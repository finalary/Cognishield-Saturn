/***************************** 
 * Saturn - Cognishield *
 *****************************/


// store info about the experiment session:
let expName = 'Saturn - CogniShield';  // from the Builder filename that created this script
let expInfo = {
    'participant': '',
};
let PILOTING = util.getUrlParameters().has('__pilotToken');

// Start code blocks for 'Before Experiment'
// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: true,
  color: new util.Color([0, 0, 0]),
  units: 'height',
  waitBlanking: true,
  backgroundImage: '',
  backgroundFit: 'none',
});
// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); },flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
flowScheduler.add(r_welcomeRoutineBegin());
flowScheduler.add(r_welcomeRoutineEachFrame());
flowScheduler.add(r_welcomeRoutineEnd());
const loop_inTime_p1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p1LoopBegin(loop_inTime_p1LoopScheduler));
flowScheduler.add(loop_inTime_p1LoopScheduler);
flowScheduler.add(loop_inTime_p1LoopEnd);






const loop_inTime_p2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p2LoopBegin(loop_inTime_p2LoopScheduler));
flowScheduler.add(loop_inTime_p2LoopScheduler);
flowScheduler.add(loop_inTime_p2LoopEnd);







const loop_inTime_p3LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p3LoopBegin(loop_inTime_p3LoopScheduler));
flowScheduler.add(loop_inTime_p3LoopScheduler);
flowScheduler.add(loop_inTime_p3LoopEnd);






const loop_inTime_p4LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p4LoopBegin(loop_inTime_p4LoopScheduler));
flowScheduler.add(loop_inTime_p4LoopScheduler);
flowScheduler.add(loop_inTime_p4LoopEnd);






const loop_inTime_p5LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p5LoopBegin(loop_inTime_p5LoopScheduler));
flowScheduler.add(loop_inTime_p5LoopScheduler);
flowScheduler.add(loop_inTime_p5LoopEnd);








const loop_inTime_p6LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p6LoopBegin(loop_inTime_p6LoopScheduler));
flowScheduler.add(loop_inTime_p6LoopScheduler);
flowScheduler.add(loop_inTime_p6LoopEnd);






const loop_inTime_p7LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p7LoopBegin(loop_inTime_p7LoopScheduler));
flowScheduler.add(loop_inTime_p7LoopScheduler);
flowScheduler.add(loop_inTime_p7LoopEnd);





const loop_inTime_p8LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p8LoopBegin(loop_inTime_p8LoopScheduler));
flowScheduler.add(loop_inTime_p8LoopScheduler);
flowScheduler.add(loop_inTime_p8LoopEnd);





const loop_inTime_p9aLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p9aLoopBegin(loop_inTime_p9aLoopScheduler));
flowScheduler.add(loop_inTime_p9aLoopScheduler);
flowScheduler.add(loop_inTime_p9aLoopEnd);





const loop_inTime_p9bLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p9bLoopBegin(loop_inTime_p9bLoopScheduler));
flowScheduler.add(loop_inTime_p9bLoopScheduler);
flowScheduler.add(loop_inTime_p9bLoopEnd);





const loop_inTime_p9cLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p9cLoopBegin(loop_inTime_p9cLoopScheduler));
flowScheduler.add(loop_inTime_p9cLoopScheduler);
flowScheduler.add(loop_inTime_p9cLoopEnd);





const loop_inTime_p10LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p10LoopBegin(loop_inTime_p10LoopScheduler));
flowScheduler.add(loop_inTime_p10LoopScheduler);
flowScheduler.add(loop_inTime_p10LoopEnd);






const loop_inTime_p11aLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p11aLoopBegin(loop_inTime_p11aLoopScheduler));
flowScheduler.add(loop_inTime_p11aLoopScheduler);
flowScheduler.add(loop_inTime_p11aLoopEnd);





const loop_inTime_p11bLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p11bLoopBegin(loop_inTime_p11bLoopScheduler));
flowScheduler.add(loop_inTime_p11bLoopScheduler);
flowScheduler.add(loop_inTime_p11bLoopEnd);





const loop_inTime_p12aLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p12aLoopBegin(loop_inTime_p12aLoopScheduler));
flowScheduler.add(loop_inTime_p12aLoopScheduler);
flowScheduler.add(loop_inTime_p12aLoopEnd);






const loop_inTime_p12bLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p12bLoopBegin(loop_inTime_p12bLoopScheduler));
flowScheduler.add(loop_inTime_p12bLoopScheduler);
flowScheduler.add(loop_inTime_p12bLoopEnd);





const loop_inTime_p12cLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p12cLoopBegin(loop_inTime_p12cLoopScheduler));
flowScheduler.add(loop_inTime_p12cLoopScheduler);
flowScheduler.add(loop_inTime_p12cLoopEnd);





const loop_inTime_p12dLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p12dLoopBegin(loop_inTime_p12dLoopScheduler));
flowScheduler.add(loop_inTime_p12dLoopScheduler);
flowScheduler.add(loop_inTime_p12dLoopEnd);





const loop_inTime_p13LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p13LoopBegin(loop_inTime_p13LoopScheduler));
flowScheduler.add(loop_inTime_p13LoopScheduler);
flowScheduler.add(loop_inTime_p13LoopEnd);















const loop_inTime_p14aLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p14aLoopBegin(loop_inTime_p14aLoopScheduler));
flowScheduler.add(loop_inTime_p14aLoopScheduler);
flowScheduler.add(loop_inTime_p14aLoopEnd);








const loop_inTime_p14bLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(loop_inTime_p14bLoopBegin(loop_inTime_p14bLoopScheduler));
flowScheduler.add(loop_inTime_p14bLoopScheduler);
flowScheduler.add(loop_inTime_p14bLoopEnd);





flowScheduler.add(r_endRoutineBegin());
flowScheduler.add(r_endRoutineEachFrame());
flowScheduler.add(r_endRoutineEnd());
flowScheduler.add(quitPsychoJS, 'Grazie per la partecipazione.', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, 'Grazie per la partecipazione.', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  resources: [
    // resources:
    {'name': 'instructions/list_instr_p5.csv', 'path': 'instructions/list_instr_p5.csv'},
    {'name': 'instructions/p5_instr_01.png', 'path': 'instructions/p5_instr_01.png'},
    {'name': 'instructions/p5_instr_02.png', 'path': 'instructions/p5_instr_02.png'},
    {'name': 'conditions/conditionsP5.csv', 'path': 'conditions/conditionsP5.csv'},
    {'name': 'conditions/conditions_Stroop_practice.csv', 'path': 'conditions/conditions_Stroop_practice.csv'},
    {'name': 'conditions/conditions_Stroop.csv', 'path': 'conditions/conditions_Stroop.csv'},
    {'name': 'instructions/list_instr_p14.csv', 'path': 'instructions/list_instr_p14.csv'},
    {'name': 'instructions/p14_instr_01.png', 'path': 'instructions/p14_instr_01.png'},
    {'name': 'instructions/p14_instr_02.png', 'path': 'instructions/p14_instr_02.png'},
    {'name': 'instructions/p14_instr_03.png', 'path': 'instructions/p14_instr_03.png'},
    {'name': 'instructions/p1a_instr_01.png', 'path': 'instructions/p1a_instr_01.png'},
    {'name': 'instructions/p1b_instr_01.png', 'path': 'instructions/p1b_instr_01.png'},
    {'name': 'instructions/p2a_instr_01.png', 'path': 'instructions/p2a_instr_01.png'},
    {'name': 'instructions/p3_instr_01.png', 'path': 'instructions/p3_instr_01.png'},
    {'name': 'instructions/p4_instr_01.png', 'path': 'instructions/p4_instr_01.png'},
    {'name': 'default.png', 'path': 'https://pavlovia.org/assets/default/default.png'},
    {'name': 'instructions/p6_instr_01.png', 'path': 'instructions/p6_instr_01.png'},
    {'name': 'instructions/p12_instr_01.png', 'path': 'instructions/p12_instr_01.png'},
    {'name': 'images/shape01_pentagon.png', 'path': 'images/shape01_pentagon.png'},
    {'name': 'images/shape02_head.png', 'path': 'images/shape02_head.png'},
    {'name': 'images/shape03_triangle.png', 'path': 'images/shape03_triangle.png'},
    {'name': 'images/shape04_square.png', 'path': 'images/shape04_square.png'},
    {'name': 'images/shape05_circle.png', 'path': 'images/shape05_circle.png'},
    {'name': 'images/shape06_hexagon.png', 'path': 'images/shape06_hexagon.png'},
    {'name': 'images/shape_tot.png', 'path': 'images/shape_tot.png'},
    {'name': 'images/face_01.png', 'path': 'images/face_01.png'},
    {'name': 'images/face_02.png', 'path': 'images/face_02.png'},
    {'name': 'images/face_03.png', 'path': 'images/face_03.png'},
    {'name': 'images/face_04.png', 'path': 'images/face_04.png'},
    {'name': 'images/face_05.png', 'path': 'images/face_05.png'},
    {'name': 'images/face_06.png', 'path': 'images/face_06.png'},
    {'name': 'images/face_tot.png', 'path': 'images/face_tot.png'},
    {'name': 'images/line_01.png', 'path': 'images/line_01.png'},
    {'name': 'images/line_02.png', 'path': 'images/line_02.png'},
    {'name': 'images/line_03.png', 'path': 'images/line_03.png'},
    {'name': 'images/line_04.png', 'path': 'images/line_04.png'},
    {'name': 'images/line_05.png', 'path': 'images/line_05.png'},
    {'name': 'images/line_06.png', 'path': 'images/line_06.png'},
    {'name': 'images/line_tot.png', 'path': 'images/line_tot.png'},
    {'name': 'images/cube_01.png', 'path': 'images/cube_01.png'},
    {'name': 'images/cube_02.png', 'path': 'images/cube_02.png'},
    {'name': 'images/cube_03.png', 'path': 'images/cube_03.png'},
    {'name': 'images/cube_04.png', 'path': 'images/cube_04.png'},
    {'name': 'images/cube_05.png', 'path': 'images/cube_05.png'},
    {'name': 'images/cube_06.png', 'path': 'images/cube_06.png'},
    {'name': 'images/cube_tot.png', 'path': 'images/cube_tot.png'},
    {'name': 'instructions/p13_instr_01.png', 'path': 'instructions/p13_instr_01.png'},
    {'name': 'instructions/p_end.png', 'path': 'instructions/p_end.png'},
    {'name': 'images/cube_01.png', 'path': 'images/cube_01.png'},
    {'name': 'images/cube_02.png', 'path': 'images/cube_02.png'},
    {'name': 'images/cube_03.png', 'path': 'images/cube_03.png'},
    {'name': 'images/cube_04.png', 'path': 'images/cube_04.png'},
    {'name': 'images/cube_05.png', 'path': 'images/cube_05.png'},
    {'name': 'images/cube_06.png', 'path': 'images/cube_06.png'},
    {'name': 'images/cube_tot.png', 'path': 'images/cube_tot.png'},
    {'name': 'images/face_01.png', 'path': 'images/face_01.png'},
    {'name': 'images/face_02.png', 'path': 'images/face_02.png'},
    {'name': 'images/face_03.png', 'path': 'images/face_03.png'},
    {'name': 'images/face_04.png', 'path': 'images/face_04.png'},
    {'name': 'images/face_05.png', 'path': 'images/face_05.png'},
    {'name': 'images/face_06.png', 'path': 'images/face_06.png'},
    {'name': 'images/face_tot.png', 'path': 'images/face_tot.png'},
    {'name': 'images/line_01.png', 'path': 'images/line_01.png'},
    {'name': 'images/line_02.png', 'path': 'images/line_02.png'},
    {'name': 'images/line_03.png', 'path': 'images/line_03.png'},
    {'name': 'images/line_04.png', 'path': 'images/line_04.png'},
    {'name': 'images/line_05.png', 'path': 'images/line_05.png'},
    {'name': 'images/line_06.png', 'path': 'images/line_06.png'},
    {'name': 'images/line_tot.png', 'path': 'images/line_tot.png'},
    {'name': 'images/shape_tot.png', 'path': 'images/shape_tot.png'},
    {'name': 'images/shape01_pentagon.png', 'path': 'images/shape01_pentagon.png'},
    {'name': 'images/shape02_head.png', 'path': 'images/shape02_head.png'},
    {'name': 'images/shape03_triangle.png', 'path': 'images/shape03_triangle.png'},
    {'name': 'images/shape04_square.png', 'path': 'images/shape04_square.png'},
    {'name': 'images/shape05_circle.png', 'path': 'images/shape05_circle.png'},
    {'name': 'images/shape06_hexagon.png', 'path': 'images/shape06_hexagon.png'},
    {'name': 'instructions/list_instr_p5.csv', 'path': 'instructions/list_instr_p5.csv'},
    {'name': 'instructions/list_instr_p14.csv', 'path': 'instructions/list_instr_p14.csv'},
    {'name': 'instructions/p_end.png', 'path': 'instructions/p_end.png'},
    {'name': 'instructions/p1a_instr_01.png', 'path': 'instructions/p1a_instr_01.png'},
    {'name': 'instructions/p1b_instr_01.png', 'path': 'instructions/p1b_instr_01.png'},
    {'name': 'instructions/p2a_instr_01.png', 'path': 'instructions/p2a_instr_01.png'},
    {'name': 'instructions/p3_instr_01.png', 'path': 'instructions/p3_instr_01.png'},
    {'name': 'instructions/p4_instr_01.png', 'path': 'instructions/p4_instr_01.png'},
    {'name': 'instructions/p5_instr_01.png', 'path': 'instructions/p5_instr_01.png'},
    {'name': 'instructions/p5_instr_02.png', 'path': 'instructions/p5_instr_02.png'},
    {'name': 'instructions/p6_instr_01.png', 'path': 'instructions/p6_instr_01.png'},
    {'name': 'instructions/p12_instr_01.png', 'path': 'instructions/p12_instr_01.png'},
    {'name': 'instructions/p13_instr_01.png', 'path': 'instructions/p13_instr_01.png'},
    {'name': 'instructions/p14_instr_01.png', 'path': 'instructions/p14_instr_01.png'},
    {'name': 'instructions/p14_instr_02.png', 'path': 'instructions/p14_instr_02.png'},
    {'name': 'instructions/p14_instr_03.png', 'path': 'instructions/p14_instr_03.png'},
    {'name': 'conditions/conditions_Stroop.csv', 'path': 'conditions/conditions_Stroop.csv'},
    {'name': 'conditions/conditions_Stroop.xlsx', 'path': 'conditions/conditions_Stroop.xlsx'},
    {'name': 'conditions/conditions_Stroop_practice.csv', 'path': 'conditions/conditions_Stroop_practice.csv'},
    {'name': 'conditions/conditionsP5.csv', 'path': 'conditions/conditionsP5.csv'},
  ]
});

psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.DEBUG);


var currentLoop;
var frameDur;
async function updateInfo() {
  currentLoop = psychoJS.experiment;  // right now there are no loops
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2025.2.4';
  expInfo['OS'] = window.navigator.platform;


  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  

  
  psychoJS.experiment.dataFileName = (("." + "/") + `data/${expInfo["participant"]}_${expName}_${expInfo["date"]}`);
  psychoJS.experiment.field_separator = ',';


  return Scheduler.Event.NEXT;
}


var r_welcomeClock;
var cBlue;
var cWhite;
var cGrey;
var cGreen;
var cDarkGreen;
var cBlack;
var cRed;
var cDarkRed;
var cAzul;
var d;
var thisYear;
var thisMonth;
var thisDay;
var maxtime;
var inTime;
var txt_welcome;
var BoxNextColor;
var BoxTryColor;
var sum;
var p1aClock;
var p1a_instr;
var p1a_mouse;
var p1a_box_next;
var p1a_txt_next;
var p1a_txt_instr;
var p1_ReadingClock;
var p1_shapeIDX;
var p1_isCorrect;
var p1_ans;
var p1_corrAns;
var p1_corrAns_Idx;
var p1_stimColors;
var p1_opNextBox;
var p1_opNextTxt;
var p1_opTryBox;
var p1_opTryTxt;
var p1_txt;
var p1_mouse;
var p1_imgSX;
var p1_imgDX;
var p1_box_next;
var p1_box_try;
var p1_txt_next;
var p1_txt_try;
var p1_inTimeClock;
var p1bClock;
var p1b_instr;
var p1b_mouse;
var p1b_box_next;
var p1b_txt_next;
var p2aClock;
var p2a_instr;
var p2a_mouse;
var p2a_box_next;
var p2a_txt_next;
var p2_Att_JWordClock;
var p2_stimIDX;
var p2_isPicked;
var p2_stimColors;
var p2_isCorrect;
var p2_ans;
var p2_ans_Idx;
var p2_corrAns;
var p2_corrAns_Idx;
var p2_countNext;
var p2_points;
var p2_corrAns_Vec;
var p2_countCorrect;
var p2_opNextBox;
var p2_opNextTxt;
var p2_opTryBox;
var p2_opTryTxt;
var p2_words;
var p2_mouse;
var p2_txt_q;
var p2_sq_10;
var p2_sq_9;
var p2_sq_8;
var p2_sq_7;
var p2_sq_6;
var p2_sq_5;
var p2_sq_4;
var p2_sq_3;
var p2_sq_2;
var p2_sq_1;
var p2_txt_1;
var p2_txt_2;
var p2_txt_3;
var p2_txt_4;
var p2_txt_5;
var p2_txt_6;
var p2_txt_7;
var p2_txt_8;
var p2_txt_9;
var p2_txt_10;
var p2_box_try;
var p2_txt_try;
var p2_box_next;
var p2_txt_next;
var p2_inTimeClock;
var p3aClock;
var p3a_instr;
var p3a_mouse;
var p3a_box_next;
var p3a_txt_next;
var p3_Att_FruitsClock;
var p3_stimIDX;
var p3_stimColors;
var p3_isPicked;
var p3_isCorrect;
var p3_ans;
var p3_ans_Idx;
var p3_corrAns;
var p3_corrAns_Idx;
var p3_countNext;
var p3_points;
var p3_corrAns_Vec;
var p3_countCorrect;
var p3_opNextBox;
var p3_opNextTxt;
var p3_opTryBox;
var p3_opTryTxt;
var p3_opTry2Txt;
var p3_words;
var p3_mouse;
var p3_txt_q;
var p3_sq_1;
var p3_sq_2;
var p3_sq_3;
var p3_sq_4;
var p3_txt_1;
var p3_txt_2;
var p3_txt_3;
var p3_txt_4;
var p3_box_try;
var p3_txt_try;
var p3_txt_try2;
var p3_box_next;
var p3_txt_next;
var p3_inTimeClock;
var p4aClock;
var p4a_instr;
var p4a_mouse;
var p4a_box_next;
var p4a_txt_next;
var p4_Att_NumpadClock;
var p4_txt_q1;
var p4_txt_q2;
var lenString_p4;
var p4_ans;
var p4_isCorrect;
var p4_keyNum;
var p4_corrAns;
var p4_points;
var p4_countNext;
var p4_opNextBox;
var p4_opNextTxt;
var p4_opTryBox;
var p4_opTryTxt;
var p4_mouse;
var p4_screen_box;
var p4_screen_txt;
var p4_key_1;
var p4_key_2;
var p4_key_3;
var p4_key_4;
var p4_key_5;
var p4_key_6;
var p4_key_7;
var p4_key_8;
var p4_key_9;
var p4_key_0;
var p4_key_DEL;
var p4_box_next;
var p4_txt_next;
var p4_box_try;
var p4_txt_try;
var p4_key_txt_1;
var p4_key_txt_2;
var p4_key_txt_3;
var p4_key_txt_4;
var p4_key_txt_5;
var p4_key_txt_6;
var p4_key_txt_7;
var p4_key_txt_8;
var p4_key_txt_9;
var p4_key_txt_0;
var p4_key_txt_DEL;
var p4_inTimeClock;
var p5aClock;
var p5a_instr;
var p5a_mouse;
var p5a_box_next;
var p5a_txt_next;
var p5_Mem_wordListClock;
var p5_txt;
var p5_inTimeClock;
var p6aClock;
var p6a_instr;
var p6a_mouse;
var p6a_box_next;
var p6a_txt_next;
var p6_IM_shapeClock;
var p6_stimIDX;
var p6_stimColors;
var p6_isPicked;
var p6_isCorrect;
var p6_ans;
var p6_ans_Idx;
var p6_corrAns;
var p6_corrAns_Idx;
var p6_countNext;
var p6_points;
var p6_corrAns_Vec;
var p6_countCorrect;
var p6_opNextBox;
var p6_opNextTxt;
var p6_opTryBox;
var p6_opTryTxt;
var p6_words;
var p6_mouse;
var p6_txt_q;
var p6_sq_1;
var p6_sq_2;
var p6_sq_3;
var p6_sq_4;
var p6_sq_5;
var p6_sq_6;
var p6_txt_1;
var p6_txt_2;
var p6_txt_3;
var p6_txt_4;
var p6_txt_5;
var p6_txt_6;
var p6_box_next;
var p6_box_try;
var p6_txt_next;
var p6_txt_try;
var p6_inTimeClock;
var p7_IM_jwordClock;
var p7_txt_q;
var p7_stimIDX;
var p7_isPicked;
var p7_stimColors;
var p7_isCorrect;
var p7_ans;
var p7_ans_Idx;
var p7_corrAns;
var p7_corrAns_Idx;
var p7_countNext;
var p7_points;
var p7_corrAns_Vec;
var p7_countCorrect;
var p7_opNextBox;
var p7_opNextTxt;
var p7_opTryBox;
var p7_opTryTxt;
var p7_words;
var p7_mouse;
var p7_sq_10;
var p7_sq_9;
var p7_sq_8;
var p7_sq_7;
var p7_sq_6;
var p7_sq_5;
var p7_sq_4;
var p7_sq_3;
var p7_sq_2;
var p7_sq_1;
var p7_txt_1;
var p7_txt_2;
var p7_txt_3;
var p7_txt_4;
var p7_txt_5;
var p7_txt_6;
var p7_txt_7;
var p7_txt_8;
var p7_txt_9;
var p7_txt_10;
var p7_box_next;
var p7_txt_next;
var p7_box_try;
var p7_txt_try;
var p7_inTimeClock;
var p8_IM_numberClock;
var p8_txt_q;
var lenString_p8;
var p8_ans;
var p8_isCorrect;
var p8_keyNum;
var p8_corrAns;
var p8_countNext;
var p8_points;
var p8_opTryBox;
var p8_opTryTxt;
var p8_opNextBox;
var p8_opNextTxt;
var p8_mouse;
var p8_screen_box;
var p8_screen_txt;
var p8_key_1;
var p8_key_2;
var p8_key_3;
var p8_key_4;
var p8_key_5;
var p8_key_6;
var p8_key_7;
var p8_key_8;
var p8_key_9;
var p8_key_0;
var p8_key_DEL;
var p8_box_next;
var p8_txt_next;
var p8_box_try;
var p8_txt_try;
var p8_key_txt_1;
var p8_key_txt_2;
var p8_key_txt_3;
var p8_key_txt_4;
var p8_key_txt_5;
var p8_key_txt_6;
var p8_key_txt_7;
var p8_key_txt_8;
var p8_key_txt_9;
var p8_key_txt_0;
var p8_key_txt_DEL;
var p8_inTimeClock;
var p9_ST_monthClock;
var p9a_words;
var p9a_stimIDX;
var p9a_isPicked;
var p9a_stimColors;
var p9a_isCorrect;
var p9a_corrAns_Idx;
var p9a_corrAns;
var p9a_ans;
var p9a_ans_Idx;
var p9a_countNext;
var p9a_points;
var p9a_opTryBox;
var p9a_opTryTxt;
var p9a_opNextBox;
var p9a_opNextTxt;
var p9a_sq_1;
var p9a_sq_2;
var p9a_sq_3;
var p9a_sq_4;
var p9a_sq_5;
var p9a_sq_6;
var p9a_sq_7;
var p9a_sq_8;
var p9a_sq_9;
var p9a_sq_10;
var p9a_sq_11;
var p9a_sq_12;
var p9a_txt_1;
var p9a_txt_2;
var p9a_txt_3;
var p9a_txt_4;
var p9a_txt_5;
var p9a_txt_6;
var p9a_txt_7;
var p9a_txt_8;
var p9a_txt_9;
var p9a_txt_10;
var p9a_txt_11;
var p9a_txt_12;
var p9a_mouse;
var p9a_txt_q;
var p9a_box_next;
var p9a_txt_next;
var p9a_box_try;
var p9a_txt_try;
var p9a_inTimeClock;
var p9_ST_yearClock;
var p9b_txt_q;
var p9b_corrAns_Idx;
var p9b_corrAns;
var lenString_p9b;
var p9b_ans;
var p9b_isCorrect;
var p9b_keyNum;
var p9b_countNext;
var p9b_points;
var p9b_opTryBox;
var p9b_opTryTxt;
var p9b_opNextBox;
var p9b_opNextTxt;
var p9b_mouse;
var p9b_screen_box;
var p9b_screen_txt;
var p9b_key_1;
var p9b_key_2;
var p9b_key_3;
var p9b_key_4;
var p9b_key_5;
var p9b_key_6;
var p9b_key_7;
var p9b_key_8;
var p9b_key_9;
var p9b_key_0;
var p9b_key_DEL;
var p9b_box_next;
var p9b_txt_next;
var p9b_box_try;
var p9b_txt_try;
var p9b_key_txt_1;
var p9b_key_txt_2;
var p9b_key_txt_3;
var p9b_key_txt_4;
var p9b_key_txt_5;
var p9b_key_txt_6;
var p9b_key_txt_7;
var p9b_key_txt_8;
var p9b_key_txt_9;
var p9b_key_txt_0;
var p9b_key_txt_DEL;
var p9b_inTimeClock;
var p9_ST_dayClock;
var p9c_words;
var p9c_stimIDX;
var p9c_isPicked;
var p9c_stimColors;
var p9c_isCorrect;
var p9c_corrAns_Idx;
var p9c_corrAns;
var p9c_ans;
var p9c_ans_Idx;
var p9c_countNext;
var p9c_points;
var p9c_opTryBox;
var p9c_opTryTxt;
var p9c_opNextBox;
var p9c_opNextTxt;
var p9c_sq_1;
var p9c_sq_2;
var p9c_sq_3;
var p9c_sq_4;
var p9c_sq_5;
var p9c_sq_6;
var p9c_sq_7;
var p9c_txt_1;
var p9c_txt_2;
var p9c_txt_3;
var p9c_txt_4;
var p9c_txt_5;
var p9c_txt_6;
var p9c_txt_7;
var p9c_mouse;
var p9c_txt_q;
var p9c_box_next;
var p9c_txt_next;
var p9c_box_try;
var p9c_txt_try;
var p9c_inTimeClock;
var bufferClock;
var text;
var mouse;
var p10_MEM_wordListClock;
var p10_stimIDX;
var p10_isPicked;
var p10_stimColors;
var p10_isCorrect;
var p10_ans;
var p10_ans_Idx;
var p10_corrAns;
var p10_corrAns_Idx;
var p10_countNext;
var p10_points;
var p10_corrAns_Vec;
var p10_countCorrect;
var p10_words;
var p10_opTryBox;
var p10_opTryTxt;
var p10_opTryManyTxt;
var p10_opNextBox;
var p10_opNextTxt;
var p10_mouse;
var p10_txt_q;
var p10_sq11;
var p10_sq21;
var p10_sq31;
var p10_sq41;
var p10_sq51;
var p10_sq61;
var p10_sq71;
var p10_sq81;
var p10_sq91;
var p10_sq101;
var p10_sq111;
var p10_sq121;
var p10_sq131;
var p10_sq141;
var p10_sq151;
var p10_sq161;
var p10_sq171;
var p10_sq12;
var p10_sq22;
var p10_sq32;
var p10_sq42;
var p10_sq52;
var p10_sq62;
var p10_sq72;
var p10_sq82;
var p10_sq92;
var p10_sq102;
var p10_sq112;
var p10_sq122;
var p10_sq132;
var p10_sq142;
var p10_sq152;
var p10_sq162;
var p10_sq172;
var p10_sq13;
var p10_sq23;
var p10_sq33;
var p10_sq43;
var p10_sq53;
var p10_sq63;
var p10_sq73;
var p10_sq83;
var p10_sq93;
var p10_sq103;
var p10_sq113;
var p10_sq123;
var p10_sq133;
var p10_sq143;
var p10_sq153;
var p10_sq163;
var p10_sq173;
var p10_sq14;
var p10_sq24;
var p10_sq34;
var p10_sq44;
var p10_sq54;
var p10_sq64;
var p10_sq74;
var p10_sq84;
var p10_sq94;
var p10_sq104;
var p10_sq114;
var p10_sq124;
var p10_sq134;
var p10_sq144;
var p10_sq154;
var p10_sq164;
var p10_sq174;
var p10_sq15;
var p10_sq25;
var p10_sq35;
var p10_sq45;
var p10_sq55;
var p10_sq65;
var p10_sq75;
var p10_sq85;
var p10_sq95;
var p10_sq105;
var p10_sq115;
var p10_sq125;
var p10_sq135;
var p10_sq145;
var p10_sq155;
var p10_sq165;
var p10_sq175;
var p10_sq16;
var p10_sq26;
var p10_sq36;
var p10_sq46;
var p10_sq56;
var p10_sq66;
var p10_sq76;
var p10_sq86;
var p10_sq96;
var p10_sq106;
var p10_sq116;
var p10_sq126;
var p10_sq136;
var p10_sq146;
var p10_sq156;
var p10_txt1;
var p10_txt2;
var p10_txt3;
var p10_txt4;
var p10_txt5;
var p10_txt6;
var p10_txt7;
var p10_txt8;
var p10_txt9;
var p10_txt10;
var p10_txt11;
var p10_txt12;
var p10_txt13;
var p10_txt14;
var p10_txt15;
var p10_txt16;
var p10_txt17;
var p10_txt18;
var p10_txt19;
var p10_txt20;
var p10_txt21;
var p10_txt22;
var p10_txt23;
var p10_txt24;
var p10_txt25;
var p10_txt26;
var p10_txt27;
var p10_txt28;
var p10_txt29;
var p10_txt30;
var p10_txt31;
var p10_txt32;
var p10_txt33;
var p10_txt34;
var p10_txt35;
var p10_txt36;
var p10_txt37;
var p10_txt38;
var p10_txt39;
var p10_txt40;
var p10_txt41;
var p10_txt42;
var p10_txt43;
var p10_txt44;
var p10_txt45;
var p10_txt46;
var p10_txt47;
var p10_txt48;
var p10_txt49;
var p10_txt50;
var p10_txt51;
var p10_txt52;
var p10_txt53;
var p10_txt54;
var p10_txt55;
var p10_txt56;
var p10_txt57;
var p10_txt58;
var p10_txt59;
var p10_txt60;
var p10_txt61;
var p10_txt62;
var p10_txt63;
var p10_txt64;
var p10_txt65;
var p10_txt66;
var p10_txt67;
var p10_txt68;
var p10_txt69;
var p10_txt70;
var p10_txt71;
var p10_txt72;
var p10_txt73;
var p10_txt74;
var p10_txt75;
var p10_txt76;
var p10_txt77;
var p10_txt78;
var p10_txt79;
var p10_txt80;
var p10_txt81;
var p10_txt82;
var p10_txt83;
var p10_txt84;
var p10_txt85;
var p10_txt86;
var p10_txt87;
var p10_txt88;
var p10_txt89;
var p10_txt90;
var p10_txt91;
var p10_txt92;
var p10_txt93;
var p10_txt94;
var p10_txt95;
var p10_txt96;
var p10_txt97;
var p10_txt98;
var p10_txt99;
var p10_txt100;
var p10_box_next;
var p10_box_try;
var p10_txt_try;
var p10_txt_next;
var p10_txt_try_many;
var p10_inTimeClock;
var p11a_CALC_sumClock;
var p11a_txt_q;
var lenString_p11a;
var p11a_ans;
var p11a_isCorrect;
var p11a_keyNum;
var p11a_corrAns;
var p11a_countNext;
var p11a_points;
var p11a_opTryBox;
var p11a_opTryTxt;
var p11a_opNextBox;
var p11a_opNextTxt;
var p11a_mouse;
var p11a_screen_box;
var p11a_screen_txt;
var p11a_key_1;
var p11a_key_2;
var p11a_key_3;
var p11a_key_4;
var p11a_key_5;
var p11a_key_6;
var p11a_key_7;
var p11a_key_8;
var p11a_key_9;
var p11a_key_0;
var p11a_key_DEL;
var p11a_box_next;
var p11a_txt_next;
var p11a_box_try;
var p11a_txt_try;
var p11a_key_txt_1;
var p11a_key_txt_2;
var p11a_key_txt_3;
var p11a_key_txt_4;
var p11a_key_txt_5;
var p11a_key_txt_6;
var p11a_key_txt_7;
var p11a_key_txt_8;
var p11a_key_txt_9;
var p11a_key_txt_0;
var p11a_key_txt_DEL;
var p11a_inTimeClock;
var p11b_CALC_diffClock;
var p11b_txt_q;
var p11b_ans;
var lenString_p11b;
var p11b_isCorrect;
var p11b_keyNum;
var p11b_corrAns;
var p11b_countNext;
var p11b_points;
var p11b_opTryBox;
var p11b_opTryTxt;
var p11b_opNextBox;
var p11b_opNextTxt;
var p11b_mouse;
var p11b_screen_box;
var p11b_screen_txt;
var p11b_key_1;
var p11b_key_2;
var p11b_key_3;
var p11b_key_4;
var p11b_key_5;
var p11b_key_6;
var p11b_key_7;
var p11b_key_8;
var p11b_key_9;
var p11b_key_0;
var p11b_key_DEL;
var p11b_box_next;
var p11b_txt_next;
var p11b_box_try;
var p11b_txt_try;
var p11b_key_txt_1;
var p11b_key_txt_2;
var p11b_key_txt_3;
var p11b_key_txt_4;
var p11b_key_txt_5;
var p11b_key_txt_6;
var p11b_key_txt_7;
var p11b_key_txt_8;
var p11b_key_txt_9;
var p11b_key_txt_0;
var p11b_key_txt_DEL;
var p11b_inTimeClock;
var p12Clock;
var p12_img_instr;
var p12_mouse;
var p12_box_next;
var p12_txt_next;
var p12a_VS_shapesClock;
var p12a_stimIDX;
var p12a_isPicked;
var p12a_stimColors;
var p12a_isCorrect;
var p12a_ans;
var p12a_ans_Idx;
var p12a_corrAns;
var p12a_corrAns_Idx;
var p12a_countNext;
var p12a_points;
var p12a_corrAns_Vec;
var p12a_countCorrect;
var p12a_words;
var p12a_opTryBox;
var p12a_opTryTxt;
var p12a_opTryManyTxt;
var p12a_opNextBox;
var p12a_opNextTxt;
var p12a_sq6;
var p12a_sq5;
var p12a_sq4;
var p12a_sq3;
var p12a_sq2;
var p12a_sq1;
var p12a_txb_q1;
var p12a_txt_q1;
var p12a_img_1;
var p12a_img_2;
var p12a_img_3;
var p12a_img_4;
var p12a_img_5;
var p12a_img_6;
var p12a_img_whole;
var p12a_box_next;
var p12a_txt_next;
var p12a_box_try;
var p12a_txt_try;
var p12a_txt_try_many;
var p12a_mouse;
var p12a_inTimeClock;
var p12b_VS_facesClock;
var p12b_stimIDX;
var p12b_isPicked;
var p12b_stimColors;
var p12b_isCorrect;
var p12b_ans;
var p12b_ans_Idx;
var p12b_corrAns;
var p12b_corrAns_Idx;
var p12b_countNext;
var p12b_points;
var p12b_corrAns_Vec;
var p12b_countCorrect;
var p12b_words;
var p12b_opTryBox;
var p12b_opTryTxt;
var p12b_opTryManyTxt;
var p12b_opNextBox;
var p12b_opNextTxt;
var p12b_sq6;
var p12b_sq5;
var p12b_sq4;
var p12b_sq3;
var p12b_sq2;
var p12b_sq1;
var p12b_txb_q1;
var p12b_txt_q1;
var p12b_img_1;
var p12b_img_2;
var p12b_img_3;
var p12b_img_4;
var p12b_img_5;
var p12b_img_6;
var p12b_img_whole;
var p12b_box_next;
var p12b_txt_next;
var p12b_box_try;
var p12b_txt_try;
var p12b_txt_try_many;
var p12b_mouse;
var p12b_inTimeClock;
var p12c_VS_linesClock;
var p12c_stimIDX;
var p12c_isPicked;
var p12c_stimColors;
var p12c_isCorrect;
var p12c_ans;
var p12c_ans_Idx;
var p12c_corrAns;
var p12c_corrAns_Idx;
var p12c_countNext;
var p12c_points;
var p12c_corrAns_Vec;
var p12c_countCorrect;
var p12c_words;
var p12c_opTryBox;
var p12c_opTryTxt;
var p12c_opTryManyTxt;
var p12c_opNextBox;
var p12c_opNextTxt;
var p12c_sq6;
var p12c_sq5;
var p12c_sq4;
var p12c_sq3;
var p12c_sq2;
var p12c_sq1;
var p12c_txb_q1;
var p12c_txt_q1;
var p12c_img_1;
var p12c_img_2;
var p12c_img_3;
var p12c_img_4;
var p12c_img_5;
var p12c_img_6;
var p12c_img_whole;
var p12c_box_next;
var p12c_txt_next;
var p12c_box_try;
var p12c_txt_try;
var p12c_txt_try_many;
var p12c_mouse;
var p12c_inTimeClock;
var p12d_VS_cubesClock;
var p12d_stimIDX;
var p12d_isPicked;
var p12d_stimColors;
var p12d_isCorrect;
var p12d_ans;
var p12d_ans_Idx;
var p12d_corrAns;
var p12d_corrAns_Idx;
var p12d_countNext;
var p12d_points;
var p12d_corrAns_Vec;
var p12d_countCorrect;
var p12d_words;
var p12d_opTryBox;
var p12d_opTryTxt;
var p12d_opTryManyTxt;
var p12d_opNextBox;
var p12d_opNextTxt;
var p12d_sq6;
var p12d_sq5;
var p12d_sq4;
var p12d_sq3;
var p12d_sq2;
var p12d_sq1;
var p12d_txb_q1;
var p12d_txt_q1;
var p12d_img_1;
var p12d_img_2;
var p12d_img_3;
var p12d_img_4;
var p12d_img_5;
var p12d_img_6;
var p12d_img_whole;
var p12d_box_next;
var p12d_txt_next;
var p12d_box_try;
var p12d_txt_try;
var p12d_txt_try_many;
var p12d_mouse;
var p12d_inTimeClock;
var p13Clock;
var p13_img_instr;
var p13_mouse;
var p13_box_next;
var p13_txt_next;
var p13_leadinClock;
var text_2;
var p13a_Stroop_practiceClock;
var p13a_stimIDX;
var p13a_isPicked;
var p13a_stimColors;
var p13a_isCorrect;
var p13a_ans;
var p13a_ans_Idx;
var p13a_countNext;
var p13a_points;
var p13a_words;
var p13a_opTryBox;
var p13a_opTryTxt;
var p13a_opNextBox;
var p13a_opNextTxt;
var p13a_txb1;
var p13a_txb2;
var p13a_txb3;
var p13a_box_next;
var p13a_txt_next;
var p13a_box_try;
var p13a_txt_try;
var p13a_mouse;
var p13a_txt1;
var p13a_txt2;
var p13a_txt3;
var p13a_box_word;
var p13a_txt_word;
var p13b_StroopClock;
var p13b_stimIDX;
var p13b_isPicked;
var p13b_stimColors;
var p13b_isCorrect;
var p13b_ans;
var p13b_ans_Idx;
var p13b_countNext;
var p13b_points;
var p13b_words;
var p13b_opTryBox;
var p13b_opTryTxt;
var p13b_opNextBox;
var p13b_opNextTxt;
var p13b_txb1;
var p13b_txb2;
var p13b_txb3;
var p13b_box_next;
var p13b_txt_next;
var p13b_box_try;
var p13b_txt_try;
var p13b_mouse;
var p13b_txt1;
var p13b_txt2;
var p13b_txt3;
var p13b_box_word;
var p13b_txt_word;
var p13_inTimeClock;
var p14_TMTClock;
var p14_img_instr;
var p14_box_next;
var p14_txt_next;
var p14_mouse;
var p14a_TMT_NumbersClock;
var p14a_txt_instr1;
var p14a_txt_instr2;
var p14a_ans;
var lenString_p14a;
var p14a_isCorrect;
var p14a_keyNum;
var p14a_corrAns;
var p14a_stringCorr;
var p14a_isPicked;
var p14a_nErrors;
var p14a_countNext;
var p14a_points;
var p14a_stimIDX;
var p14a_stimColors;
var p14a_opTryBox;
var p14a_opTryTxt;
var p14a_opNextBox;
var p14a_opNextTxt;
var p14a_sq1;
var p14a_sq2;
var p14a_sq3;
var p14a_sq4;
var p14a_sq5;
var p14a_txt1;
var p14a_txt2;
var p14a_txt3;
var p14a_txt4;
var p14a_txt5;
var p14a_txtEND;
var p14a_txtSTART;
var p14a_box_try;
var p14a_box_next;
var p14a_txt_next;
var p14a_txt_try;
var p14a_mouse;
var p14a_inTimeClock;
var p14b_TMT_LettersClock;
var p14b_txt_instr1;
var p14b_txt_instr2;
var p14b_ans;
var lenString_p14b;
var p14b_isCorrect;
var p14b_keyNum;
var p14b_corrAns;
var p14b_isPicked;
var p14b_nErrors;
var p14b_countNext;
var p14b_points;
var p14b_stimIDX;
var p14b_stimColors;
var p14b_opTryBox;
var p14b_opTryTxt;
var p14b_opNextBox;
var p14b_opNextTxt;
var p14b_sq1;
var p14b_sqA;
var p14b_sq2;
var p14b_sqB;
var p14b_sq3;
var p14b_sqC;
var p14b_sq4;
var p14b_sqD;
var p14b_txt1;
var p14b_txtA;
var p14b_txt2;
var p14b_txtB;
var p14b_txt3;
var p14b_txtC;
var p14b_txt4;
var p14b_txtD;
var p14b_txtEND;
var p14b_txtSTART;
var p14b_box_try;
var p14b_box_next;
var p14b_txt_next;
var p14b_txt_try;
var p14b_mouse;
var p14b_inTimeClock;
var r_endClock;
var pEND_img_instr;
var globalClock;
var routineTimer;
async function experimentInit() {
  // Initialize components for Routine "r_welcome"
  r_welcomeClock = new util.Clock();
  // Run 'Begin Experiment' code from code_Both
  // Define colors to use througout the test
  // RED, BLUE, GREEN, AZUL
  cBlue = new util.Color([-1,-1,1]);
  cWhite = new util.Color([1, 1, 1]);
  cGrey = new util.Color([0,0,0]);
  cGreen = new util.Color([0,1,0]);
  cDarkGreen = new util.Color([-1, 0.00392156862745097, -1]);
  cBlack = new util.Color([-1, -1, -1]);
  cRed = new util.Color([1,-0.2,-0.2]);
  cDarkRed = new util.Color([1,-1,-1]);
  cAzul = new util.Color([-0.254901960784314, 0.23921568627451, 0.254901960784314]);
  
  // to check time and date
  d = new Date();
  thisYear = d.getFullYear() 
  thisMonth = (d.getMonth()+1)
  thisDay = d.getDay()
  
  // to set time limit for completion in seconds
  maxtime = 60*30
  inTime = 1
  
  txt_welcome = new visual.TextStim({
    win: psychoJS.window,
    name: 'txt_welcome',
    text: 'Benvenuti su SATURN\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.1,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Run 'Begin Experiment' code from code_EXP
  BoxNextColor = cGreen;
  BoxTryColor = cRed;
  
  sum = function (arr) {
  return arr.reduce((a,b)=>a+b)
  }
  
  // Initialize components for Routine "p1a"
  p1aClock = new util.Clock();
  p1a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p1a_instr', units : undefined, 
    image : 'instructions/p1a_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p1a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p1a_mouse.mouseClock = new util.Clock();
  p1a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p1a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.45, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p1a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.3)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  p1a_txt_instr = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1a_txt_instr',
    text: 'ASSICURATI CHE IL TABLET SIA ORIENTATO IN ORIZZONTALE',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], draggable: false, height: 0.03,  wrapWidth: 1.5, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  // Initialize components for Routine "p1_Reading"
  p1_ReadingClock = new util.Clock();
  // Run 'Begin Experiment' code from p1_code
  p1_shapeIDX = [1, 2];
  p1_isCorrect = 0;
  p1_ans = "";
  p1_isCorrect = 0;
  p1_corrAns = "square";
  p1_corrAns_Idx = 2;
  p1_stimColors = {};
  p1_opNextBox = 1;
  p1_opNextTxt = 1;
  p1_opTryBox = 0;
  p1_opTryTxt = 0;
  for (var k, _pj_c = 0, _pj_a = p1_shapeIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p1_stimColors[k] = cWhite;
  }
  
  p1_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1_txt',
    text: 'Tocca il QUADRATO per procedere',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], draggable: false, height: 0.06,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  p1_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p1_mouse.mouseClock = new util.Clock();
  p1_imgSX = new visual.ShapeStim ({
    win: psychoJS.window, name: 'p1_imgSX', 
    vertices: [[-[0.3, 0.3][0]/2.0, -[0.3, 0.3][1]/2.0], [+[0.3, 0.3][0]/2.0, -[0.3, 0.3][1]/2.0], [0, [0.3, 0.3][1]/2.0]],
    ori: 0, 
    pos: [(- 0.3), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p1_imgDX = new visual.Rect ({
    win: psychoJS.window, name: 'p1_imgDX', 
    width: [0.3, 0.3][0], height: [0.3, 0.3][1],
    ori: 0, 
    pos: [0.3, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p1_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p1_box_next', 
    width: [0.65, 0.05][0], height: [0.65, 0.05][1],
    ori: 0, 
    pos: [0.35, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -5, 
    interpolate: true, 
  });
  
  p1_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p1_box_try', 
    width: [0.6, 0.05][0], height: [0.6, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -6, 
    interpolate: true, 
  });
  
  p1_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1_txt_next',
    text: 'Tocca AVANTI per continuare…',
    font: 'Arial',
    units: undefined, 
    pos: [0.35, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -7.0 
  });
  
  p1_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1_txt_try',
    text: 'OOPS! PROVA DI NUOVO!',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -8.0 
  });
  
  // Initialize components for Routine "p1_inTime"
  p1_inTimeClock = new util.Clock();
  // Initialize components for Routine "p1b"
  p1bClock = new util.Clock();
  p1b_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p1b_instr', units : undefined, 
    image : 'instructions/p1b_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p1b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p1b_mouse.mouseClock = new util.Clock();
  p1b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p1b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.45, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p1b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p1b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.3)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p2a"
  p2aClock = new util.Clock();
  p2a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p2a_instr', units : undefined, 
    image : 'instructions/p2a_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p2a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p2a_mouse.mouseClock = new util.Clock();
  p2a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p2a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p2a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p2_Att_JWord"
  p2_Att_JWordClock = new util.Clock();
  // Run 'Begin Experiment' code from p2_code
  p2_stimIDX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  p2_isPicked = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p2_stimColors = {};
  p2_isCorrect = 0;
  p2_ans = "";
  p2_ans_Idx = [];
  p2_corrAns = "GITA";
  p2_corrAns_Idx = [5];
  p2_countNext = 0;
  p2_points = 0;
  p2_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p2_corrAns_Vec[5] = 1;
  p2_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p2_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p2_stimColors[k] = cGrey;
  }
  p2_opNextBox = 1;
  p2_opNextTxt = 1;
  p2_opTryBox = 0;
  p2_opTryTxt = 0;
  p2_words = ["", "TOPO", "LATO", "ARIA", "NODO", "GITA", "PALO", "MODA", "SEDE", "CANE", "VINO"];
  
  p2_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p2_mouse.mouseClock = new util.Clock();
  p2_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_q',
    text: 'SCEGLI LA PAROLA\nCHE COMINCIA CON G',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], draggable: false, height: 0.06,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  p2_sq_10 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_10', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p2_sq_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_9', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p2_sq_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_8', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p2_sq_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_7', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p2_sq_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_6', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p2_sq_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_5', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p2_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_4', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p2_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_3', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p2_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_2', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p2_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p2_sq_1', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p2_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.2], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  p2_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.1], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -14.0 
  });
  
  p2_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -15.0 
  });
  
  p2_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.1)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  p2_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_5',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.2)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -17.0 
  });
  
  p2_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_6',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.2], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -18.0 
  });
  
  p2_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_7',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.1], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -19.0 
  });
  
  p2_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_8',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.0], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  p2_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_9',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.1)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -21.0 
  });
  
  p2_txt_10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_10',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.2)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -22.0 
  });
  
  p2_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p2_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -23, 
    interpolate: true, 
  });
  
  p2_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_try',
    text: 'NON ANCORA.\nPER CONTINUARE, DEVI SCEGLIERE LA PAROLA CHE COMINCIA CON “G”.\n\nTOCCA LA PAROLA E DIVENTERA’ BLU. ',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -24.0 
  });
  
  p2_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p2_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -26, 
    interpolate: true, 
  });
  
  p2_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p2_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -27.0 
  });
  
  // Initialize components for Routine "p2_inTime"
  p2_inTimeClock = new util.Clock();
  // Initialize components for Routine "p3a"
  p3aClock = new util.Clock();
  p3a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p3a_instr', units : undefined, 
    image : 'instructions/p3_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p3a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p3a_mouse.mouseClock = new util.Clock();
  p3a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p3a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p3a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p3_Att_Fruits"
  p3_Att_FruitsClock = new util.Clock();
  // Run 'Begin Experiment' code from p3_code
  p3_stimIDX = [1, 2, 3, 4];
  p3_stimColors = {};
  p3_isPicked = [0, 0, 0, 0, 0];
  p3_isCorrect = 0;
  p3_ans = "";
  p3_ans_Idx = [];
  p3_corrAns = ["BANANA", "MELA"];
  p3_corrAns_Idx = [1, 3];
  p3_countNext = 0;
  p3_points = 0;
  p3_corrAns_Vec = [0, 0, 0, 0, 0];
  p3_corrAns_Vec[1] = 1;
  p3_corrAns_Vec[1] = 3;
  p3_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p3_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p3_stimColors[k] = [0, 0, 0];
  }
  p3_opNextBox = 1;
  p3_opNextTxt = 1;
  p3_opTryBox = 0;
  p3_opTryTxt = 0;
  p3_opTry2Txt = 0;
  p3_words = ["", "BANANA", "SABBIA", "MELA", "LUCE"];
  
  p3_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p3_mouse.mouseClock = new util.Clock();
  p3_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_q',
    text: 'SCEGLI LE PAROLE\nRIFERITE AI FRUTTI',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], draggable: false, height: 0.06,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  p3_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p3_sq_1', 
    width: [0.2, 0.05][0], height: [0.2, 0.05][1],
    ori: 0, 
    pos: [0.0, (+ 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p3_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p3_sq_2', 
    width: [0.2, 0.05][0], height: [0.2, 0.05][1],
    ori: 0, 
    pos: [0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p3_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p3_sq_3', 
    width: [0.2, 0.05][0], height: [0.2, 0.05][1],
    ori: 0, 
    pos: [0.0, (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p3_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p3_sq_4', 
    width: [0.2, 0.05][0], height: [0.2, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p3_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -7.0 
  });
  
  p3_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -8.0 
  });
  
  p3_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -9.0 
  });
  
  p3_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -10.0 
  });
  
  p3_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p3_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -11, 
    interpolate: true, 
  });
  
  p3_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_try',
    text: 'NON ANCORA.\nPER CONTINUARE, SCEGLI SOLO LE PAROLE RIFERITE AI FRUTTI.\n\nPER DE-SELEZIONARE UNA PAROLA, TOCCALA DI NUOVO. ',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -12.0 
  });
  
  p3_txt_try2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_try2',
    text: 'NON ANCORA. \nPER CONTINUARE, TOCCA ENTRAMBE LE PAROLE RIFERITE AI FRUTTI.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -13.0 
  });
  
  p3_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p3_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -15, 
    interpolate: true, 
  });
  
  p3_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p3_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -16.0 
  });
  
  // Initialize components for Routine "p3_inTime"
  p3_inTimeClock = new util.Clock();
  // Initialize components for Routine "p4a"
  p4aClock = new util.Clock();
  p4a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p4a_instr', units : undefined, 
    image : 'instructions/p4_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p4a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p4a_mouse.mouseClock = new util.Clock();
  p4a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p4a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p4a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.3)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p4_Att_Numpad"
  p4_Att_NumpadClock = new util.Clock();
  p4_txt_q1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_txt_q1',
    text: 'DIGITA IL NUMERO',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.42], draggable: false, height: 0.06,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  p4_txt_q2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_txt_q2',
    text: '1239',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.35], draggable: false, height: 0.06,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([1, 0, 0]),  opacity: 1,
    depth: -1.0 
  });
  
  // Run 'Begin Experiment' code from p4_code
  lenString_p4 = 0;
  p4_ans = "";
  p4_isCorrect = 0;
  p4_keyNum = ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "DEL"];
  p4_corrAns = "1239";
  p4_points = 0;
  p4_countNext = 0;
  p4_opNextBox = 1;
  p4_opNextTxt = 1;
  p4_opTryBox = 0;
  p4_opTryTxt = 0;
  
  p4_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p4_mouse.mouseClock = new util.Clock();
  p4_screen_box = new visual.Rect ({
    win: psychoJS.window, name: 'p4_screen_box', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0, 0.12], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 3, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p4_screen_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_screen_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.12], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -5.0 
  });
  
  p4_key_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_1', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p4_key_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_2', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p4_key_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_3', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p4_key_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_4', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p4_key_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_5', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p4_key_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_6', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p4_key_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_7', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p4_key_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_8', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p4_key_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_9', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p4_key_0 = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_0', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p4_key_DEL = new visual.Rect ({
    win: psychoJS.window, name: 'p4_key_DEL', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.05, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -16, 
    interpolate: true, 
  });
  
  p4_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p4_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -17, 
    interpolate: true, 
  });
  
  p4_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -18.0 
  });
  
  p4_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p4_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -19, 
    interpolate: true, 
  });
  
  p4_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_txt_try',
    text: 'NON ANCORA!\n\nPER CONTINUARE, DIGITA IL NUMERO CORRETTO',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  p4_key_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -21.0 
  });
  
  p4_key_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -22.0 
  });
  
  p4_key_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -23.0 
  });
  
  p4_key_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -24.0 
  });
  
  p4_key_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -25.0 
  });
  
  p4_key_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -26.0 
  });
  
  p4_key_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_7',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -27.0 
  });
  
  p4_key_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_8',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0.0, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -28.0 
  });
  
  p4_key_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_9',
    text: '9',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -29.0 
  });
  
  p4_key_txt_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -30.0 
  });
  
  p4_key_txt_DEL = new visual.TextStim({
    win: psychoJS.window,
    name: 'p4_key_txt_DEL',
    text: 'CANCELLA',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -31.0 
  });
  
  // Initialize components for Routine "p4_inTime"
  p4_inTimeClock = new util.Clock();
  // Initialize components for Routine "p5a"
  p5aClock = new util.Clock();
  p5a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p5a_instr', units : undefined, 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p5a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p5a_mouse.mouseClock = new util.Clock();
  p5a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p5a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p5a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p5a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p5_Mem_wordList"
  p5_Mem_wordListClock = new util.Clock();
  p5_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p5_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.1,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "p5_inTime"
  p5_inTimeClock = new util.Clock();
  // Initialize components for Routine "p6a"
  p6aClock = new util.Clock();
  p6a_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p6a_instr', units : undefined, 
    image : 'instructions/p6_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p6a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p6a_mouse.mouseClock = new util.Clock();
  p6a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p6a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p6a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p6_IM_shape"
  p6_IM_shapeClock = new util.Clock();
  // Run 'Begin Experiment' code from p6_code
  p6_stimIDX = [1, 2, 3, 4, 5, 6];
  p6_stimColors = {};
  p6_isPicked = [0, 0, 0, 0, 0, 0, 0];
  p6_isCorrect = 0;
  p6_ans = "";
  p6_ans_Idx = [];
  p6_corrAns = ["SQUARE"];
  p6_corrAns_Idx = "3";
  p6_countNext = 0;
  p6_points = 0;
  p6_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0];
  p6_corrAns_Vec[3] = 1;
  p6_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p6_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p6_stimColors[k] = cGrey;
  }
  p6_opNextBox = 1;
  p6_opNextTxt = 1;
  p6_opTryBox = 0;
  p6_opTryTxt = 0;
  p6_words = [" ", "CERCHIO", "TRIANGOLO", "QUADRATO", "STELLA", "CROCE", "PENTAGONO"];
  
  p6_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p6_mouse.mouseClock = new util.Clock();
  p6_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_q',
    text: 'PRIMA, QUALE FORMA TI E’ STATO CHIESTO \nDI SCEGLIERE SULLO SCHERMO?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.75], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  p6_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_1', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0.0, (+ 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p6_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_2', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0, 0.15], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p6_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_3', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0.0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p6_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_4', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p6_sq_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_5', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p6_sq_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p6_sq_6', 
    width: [0.4, 0.05][0], height: [0.4, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p6_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -9.0 
  });
  
  p6_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -10.0 
  });
  
  p6_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -11.0 
  });
  
  p6_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -12.0 
  });
  
  p6_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_5',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  p6_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_6',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.25)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -14.0 
  });
  
  p6_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p6_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -15, 
    interpolate: true, 
  });
  
  p6_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p6_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p6_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p6_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p6_txt_try',
    text: 'NON ANCORA!\nDEVI SCEGLIERE UNA FORMA.\n\nSE NON RICORDI, INDOVINA! ',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -18.0 
  });
  
  // Initialize components for Routine "p6_inTime"
  p6_inTimeClock = new util.Clock();
  // Initialize components for Routine "p7_IM_jword"
  p7_IM_jwordClock = new util.Clock();
  p7_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_q',
    text: 'RICORDI QUANDO PRIMA HAI SCELTO UNA SOLA PAROLA CHE INIZIAVA CON UNA DETERMINATA LETTERA?\n\nSCELGI DI NUOVO LA STESSA PAROLA.',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.65], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Run 'Begin Experiment' code from p7_code
  p7_stimIDX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  p7_isPicked = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p7_stimColors = {};
  p7_isCorrect = 0;
  p7_ans = "";
  p7_ans_Idx = [];
  p7_corrAns = ["GITA"];
  p7_corrAns_Idx = 8;
  p7_countNext = 0;
  p7_points = 0;
  p7_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p7_corrAns_Vec[8] = 1;
  p7_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p7_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p7_stimColors[k] = [0, 0, 0];
  }
  p7_opNextBox = 1;
  p7_opNextTxt = 1;
  p7_opTryBox = 0;
  p7_opTryTxt = 0;
  p7_words = ["", "LATO", "CANE", "MODA", "ARIA", "SEDE", "NODO", "GITA", "TOPO", "PALO", "VINO"];
  
  p7_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p7_mouse.mouseClock = new util.Clock();
  p7_sq_10 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_10', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p7_sq_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_9', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p7_sq_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_8', 
    width: [0.12, 0.05][0], height: [0.12, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p7_sq_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_7', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p7_sq_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_6', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.15], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p7_sq_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_5', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p7_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_4', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p7_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_3', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p7_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_2', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p7_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p7_sq_1', 
    width: [0.13, 0.05][0], height: [0.13, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.15], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p7_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  p7_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -14.0 
  });
  
  p7_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -15.0 
  });
  
  p7_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  p7_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_5',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.25)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -17.0 
  });
  
  p7_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_6',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -18.0 
  });
  
  p7_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_7',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -19.0 
  });
  
  p7_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_8',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  p7_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_9',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -21.0 
  });
  
  p7_txt_10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_10',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.25)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -22.0 
  });
  
  p7_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p7_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -23, 
    interpolate: true, 
  });
  
  p7_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -24.0 
  });
  
  p7_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p7_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -25, 
    interpolate: true, 
  });
  
  p7_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p7_txt_try',
    text: 'NON ANCORA! PER CONTINUARE, DEVI SCEGLIERE UNA PAROLA. \n\nSE NON LA RICORDI, INDOVINA!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -26.0 
  });
  
  // Initialize components for Routine "p7_inTime"
  p7_inTimeClock = new util.Clock();
  // Initialize components for Routine "p8_IM_number"
  p8_IM_numberClock = new util.Clock();
  p8_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_txt_q',
    text: 'QUANDO HAI VISTO PER LA PRIMA VOLTA QUESTO TASTIERINO NUMERICO, HAI INSERITO UN NUMERO A QUATTRO CIFRE.\n\nDIGITA DI NUOVO LO STESSO NUMERO.',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.6], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Run 'Begin Experiment' code from p8_code
  lenString_p8 = 0;
  p8_ans = "";
  p8_isCorrect = 0;
  p8_keyNum = ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "DEL"];
  p8_corrAns = "1239";
  p8_countNext = 0;
  p8_points = 0;
  p8_opTryBox = 0;
  p8_opTryTxt = 0;
  p8_opNextBox = 1;
  p8_opNextTxt = 1;
  
  p8_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p8_mouse.mouseClock = new util.Clock();
  p8_screen_box = new visual.Rect ({
    win: psychoJS.window, name: 'p8_screen_box', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0, 0.12], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 3, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p8_screen_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_screen_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.12], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  p8_key_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_1', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p8_key_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_2', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p8_key_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_3', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p8_key_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_4', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p8_key_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_5', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p8_key_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_6', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p8_key_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_7', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p8_key_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_8', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p8_key_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_9', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p8_key_0 = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_0', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p8_key_DEL = new visual.Rect ({
    win: psychoJS.window, name: 'p8_key_DEL', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.05, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p8_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p8_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p8_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p8_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p8_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p8_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_txt_try',
    text: 'NON ANCORA!\nPER CONTINUARE, DIGITA UN NUMERO A QUATTRO CIFRE.\n\nSE NON LO RICORDI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p8_key_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -20.0 
  });
  
  p8_key_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -21.0 
  });
  
  p8_key_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -22.0 
  });
  
  p8_key_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -23.0 
  });
  
  p8_key_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -24.0 
  });
  
  p8_key_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -25.0 
  });
  
  p8_key_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_7',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -26.0 
  });
  
  p8_key_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_8',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -27.0 
  });
  
  p8_key_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_9',
    text: '9',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -28.0 
  });
  
  p8_key_txt_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -29.0 
  });
  
  p8_key_txt_DEL = new visual.TextStim({
    win: psychoJS.window,
    name: 'p8_key_txt_DEL',
    text: 'CANCELLA',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -30.0 
  });
  
  // Initialize components for Routine "p8_inTime"
  p8_inTimeClock = new util.Clock();
  // Initialize components for Routine "p9_ST_month"
  p9_ST_monthClock = new util.Clock();
  // Run 'Begin Experiment' code from p9a_code
  p9a_words = ["", "GENNAIO", "FEBBRAIO", "MARZO", "APRILE", "MAGGIO", "GIUGNO", "LUGLIO", "AGOSTO", "SETTEMBRE", "OTTOBRE", "NOVEMBRE", "DICEMBRE"];
  p9a_stimIDX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  p9a_isPicked = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p9a_stimColors = {};
  p9a_isCorrect = 0;
  p9a_corrAns_Idx = Number.parseInt(thisMonth);
  p9a_corrAns = p9a_words[p9a_corrAns_Idx];
  p9a_ans = "";
  p9a_ans_Idx = [];
  p9a_countNext = 0;
  p9a_points = 0;
  for (var k, _pj_c = 0, _pj_a = p9a_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p9a_stimColors[k] = [0, 0, 0];
  }
  p9a_opTryBox = 0;
  p9a_opTryTxt = 0;
  p9a_opNextBox = 1;
  p9a_opNextTxt = 1;
  
  p9a_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_1', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.25], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p9a_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_2', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.15], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p9a_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_3', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p9a_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_4', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p9a_sq_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_5', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p9a_sq_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_6', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [(- 0.2), (- 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p9a_sq_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_7', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.25], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p9a_sq_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_8', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.15], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p9a_sq_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_9', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p9a_sq_10 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_10', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.05)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p9a_sq_11 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_11', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p9a_sq_12 = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_sq_12', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0.2, (- 0.25)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p9a_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.25], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  p9a_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -14.0 
  });
  
  p9a_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -15.0 
  });
  
  p9a_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  p9a_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_5',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -17.0 
  });
  
  p9a_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_6',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.2), (- 0.25)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -18.0 
  });
  
  p9a_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_7',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.25], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -19.0 
  });
  
  p9a_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_8',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.15], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  p9a_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_9',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.05], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -21.0 
  });
  
  p9a_txt_10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_10',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.05)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -22.0 
  });
  
  p9a_txt_11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_11',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.15)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -23.0 
  });
  
  p9a_txt_12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_12',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, (- 0.25)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -24.0 
  });
  
  p9a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p9a_mouse.mouseClock = new util.Clock();
  p9a_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_q',
    text: 'IN CHE MESE SIAMO?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.8], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -26.0 
  });
  
  p9a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -27, 
    interpolate: true, 
  });
  
  p9a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -28.0 
  });
  
  p9a_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p9a_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -29, 
    interpolate: true, 
  });
  
  p9a_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9a_txt_try',
    text: 'NON ANCORA! PER CONTINUARE, DEVI SCEGLIERE UN MESE. \n\nSE NON TI RICORDI CHE MESE È, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -30.0 
  });
  
  // Initialize components for Routine "p9a_inTime"
  p9a_inTimeClock = new util.Clock();
  // Initialize components for Routine "p9_ST_year"
  p9_ST_yearClock = new util.Clock();
  p9b_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_txt_q',
    text: 'IN CHE ANNO SIAMO?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.8], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Run 'Begin Experiment' code from p9b_code
  p9b_corrAns_Idx = Number.parseInt(thisYear);
  p9b_corrAns = thisYear;
  lenString_p9b = 0;
  p9b_ans = "";
  p9b_isCorrect = 0;
  p9b_keyNum = ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "DEL"];
  p9b_countNext = 0;
  p9b_points = 0;
  p9b_opTryBox = 0;
  p9b_opTryTxt = 0;
  p9b_opNextBox = 1;
  p9b_opNextTxt = 1;
  
  p9b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p9b_mouse.mouseClock = new util.Clock();
  p9b_screen_box = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_screen_box', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0, 0.12], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 3, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p9b_screen_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_screen_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.12], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  p9b_key_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_1', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p9b_key_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_2', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p9b_key_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_3', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p9b_key_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_4', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p9b_key_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_5', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p9b_key_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_6', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p9b_key_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_7', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p9b_key_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_8', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p9b_key_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_9', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p9b_key_0 = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_0', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p9b_key_DEL = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_key_DEL', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.05, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p9b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p9b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p9b_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p9b_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p9b_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_txt_try',
    text: 'NON ANCORA!\nDIGITA UN NUMERO A QUATTRO CIFRE.\n\nSE NON TI RICORDI L’ANNO, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p9b_key_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -20.0 
  });
  
  p9b_key_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -21.0 
  });
  
  p9b_key_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -22.0 
  });
  
  p9b_key_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -23.0 
  });
  
  p9b_key_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -24.0 
  });
  
  p9b_key_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -25.0 
  });
  
  p9b_key_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_7',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -26.0 
  });
  
  p9b_key_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_8',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -27.0 
  });
  
  p9b_key_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_9',
    text: '9',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -28.0 
  });
  
  p9b_key_txt_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -29.0 
  });
  
  p9b_key_txt_DEL = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9b_key_txt_DEL',
    text: 'CANCELLA',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -30.0 
  });
  
  // Initialize components for Routine "p9b_inTime"
  p9b_inTimeClock = new util.Clock();
  // Initialize components for Routine "p9_ST_day"
  p9_ST_dayClock = new util.Clock();
  // Run 'Begin Experiment' code from p9c_code
  p9c_words = ["", "LUNEDI", "MARTEDI", "MERCOLEDI", "GIOVEDI", "VENERDI", "SABATO", "DOMENICA"];
  p9c_stimIDX = [1, 2, 3, 4, 5, 6, 7];
  p9c_isPicked = [0, 0, 0, 0, 0, 0, 0, 0];
  p9c_stimColors = {};
  p9c_isCorrect = 0;
  p9c_corrAns_Idx = 0;
  p9c_corrAns = thisDay;
  p9c_ans = "";
  p9c_ans_Idx = [];
  p9c_countNext = 0;
  p9c_points = 0;
  for (var k, _pj_c = 0, _pj_a = p9c_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p9c_stimColors[k] = cGrey;
  }
  p9c_opTryBox = 0;
  p9c_opTryTxt = 0;
  p9c_opNextBox = 1;
  p9c_opNextTxt = 1;
  
  p9c_sq_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_1', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, 0.21], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p9c_sq_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_2', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, 0.14], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p9c_sq_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_3', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, 0.07], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p9c_sq_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_4', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p9c_sq_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_5', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.07)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p9c_sq_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_6', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.14)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p9c_sq_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_sq_7', 
    width: [0.3, 0.05][0], height: [0.3, 0.05][1],
    ori: 0, 
    pos: [0, (- 0.21)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p9c_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_1',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.21], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -8.0 
  });
  
  p9c_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.14], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -9.0 
  });
  
  p9c_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_3',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.07], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -10.0 
  });
  
  p9c_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_4',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -11.0 
  });
  
  p9c_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_5',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.07)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -12.0 
  });
  
  p9c_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_6',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.14)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  p9c_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_7',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.21)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -14.0 
  });
  
  p9c_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p9c_mouse.mouseClock = new util.Clock();
  p9c_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_q',
    text: 'CHE GIORNO DELLA SETTIMANA È OGGI?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.8], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  p9c_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.45)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -17, 
    interpolate: true, 
  });
  
  p9c_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.45)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -18.0 
  });
  
  p9c_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p9c_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -19, 
    interpolate: true, 
  });
  
  p9c_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p9c_txt_try',
    text: 'NON ANCORA! DEVI SCEGLIERE UN GIORNO. \n\nSE NON TI RICORDI CHE GIORNO È, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.25, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  // Initialize components for Routine "p9c_inTime"
  p9c_inTimeClock = new util.Clock();
  // Initialize components for Routine "buffer"
  bufferClock = new util.Clock();
  text = new visual.TextStim({
    win: psychoJS.window,
    name: 'text',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.1,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  mouse = new core.Mouse({
    win: psychoJS.window,
  });
  mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p10_MEM_wordList"
  p10_MEM_wordListClock = new util.Clock();
  // Run 'Begin Experiment' code from p10_code
  p10_stimIDX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100];
  p10_isPicked = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p10_stimColors = {};
  p10_isCorrect = 0;
  p10_ans = "";
  p10_ans_Idx = [];
  p10_corrAns = ["ANNO", "MUCCA", "STATUA", "PANE", "LADRO"];
  p10_corrAns_Idx = ["2", "56", "83", "69", "38"];
  p10_countNext = 0;
  p10_points = 0;
  p10_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  p10_corrAns_Vec[2] = 1;
  p10_corrAns_Vec[56] = 1;
  p10_corrAns_Vec[83] = 1;
  p10_corrAns_Vec[69] = 1;
  p10_corrAns_Vec[38] = 1;
  p10_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p10_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p10_stimColors[k] = cGrey;
  }
  p10_words = ["", "ANGOLO", "ANNO", "ARIA", "ATLETA", "AULA", "BANANA", "BIBITA", "BOCCA", "BRODO", "BURRO", "CANE", "CIELO", "CINEMA", "CIRCO", "CLIMA", "COLORE", "DENARO", "DIVANO", "DOCCIA", "DONNA", "ERBA", "ESTATE", "FAME", "FANGO", "FAVOLA", "FEBBRE", "FIAMMA", "FUCILE", "FUOCO", "FURTO", "GARA", "GIOIA", "GITA", "GOCCIA", "GONNA", "GUERRA", "INCUBO", "LADRO", "LAGO", "LANA", "LATO", "LIBRO", "LIMONE", "LUCE", "LUNA", "LUPO", "MADRE", "MAGO", "MAIALE", "MARE", "MARITO", "MELA", "MIELE", "MODA", "MOGLIE", "MUCCA", "NASO", "NEVE", "NIPOTE", "NODO", "NOIA", "NOTTE", "NUVOLA", "ORSO", "PACCO", "PACE", "PADRE", "PALO", "PANE", "PATATA", "PECORA", "PEPE", "PONTE", "PRATO", "PUGILE", "RITMO", "RUMORE", "SABBIA", "SANGUE", "SEDE", "SERA", "SONNO", "STATUA", "STRADA", "SUORA", "TAVOLO", "TETTO", "TIPO", "TOPO", "TORTA", "TRENO", "UOVO", "VASCA", "VASO", "VENTO", "VERME", "VINO", "VOLPE", "ZAMPA", "ZONA"];
  p10_opTryBox = 0;
  p10_opTryTxt = 0;
  p10_opTryManyTxt = 0;
  p10_opNextBox = 1;
  p10_opNextTxt = 1;
  
  p10_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p10_mouse.mouseClock = new util.Clock();
  p10_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt_q',
    text: 'PRIMA, HAI MEMORIZZATO CINQUE PAROLE.\nSELEZIONA QUELLE PAROLE SULLA LISTA.',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.85], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  p10_sq11 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq11', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p10_sq21 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq21', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p10_sq31 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq31', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p10_sq41 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq41', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p10_sq51 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq51', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p10_sq61 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq61', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p10_sq71 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq71', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p10_sq81 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq81', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p10_sq91 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq91', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p10_sq101 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq101', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p10_sq111 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq111', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p10_sq121 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq121', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p10_sq131 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq131', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p10_sq141 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq141', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -16, 
    interpolate: true, 
  });
  
  p10_sq151 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq151', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -17, 
    interpolate: true, 
  });
  
  p10_sq161 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq161', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.8)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -18, 
    interpolate: true, 
  });
  
  p10_sq171 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq171', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.75), (- 0.9)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -19, 
    interpolate: true, 
  });
  
  p10_sq12 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq12', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -20, 
    interpolate: true, 
  });
  
  p10_sq22 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq22', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -21, 
    interpolate: true, 
  });
  
  p10_sq32 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq32', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -22, 
    interpolate: true, 
  });
  
  p10_sq42 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq42', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -23, 
    interpolate: true, 
  });
  
  p10_sq52 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq52', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -24, 
    interpolate: true, 
  });
  
  p10_sq62 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq62', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -25, 
    interpolate: true, 
  });
  
  p10_sq72 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq72', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -26, 
    interpolate: true, 
  });
  
  p10_sq82 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq82', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -27, 
    interpolate: true, 
  });
  
  p10_sq92 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq92', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -28, 
    interpolate: true, 
  });
  
  p10_sq102 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq102', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -29, 
    interpolate: true, 
  });
  
  p10_sq112 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq112', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -30, 
    interpolate: true, 
  });
  
  p10_sq122 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq122', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -31, 
    interpolate: true, 
  });
  
  p10_sq132 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq132', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -32, 
    interpolate: true, 
  });
  
  p10_sq142 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq142', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -33, 
    interpolate: true, 
  });
  
  p10_sq152 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq152', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -34, 
    interpolate: true, 
  });
  
  p10_sq162 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq162', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.8)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -35, 
    interpolate: true, 
  });
  
  p10_sq172 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq172', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.45), (- 0.9)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -36, 
    interpolate: true, 
  });
  
  p10_sq13 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq13', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -37, 
    interpolate: true, 
  });
  
  p10_sq23 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq23', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -38, 
    interpolate: true, 
  });
  
  p10_sq33 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq33', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -39, 
    interpolate: true, 
  });
  
  p10_sq43 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq43', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -40, 
    interpolate: true, 
  });
  
  p10_sq53 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq53', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -41, 
    interpolate: true, 
  });
  
  p10_sq63 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq63', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -42, 
    interpolate: true, 
  });
  
  p10_sq73 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq73', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -43, 
    interpolate: true, 
  });
  
  p10_sq83 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq83', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -44, 
    interpolate: true, 
  });
  
  p10_sq93 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq93', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -45, 
    interpolate: true, 
  });
  
  p10_sq103 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq103', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -46, 
    interpolate: true, 
  });
  
  p10_sq113 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq113', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -47, 
    interpolate: true, 
  });
  
  p10_sq123 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq123', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -48, 
    interpolate: true, 
  });
  
  p10_sq133 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq133', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -49, 
    interpolate: true, 
  });
  
  p10_sq143 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq143', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -50, 
    interpolate: true, 
  });
  
  p10_sq153 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq153', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -51, 
    interpolate: true, 
  });
  
  p10_sq163 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq163', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.8)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -52, 
    interpolate: true, 
  });
  
  p10_sq173 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq173', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [(- 0.15), (- 0.9)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -53, 
    interpolate: true, 
  });
  
  p10_sq14 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq14', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -54, 
    interpolate: true, 
  });
  
  p10_sq24 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq24', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -55, 
    interpolate: true, 
  });
  
  p10_sq34 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq34', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -56, 
    interpolate: true, 
  });
  
  p10_sq44 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq44', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -57, 
    interpolate: true, 
  });
  
  p10_sq54 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq54', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -58, 
    interpolate: true, 
  });
  
  p10_sq64 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq64', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -59, 
    interpolate: true, 
  });
  
  p10_sq74 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq74', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -60, 
    interpolate: true, 
  });
  
  p10_sq84 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq84', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -61, 
    interpolate: true, 
  });
  
  p10_sq94 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq94', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -62, 
    interpolate: true, 
  });
  
  p10_sq104 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq104', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -63, 
    interpolate: true, 
  });
  
  p10_sq114 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq114', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -64, 
    interpolate: true, 
  });
  
  p10_sq124 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq124', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -65, 
    interpolate: true, 
  });
  
  p10_sq134 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq134', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -66, 
    interpolate: true, 
  });
  
  p10_sq144 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq144', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -67, 
    interpolate: true, 
  });
  
  p10_sq154 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq154', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -68, 
    interpolate: true, 
  });
  
  p10_sq164 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq164', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.8)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -69, 
    interpolate: true, 
  });
  
  p10_sq174 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq174', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.15, (- 0.9)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -70, 
    interpolate: true, 
  });
  
  p10_sq15 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq15', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -71, 
    interpolate: true, 
  });
  
  p10_sq25 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq25', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -72, 
    interpolate: true, 
  });
  
  p10_sq35 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq35', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -73, 
    interpolate: true, 
  });
  
  p10_sq45 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq45', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -74, 
    interpolate: true, 
  });
  
  p10_sq55 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq55', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -75, 
    interpolate: true, 
  });
  
  p10_sq65 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq65', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -76, 
    interpolate: true, 
  });
  
  p10_sq75 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq75', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -77, 
    interpolate: true, 
  });
  
  p10_sq85 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq85', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -78, 
    interpolate: true, 
  });
  
  p10_sq95 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq95', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -79, 
    interpolate: true, 
  });
  
  p10_sq105 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq105', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -80, 
    interpolate: true, 
  });
  
  p10_sq115 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq115', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -81, 
    interpolate: true, 
  });
  
  p10_sq125 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq125', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -82, 
    interpolate: true, 
  });
  
  p10_sq135 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq135', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -83, 
    interpolate: true, 
  });
  
  p10_sq145 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq145', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -84, 
    interpolate: true, 
  });
  
  p10_sq155 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq155', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -85, 
    interpolate: true, 
  });
  
  p10_sq165 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq165', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.8)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -86, 
    interpolate: true, 
  });
  
  p10_sq175 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq175', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.45, (- 0.9)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -87, 
    interpolate: true, 
  });
  
  p10_sq16 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq16', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.7], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -88, 
    interpolate: true, 
  });
  
  p10_sq26 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq26', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.6], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -89, 
    interpolate: true, 
  });
  
  p10_sq36 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq36', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.5], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -90, 
    interpolate: true, 
  });
  
  p10_sq46 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq46', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.4], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -91, 
    interpolate: true, 
  });
  
  p10_sq56 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq56', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.3], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -92, 
    interpolate: true, 
  });
  
  p10_sq66 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq66', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -93, 
    interpolate: true, 
  });
  
  p10_sq76 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq76', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -94, 
    interpolate: true, 
  });
  
  p10_sq86 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq86', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, 0.0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -95, 
    interpolate: true, 
  });
  
  p10_sq96 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq96', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -96, 
    interpolate: true, 
  });
  
  p10_sq106 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq106', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -97, 
    interpolate: true, 
  });
  
  p10_sq116 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq116', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -98, 
    interpolate: true, 
  });
  
  p10_sq126 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq126', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -99, 
    interpolate: true, 
  });
  
  p10_sq136 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq136', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.5)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -100, 
    interpolate: true, 
  });
  
  p10_sq146 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq146', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.6)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -101, 
    interpolate: true, 
  });
  
  p10_sq156 = new visual.Rect ({
    win: psychoJS.window, name: 'p10_sq156', units : 'norm', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0.75, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -102, 
    interpolate: true, 
  });
  
  p10_txt1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt1',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -103.0 
  });
  
  p10_txt2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt2',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -104.0 
  });
  
  p10_txt3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt3',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -105.0 
  });
  
  p10_txt4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt4',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -106.0 
  });
  
  p10_txt5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt5',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -107.0 
  });
  
  p10_txt6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt6',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -108.0 
  });
  
  p10_txt7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt7',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -109.0 
  });
  
  p10_txt8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt8',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -110.0 
  });
  
  p10_txt9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt9',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -111.0 
  });
  
  p10_txt10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt10',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -112.0 
  });
  
  p10_txt11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt11',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -113.0 
  });
  
  p10_txt12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt12',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -114.0 
  });
  
  p10_txt13 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt13',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -115.0 
  });
  
  p10_txt14 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt14',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -116.0 
  });
  
  p10_txt15 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt15',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -117.0 
  });
  
  p10_txt16 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt16',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.8)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -118.0 
  });
  
  p10_txt17 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt17',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.75), (- 0.9)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -119.0 
  });
  
  p10_txt18 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt18',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -120.0 
  });
  
  p10_txt19 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt19',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -121.0 
  });
  
  p10_txt20 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt20',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -122.0 
  });
  
  p10_txt21 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt21',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -123.0 
  });
  
  p10_txt22 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt22',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -124.0 
  });
  
  p10_txt23 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt23',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -125.0 
  });
  
  p10_txt24 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt24',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -126.0 
  });
  
  p10_txt25 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt25',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -127.0 
  });
  
  p10_txt26 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt26',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -128.0 
  });
  
  p10_txt27 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt27',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -129.0 
  });
  
  p10_txt28 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt28',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -130.0 
  });
  
  p10_txt29 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt29',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -131.0 
  });
  
  p10_txt30 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt30',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -132.0 
  });
  
  p10_txt31 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt31',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -133.0 
  });
  
  p10_txt32 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt32',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -134.0 
  });
  
  p10_txt33 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt33',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.8)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -135.0 
  });
  
  p10_txt34 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt34',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.45), (- 0.9)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -136.0 
  });
  
  p10_txt35 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt35',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -137.0 
  });
  
  p10_txt36 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt36',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -138.0 
  });
  
  p10_txt37 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt37',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -139.0 
  });
  
  p10_txt38 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt38',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -140.0 
  });
  
  p10_txt39 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt39',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -141.0 
  });
  
  p10_txt40 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt40',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -142.0 
  });
  
  p10_txt41 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt41',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -143.0 
  });
  
  p10_txt42 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt42',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -144.0 
  });
  
  p10_txt43 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt43',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -145.0 
  });
  
  p10_txt44 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt44',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -146.0 
  });
  
  p10_txt45 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt45',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -147.0 
  });
  
  p10_txt46 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt46',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -148.0 
  });
  
  p10_txt47 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt47',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -149.0 
  });
  
  p10_txt48 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt48',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -150.0 
  });
  
  p10_txt49 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt49',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -151.0 
  });
  
  p10_txt50 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt50',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.8)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -152.0 
  });
  
  p10_txt51 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt51',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [(- 0.15), (- 0.9)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -153.0 
  });
  
  p10_txt52 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt52',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -154.0 
  });
  
  p10_txt53 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt53',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -155.0 
  });
  
  p10_txt54 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt54',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -156.0 
  });
  
  p10_txt55 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt55',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -157.0 
  });
  
  p10_txt56 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt56',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -158.0 
  });
  
  p10_txt57 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt57',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -159.0 
  });
  
  p10_txt58 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt58',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -160.0 
  });
  
  p10_txt59 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt59',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -161.0 
  });
  
  p10_txt60 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt60',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -162.0 
  });
  
  p10_txt61 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt61',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -163.0 
  });
  
  p10_txt62 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt62',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -164.0 
  });
  
  p10_txt63 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt63',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -165.0 
  });
  
  p10_txt64 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt64',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -166.0 
  });
  
  p10_txt65 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt65',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -167.0 
  });
  
  p10_txt66 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt66',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -168.0 
  });
  
  p10_txt67 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt67',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.8)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -169.0 
  });
  
  p10_txt68 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt68',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.15, (- 0.9)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -170.0 
  });
  
  p10_txt69 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt69',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -171.0 
  });
  
  p10_txt70 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt70',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -172.0 
  });
  
  p10_txt71 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt71',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -173.0 
  });
  
  p10_txt72 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt72',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -174.0 
  });
  
  p10_txt73 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt73',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -175.0 
  });
  
  p10_txt74 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt74',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -176.0 
  });
  
  p10_txt75 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt75',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -177.0 
  });
  
  p10_txt76 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt76',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -178.0 
  });
  
  p10_txt77 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt77',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -179.0 
  });
  
  p10_txt78 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt78',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -180.0 
  });
  
  p10_txt79 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt79',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -181.0 
  });
  
  p10_txt80 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt80',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -182.0 
  });
  
  p10_txt81 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt81',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -183.0 
  });
  
  p10_txt82 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt82',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -184.0 
  });
  
  p10_txt83 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt83',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -185.0 
  });
  
  p10_txt84 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt84',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.8)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -186.0 
  });
  
  p10_txt85 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt85',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.45, (- 0.9)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -187.0 
  });
  
  p10_txt86 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt86',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.7], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -188.0 
  });
  
  p10_txt87 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt87',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.6], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -189.0 
  });
  
  p10_txt88 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt88',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.5], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -190.0 
  });
  
  p10_txt89 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt89',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.4], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -191.0 
  });
  
  p10_txt90 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt90',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.3], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -192.0 
  });
  
  p10_txt91 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt91',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.2], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -193.0 
  });
  
  p10_txt92 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt92',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -194.0 
  });
  
  p10_txt93 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt93',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, 0.0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -195.0 
  });
  
  p10_txt94 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt94',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -196.0 
  });
  
  p10_txt95 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt95',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -197.0 
  });
  
  p10_txt96 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt96',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -198.0 
  });
  
  p10_txt97 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt97',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.4)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -199.0 
  });
  
  p10_txt98 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt98',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.5)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -200.0 
  });
  
  p10_txt99 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt99',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.6)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -201.0 
  });
  
  p10_txt100 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt100',
    text: '',
    font: 'Arial',
    units: 'norm', 
    pos: [0.75, (- 0.7)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -202.0 
  });
  
  p10_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p10_box_next', units : 'norm', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.9, 0.9], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -203, 
    interpolate: true, 
  });
  
  p10_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p10_box_try', units : 'norm', 
    width: [0.4, 0.5][0], height: [0.4, 0.5][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -204, 
    interpolate: true, 
  });
  
  p10_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt_try',
    text: 'NON ANCORA! DEVI SCEGLIERE CINQUE PAROLE. \n\nSE NON LE RICORDI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -205.0 
  });
  
  p10_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: 'norm', 
    pos: [0.9, 0.9], draggable: false, height: 0.07,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -206.0 
  });
  
  p10_txt_try_many = new visual.TextStim({
    win: psychoJS.window,
    name: 'p10_txt_try_many',
    text: 'NON ANCORA! PUOI SCEGLIERE SOLO CINQUE PAROLE. \n\nPER DE-SELEZIONARE UNA PAROLA, TOCCALA DI NUOVO!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -207.0 
  });
  
  // Initialize components for Routine "p10_inTime"
  p10_inTimeClock = new util.Clock();
  // Initialize components for Routine "p11a_CALC_sum"
  p11a_CALC_sumClock = new util.Clock();
  p11a_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_txt_q',
    text: 'VAI IN NEGOZIO CON ESATTAMENTE €100.\nCOMPRI UNA DOZZINA DI MELE CHE COSTANO €7 E UN TRICICLO CHE COSTA €60.\n\nQUANTO HAI SPESO?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.6], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Run 'Begin Experiment' code from p11a_code
  lenString_p11a = 1;
  p11a_ans = "\u20ac";
  p11a_isCorrect = 0;
  p11a_keyNum = ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "DEL"];
  p11a_isCorrect = 0;
  p11a_corrAns = "\u20ac67";
  p11a_countNext = 0;
  p11a_points = 0;
  p11a_opTryBox = 0;
  p11a_opTryTxt = 0;
  p11a_opNextBox = 1;
  p11a_opNextTxt = 1;
  
  p11a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p11a_mouse.mouseClock = new util.Clock();
  p11a_screen_box = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_screen_box', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0, 0.12], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 3, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p11a_screen_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_screen_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.12], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  p11a_key_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_1', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p11a_key_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_2', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p11a_key_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_3', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p11a_key_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_4', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p11a_key_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_5', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p11a_key_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_6', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p11a_key_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_7', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p11a_key_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_8', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p11a_key_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_9', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p11a_key_0 = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_0', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p11a_key_DEL = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_key_DEL', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.05, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p11a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p11a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p11a_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p11a_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p11a_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_txt_try',
    text: 'NON ANCORA!\nDEVI INSERIRE L’AMMONTARE IN EURO.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p11a_key_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -20.0 
  });
  
  p11a_key_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -21.0 
  });
  
  p11a_key_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -22.0 
  });
  
  p11a_key_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -23.0 
  });
  
  p11a_key_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -24.0 
  });
  
  p11a_key_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -25.0 
  });
  
  p11a_key_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_7',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -26.0 
  });
  
  p11a_key_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_8',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -27.0 
  });
  
  p11a_key_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_9',
    text: '9',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -28.0 
  });
  
  p11a_key_txt_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -29.0 
  });
  
  p11a_key_txt_DEL = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11a_key_txt_DEL',
    text: 'CANCELLA',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -30.0 
  });
  
  // Initialize components for Routine "p11a_inTime"
  p11a_inTimeClock = new util.Clock();
  // Initialize components for Routine "p11b_CALC_diff"
  p11b_CALC_diffClock = new util.Clock();
  p11b_txt_q = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_txt_q',
    text: 'DOPO L’ACQUISTO, \nQUANTI SOLDI TI SONO RIMASTI?',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.7], draggable: false, height: 0.09,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Run 'Begin Experiment' code from p11b_code
  p11b_ans = "\u20ac";
  lenString_p11b = 1;
  p11b_isCorrect = 0;
  p11b_keyNum = ["", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "DEL"];
  p11b_corrAns = "\u20ac33";
  p11b_countNext = 0;
  p11b_points = 0;
  p11b_opTryBox = 0;
  p11b_opTryTxt = 0;
  p11b_opNextBox = 1;
  p11b_opNextTxt = 1;
  
  p11b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p11b_mouse.mouseClock = new util.Clock();
  p11b_screen_box = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_screen_box', 
    width: [0.28, 0.08][0], height: [0.28, 0.08][1],
    ori: 0, 
    pos: [0, 0.12], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 3, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p11b_screen_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_screen_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.12], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  p11b_key_1 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_1', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p11b_key_2 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_2', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p11b_key_3 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_3', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, 0], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p11b_key_4 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_4', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p11b_key_5 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_5', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p11b_key_6 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_6', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p11b_key_7 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_7', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -11, 
    interpolate: true, 
  });
  
  p11b_key_8 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_8', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p11b_key_9 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_9', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [0.1, (- 0.2)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -13, 
    interpolate: true, 
  });
  
  p11b_key_0 = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_0', 
    width: [0.08, 0.08][0], height: [0.08, 0.08][1],
    ori: 0, 
    pos: [(- 0.1), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -14, 
    interpolate: true, 
  });
  
  p11b_key_DEL = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_key_DEL', 
    width: [0.18, 0.08][0], height: [0.18, 0.08][1],
    ori: 0, 
    pos: [0.05, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -15, 
    interpolate: true, 
  });
  
  p11b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p11b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p11b_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p11b_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p11b_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_txt_try',
    text: 'NON ANCORA!\nDEVI INSERIRE L’AMMONTARE IN EURO.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p11b_key_txt_1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -20.0 
  });
  
  p11b_key_txt_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -21.0 
  });
  
  p11b_key_txt_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -22.0 
  });
  
  p11b_key_txt_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -23.0 
  });
  
  p11b_key_txt_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -24.0 
  });
  
  p11b_key_txt_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_6',
    text: '6',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.1)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -25.0 
  });
  
  p11b_key_txt_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_7',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -26.0 
  });
  
  p11b_key_txt_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_8',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -27.0 
  });
  
  p11b_key_txt_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_9',
    text: '9',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.2)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -28.0 
  });
  
  p11b_key_txt_0 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_0',
    text: '0',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -29.0 
  });
  
  p11b_key_txt_DEL = new visual.TextStim({
    win: psychoJS.window,
    name: 'p11b_key_txt_DEL',
    text: 'CANCELLA',
    font: 'Arial',
    units: undefined, 
    pos: [0.05, (- 0.3)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -30.0 
  });
  
  // Initialize components for Routine "p11b_inTime"
  p11b_inTimeClock = new util.Clock();
  // Initialize components for Routine "p12"
  p12Clock = new util.Clock();
  p12_img_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12_img_instr', units : undefined, 
    image : 'instructions/p12_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p12_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p12_mouse.mouseClock = new util.Clock();
  p12_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p12_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.45)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p12_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.45)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p12a_VS_shapes"
  p12a_VS_shapesClock = new util.Clock();
  // Run 'Begin Experiment' code from p12a_code
  p12a_stimIDX = [1, 2, 3, 4, 5, 6];
  p12a_isPicked = [0, 0, 0, 0, 0, 0, 0];
  p12a_stimColors = {};
  p12a_isCorrect = 0;
  p12a_ans = "";
  p12a_ans_Idx = [];
  p12a_corrAns = ["shape01_pentagon.png", "shape05_circle.png"];
  p12a_corrAns_Idx = [1, 5];
  p12a_countNext = 0;
  p12a_points = 0;
  p12a_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0];
  p12a_corrAns_Vec[1] = 1;
  p12a_corrAns_Vec[5] = 1;
  p12a_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p12a_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p12a_stimColors[k] = cWhite;
  }
  p12a_words = ["", "shape01_pentagon.png", "shape02_head.png", "shape03_triangle.png", "shape04_square.png", "shape05_circle.png", "shape06_hexagon.png"];
  p12a_opTryBox = 0;
  p12a_opTryTxt = 0;
  p12a_opTryManyTxt = 0;
  p12a_opNextBox = 1;
  p12a_opNextTxt = 1;
  
  p12a_sq6 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq6', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p12a_sq5 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq5', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.0, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p12a_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq4', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p12a_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq3', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p12a_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq2', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p12a_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_sq1', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p12a_txb_q1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_txb_q1', 
    width: [1.3, 0.1][0], height: [1.3, 0.1][1],
    ori: 0, 
    pos: [0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p12a_txt_q1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12a_txt_q1',
    text: 'QUALI TRA QUESTI DISEGNI COMPONGONO LA FIGURA?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -8.0 
  });
  
  p12a_img_1 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_1', units : undefined, 
    image : 'images/shape01_pentagon.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -9.0 
  });
  p12a_img_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_2', units : undefined, 
    image : 'images/shape02_head.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -10.0 
  });
  p12a_img_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_3', units : undefined, 
    image : 'images/shape03_triangle.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -11.0 
  });
  p12a_img_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_4', units : undefined, 
    image : 'images/shape04_square.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -12.0 
  });
  p12a_img_5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_5', units : undefined, 
    image : 'images/shape05_circle.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.0, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -13.0 
  });
  p12a_img_6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_6', units : undefined, 
    image : 'images/shape06_hexagon.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -14.0 
  });
  p12a_img_whole = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12a_img_whole', units : undefined, 
    image : 'images/shape_tot.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0.3], 
    draggable: false,
    size : [0.3, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -15.0 
  });
  p12a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p12a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p12a_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p12a_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p12a_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12a_txt_try',
    text: 'NON ANCORA!\nDEVI SCEGLIERE DUE DISEGNI.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p12a_txt_try_many = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12a_txt_try_many',
    text: 'NON ANCORA!\nPUOI SCEGLIERE SOLO DUE DISEGNI.\n\nPER DESELEZIONARE UN DISEGNO, TOCCALO DI NUOVO.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  p12a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p12a_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p12a_inTime"
  p12a_inTimeClock = new util.Clock();
  // Initialize components for Routine "p12b_VS_faces"
  p12b_VS_facesClock = new util.Clock();
  // Run 'Begin Experiment' code from p12b_code
  p12b_stimIDX = [1, 2, 3, 4, 5, 6];
  p12b_isPicked = [0, 0, 0, 0, 0, 0, 0];
  p12b_stimColors = {};
  p12b_isCorrect = 0;
  p12b_ans = "";
  p12b_ans_Idx = [];
  p12b_corrAns = ["face_02.png", "face_06.png"];
  p12b_corrAns_Idx = [2, 6];
  p12b_countNext = 0;
  p12b_points = 0;
  p12b_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0];
  p12b_corrAns_Vec[2] = 1;
  p12b_corrAns_Vec[6] = 1;
  p12b_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p12b_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p12b_stimColors[k] = cWhite;
  }
  p12b_words = ["", "face_01.png", "face_02.png", "face_03.png", "face_04.png", "face_05.png", "face_06.png"];
  p12b_opTryBox = 0;
  p12b_opTryTxt = 0;
  p12b_opTryManyTxt = 0;
  p12b_opNextBox = 1;
  p12b_opNextTxt = 1;
  
  p12b_sq6 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq6', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p12b_sq5 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq5', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.0, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p12b_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq4', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p12b_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq3', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p12b_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq2', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p12b_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_sq1', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p12b_txb_q1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_txb_q1', 
    width: [1.3, 0.1][0], height: [1.3, 0.1][1],
    ori: 0, 
    pos: [0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p12b_txt_q1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12b_txt_q1',
    text: 'QUALI TRA QUESTI DISEGNI COMPONGONO LA FIGURA?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -8.0 
  });
  
  p12b_img_1 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_1', units : undefined, 
    image : 'images/face_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -9.0 
  });
  p12b_img_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_2', units : undefined, 
    image : 'images/face_02.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -10.0 
  });
  p12b_img_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_3', units : undefined, 
    image : 'images/face_03.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -11.0 
  });
  p12b_img_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_4', units : undefined, 
    image : 'images/face_04.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -12.0 
  });
  p12b_img_5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_5', units : undefined, 
    image : 'images/face_05.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.0, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -13.0 
  });
  p12b_img_6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_6', units : undefined, 
    image : 'images/face_06.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -14.0 
  });
  p12b_img_whole = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12b_img_whole', units : undefined, 
    image : 'images/face_tot.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0.3], 
    draggable: false,
    size : [0.3, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -15.0 
  });
  p12b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p12b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p12b_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p12b_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p12b_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12b_txt_try',
    text: 'NON ANCORA!\nDEVI SCEGLIERE DUE DISEGNI.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p12b_txt_try_many = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12b_txt_try_many',
    text: 'NON ANCORA!\nPUOI SCEGLIERE SOLO DUE DISEGNI.\n\nPER DESELEZIONARE UN DISEGNO, TOCCALO DI NUOVO.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  p12b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p12b_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p12b_inTime"
  p12b_inTimeClock = new util.Clock();
  // Initialize components for Routine "p12c_VS_lines"
  p12c_VS_linesClock = new util.Clock();
  // Run 'Begin Experiment' code from p12c_code
  p12c_stimIDX = [1, 2, 3, 4, 5, 6];
  p12c_isPicked = [0, 0, 0, 0, 0, 0, 0];
  p12c_stimColors = {};
  p12c_isCorrect = 0;
  p12c_ans = "";
  p12c_ans_Idx = [];
  p12c_corrAns = ["line_03.png", "line_06.png"];
  p12c_corrAns_Idx = [3, 6];
  p12c_countNext = 0;
  p12c_points = 0;
  p12c_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0];
  p12c_corrAns_Vec[3] = 1;
  p12c_corrAns_Vec[6] = 1;
  p12c_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p12c_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p12c_stimColors[k] = cWhite;
  }
  p12c_words = ["", "line_01.png", "line_02.png", "line_03.png", "line_04.png", "line_05.png", "line_06.png"];
  p12c_opTryBox = 0;
  p12c_opTryTxt = 0;
  p12c_opTryManyTxt = 0;
  p12c_opNextBox = 1;
  p12c_opNextTxt = 1;
  
  p12c_sq6 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq6', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p12c_sq5 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq5', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.0, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p12c_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq4', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p12c_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq3', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p12c_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq2', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p12c_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_sq1', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p12c_txb_q1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_txb_q1', 
    width: [1.3, 0.1][0], height: [1.3, 0.1][1],
    ori: 0, 
    pos: [0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p12c_txt_q1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12c_txt_q1',
    text: 'QUALI TRA QUESTI DISEGNI COMPONGONO LA FIGURA?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -8.0 
  });
  
  p12c_img_1 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_1', units : undefined, 
    image : 'images/line_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -9.0 
  });
  p12c_img_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_2', units : undefined, 
    image : 'images/line_02.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -10.0 
  });
  p12c_img_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_3', units : undefined, 
    image : 'images/line_03.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -11.0 
  });
  p12c_img_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_4', units : undefined, 
    image : 'images/line_04.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -12.0 
  });
  p12c_img_5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_5', units : undefined, 
    image : 'images/line_05.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.0, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -13.0 
  });
  p12c_img_6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_6', units : undefined, 
    image : 'images/line_06.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -14.0 
  });
  p12c_img_whole = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12c_img_whole', units : undefined, 
    image : 'images/line_tot.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0.3], 
    draggable: false,
    size : [0.3, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -15.0 
  });
  p12c_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p12c_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12c_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p12c_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p12c_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p12c_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12c_txt_try',
    text: 'NON ANCORA!\nDEVI SCEGLIERE DUE DISEGNI.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p12c_txt_try_many = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12c_txt_try_many',
    text: 'NON ANCORA!\nPUOI SCEGLIERE SOLO DUE DISEGNI.\n\nPER DESELEZIONARE UN DISEGNO, TOCCALO DI NUOVO.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  p12c_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p12c_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p12c_inTime"
  p12c_inTimeClock = new util.Clock();
  // Initialize components for Routine "p12d_VS_cubes"
  p12d_VS_cubesClock = new util.Clock();
  // Run 'Begin Experiment' code from p12d_code
  p12d_stimIDX = [1, 2, 3, 4, 5, 6];
  p12d_isPicked = [0, 0, 0, 0, 0, 0, 0];
  p12d_stimColors = {};
  p12d_isCorrect = 0;
  p12d_ans = "";
  p12d_ans_Idx = [];
  p12d_corrAns = ["cube_03.png", "cube_04.png"];
  p12d_corrAns_Idx = [3, 4];
  p12d_countNext = 0;
  p12d_points = 0;
  p12d_corrAns_Vec = [0, 0, 0, 0, 0, 0, 0];
  p12d_corrAns_Vec[3] = 1;
  p12d_corrAns_Vec[4] = 1;
  p12d_countCorrect = 0;
  for (var k, _pj_c = 0, _pj_a = p12d_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p12d_stimColors[k] = cWhite;
  }
  p12d_words = ["", "cube_01.png", "cube_02.png", "cube_03.png", "cube_04.png", "cube_05.png", "cube_06.png"];
  p12d_opTryBox = 0;
  p12d_opTryTxt = 0;
  p12d_opTryManyTxt = 0;
  p12d_opNextBox = 1;
  p12d_opNextTxt = 1;
  
  p12d_sq6 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq6', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p12d_sq5 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq5', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.0, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p12d_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq4', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p12d_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq3', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p12d_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq2', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p12d_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_sq1', 
    width: [0.15, 0.15][0], height: [0.15, 0.15][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p12d_txb_q1 = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_txb_q1', 
    width: [1.3, 0.1][0], height: [1.3, 0.1][1],
    ori: 0, 
    pos: [0, 0.05], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p12d_txt_q1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12d_txt_q1',
    text: 'QUALI TRA QUESTI DISEGNI COMPONGONO LA FIGURA?',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.05], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -8.0 
  });
  
  p12d_img_1 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_1', units : undefined, 
    image : 'images/cube_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -9.0 
  });
  p12d_img_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_2', units : undefined, 
    image : 'images/cube_02.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -10.0 
  });
  p12d_img_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_3', units : undefined, 
    image : 'images/cube_03.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.1)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -11.0 
  });
  p12d_img_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_4', units : undefined, 
    image : 'images/cube_04.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [(- 0.25), (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -12.0 
  });
  p12d_img_5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_5', units : undefined, 
    image : 'images/cube_05.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.0, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -13.0 
  });
  p12d_img_6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_6', units : undefined, 
    image : 'images/cube_06.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0.25, (- 0.3)], 
    draggable: false,
    size : [0.15, 0.15],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -14.0 
  });
  p12d_img_whole = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p12d_img_whole', units : undefined, 
    image : 'images/cube_tot.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0.3], 
    draggable: false,
    size : [0.3, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -15.0 
  });
  p12d_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p12d_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12d_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p12d_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p12d_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -18, 
    interpolate: true, 
  });
  
  p12d_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12d_txt_try',
    text: 'NON ANCORA!\nDEVI SCEGLIERE DUE DISEGNI.\n\nSE NON LO SAI, PROVA AD INDOVINARE!',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -19.0 
  });
  
  p12d_txt_try_many = new visual.TextStim({
    win: psychoJS.window,
    name: 'p12d_txt_try_many',
    text: 'NON ANCORA!\nPUOI SCEGLIERE SOLO DUE DISEGNI.\n\nPER DESELEZIONARE UN DISEGNO, TOCCALO DI NUOVO.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -20.0 
  });
  
  p12d_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p12d_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p12d_inTime"
  p12d_inTimeClock = new util.Clock();
  // Initialize components for Routine "p13"
  p13Clock = new util.Clock();
  p13_img_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p13_img_instr', units : undefined, 
    image : 'instructions/p13_instr_01.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p13_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p13_mouse.mouseClock = new util.Clock();
  p13_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p13_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p13_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "p13_leadin"
  p13_leadinClock = new util.Clock();
  text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], draggable: false, height: 0.1,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "p13a_Stroop_practice"
  p13a_Stroop_practiceClock = new util.Clock();
  // Run 'Begin Experiment' code from p13a_code
  p13a_stimIDX = [1, 2, 3];
  p13a_isPicked = [0, 0, 0, 0];
  p13a_stimColors = {};
  p13a_isCorrect = 0;
  p13a_ans = "";
  p13a_ans_Idx = [];
  p13a_countNext = 0;
  p13a_points = 0;
  p13a_words = ["", "GREEN", "RED", "BLUE"];
  for (var k, _pj_c = 0, _pj_a = p13a_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p13a_stimColors[k] = cWhite;
  }
  p13a_opTryBox = 0;
  p13a_opTryTxt = 0;
  p13a_opNextBox = 1;
  p13a_opNextTxt = 1;
  
  p13a_txb1 = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_txb1', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p13a_txb2 = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_txb2', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p13a_txb3 = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_txb3', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([(- 1), (- 1), (- 1)]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p13a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.42)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -4, 
    interpolate: true, 
  });
  
  p13a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.42)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -5.0 
  });
  
  p13a_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -6, 
    interpolate: true, 
  });
  
  p13a_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt_try',
    text: 'PROVA DI NUOVO!\n\nSCEGLI IL COLORE USATO PER SCRIVERE QUESTA PAROLA.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -7.0 
  });
  
  p13a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p13a_mouse.mouseClock = new util.Clock();
  p13a_txt1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt1',
    text: 'VERDE',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.25), (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -9.0 
  });
  
  p13a_txt2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt2',
    text: 'ROSSO',
    font: 'Arial',
    units: undefined, 
    pos: [0.0, (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -10.0 
  });
  
  p13a_txt3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt3',
    text: 'BLU',
    font: 'Arial',
    units: undefined, 
    pos: [0.25, (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -11.0 
  });
  
  p13a_box_word = new visual.Rect ({
    win: psychoJS.window, name: 'p13a_box_word', 
    width: [0.35, 0.15][0], height: [0.35, 0.15][1],
    ori: 0, 
    pos: [0, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([0, 0, 0]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p13a_txt_word = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13a_txt_word',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.2], draggable: false, height: 0.08,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  // Initialize components for Routine "p13b_Stroop"
  p13b_StroopClock = new util.Clock();
  // Run 'Begin Experiment' code from p13b_code
  p13b_stimIDX = [1, 2, 3];
  p13b_isPicked = [0, 0, 0, 0];
  p13b_stimColors = {};
  p13b_isCorrect = 0;
  p13b_ans = "";
  p13b_ans_Idx = [];
  p13b_countNext = 0;
  p13b_points = 0;
  p13b_words = ["", "GREEN", "RED", "BLUE"];
  for (var k, _pj_c = 0, _pj_a = p13b_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p13b_stimColors[k] = cWhite;
  }
  p13b_opTryBox = 0;
  p13b_opTryTxt = 0;
  p13b_opNextBox = 1;
  p13b_opNextTxt = 1;
  
  p13b_txb1 = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_txb1', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p13b_txb2 = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_txb2', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [0.0, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -2, 
    interpolate: true, 
  });
  
  p13b_txb3 = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_txb3', 
    width: [0.2, 0.08][0], height: [0.2, 0.08][1],
    ori: 0, 
    pos: [0.25, (- 0.1)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p13b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.42, (- 0.42)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -4, 
    interpolate: true, 
  });
  
  p13b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.42, (- 0.42)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -5.0 
  });
  
  p13b_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -6, 
    interpolate: true, 
  });
  
  p13b_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt_try',
    text: 'PROVA DI NUOVO!\n\nSCEGLI IL COLORE USATO PER SCRIVERE QUESTA PAROLA.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -7.0 
  });
  
  p13b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p13b_mouse.mouseClock = new util.Clock();
  p13b_txt1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt1',
    text: 'VERDE',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.25), (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -9.0 
  });
  
  p13b_txt2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt2',
    text: 'ROSSO',
    font: 'Arial',
    units: undefined, 
    pos: [0.0, (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -10.0 
  });
  
  p13b_txt3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt3',
    text: 'BLU',
    font: 'Arial',
    units: undefined, 
    pos: [0.25, (- 0.1)], draggable: false, height: 0.04,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -11.0 
  });
  
  p13b_box_word = new visual.Rect ({
    win: psychoJS.window, name: 'p13b_box_word', 
    width: [0.35, 0.15][0], height: [0.35, 0.15][1],
    ori: 0, 
    pos: [0, 0.2], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([0, 0, 0]), 
    fillColor: new util.Color([1, 1, 1]), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -12, 
    interpolate: true, 
  });
  
  p13b_txt_word = new visual.TextStim({
    win: psychoJS.window,
    name: 'p13b_txt_word',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.2], draggable: false, height: 0.08,  wrapWidth: 1.7, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -13.0 
  });
  
  // Initialize components for Routine "p13_inTime"
  p13_inTimeClock = new util.Clock();
  // Initialize components for Routine "p14_TMT"
  p14_TMTClock = new util.Clock();
  p14_img_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'p14_img_instr', units : 'height', 
    image : 'default.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  p14_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p14_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.4, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -1, 
    interpolate: true, 
  });
  
  p14_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1,
    depth: -2.0 
  });
  
  p14_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p14_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p14a_TMT_Numbers"
  p14a_TMT_NumbersClock = new util.Clock();
  p14a_txt_instr1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt_instr1',
    text: 'UNISCI I PUNTINI',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.9], draggable: false, height: 0.1,  wrapWidth: 1.8, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  p14a_txt_instr2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt_instr2',
    text: 'INIZIA DAL NUMERO 1, E VAI IN ORDINE. CONTINUA FINCHÉ NON ARRIVI ALLA FINE.',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.65], draggable: false, height: 0.06,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Run 'Begin Experiment' code from p14a_code
  p14a_ans = "";
  lenString_p14a = 0;
  p14a_isCorrect = 0;
  p14a_keyNum = ["", "1", "2", "3", "4", "5"];
  p14a_corrAns = ["", "1", "2", "3", "4", "5"];
  p14a_stringCorr = ["", "1", "2", "3", "4", "5"];
  p14a_isPicked = [0, 0, 0, 0, 0, 0];
  p14a_nErrors = 0;
  p14a_countNext = 0;
  p14a_points = 0;
  p14a_stimIDX = [1, 2, 3, 4, 5, 6];
  p14a_stimColors = {};
  for (var k, _pj_c = 0, _pj_a = p14a_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p14a_stimColors[k] = cWhite;
  }
  p14a_opTryBox = 0;
  p14a_opTryTxt = 0;
  p14a_opNextBox = 1;
  p14a_opNextTxt = 1;
  
  p14a_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_sq1', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [(- 0.17), (- 0.17)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p14a_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_sq2', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.09, 0.14], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p14a_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_sq3', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.26, (- 0.18)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p14a_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_sq4', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.04, (- 0.09)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p14a_sq5 = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_sq5', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.11, (- 0.34)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p14a_txt1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.17), (- 0.17)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -8.0 
  });
  
  p14a_txt2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0.09, 0.14], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -9.0 
  });
  
  p14a_txt3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.26, (- 0.18)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -10.0 
  });
  
  p14a_txt4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [0.04, (- 0.09)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -11.0 
  });
  
  p14a_txt5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt5',
    text: '5',
    font: 'Arial',
    units: undefined, 
    pos: [0.11, (- 0.34)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -12.0 
  });
  
  p14a_txtEND = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txtEND',
    text: 'FINE',
    font: 'Arial',
    units: undefined, 
    pos: [0.11, (- 0.28)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -13.0 
  });
  
  p14a_txtSTART = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txtSTART',
    text: 'INIZIO',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.17), (- 0.23)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -14.0 
  });
  
  p14a_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -15, 
    interpolate: true, 
  });
  
  p14a_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p14a_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.45, (- 0.35)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -16, 
    interpolate: true, 
  });
  
  p14a_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.35)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -17.0 
  });
  
  p14a_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14a_txt_try',
    text: 'NON ANCORA!\n\nDEVI TOCCARE TUTTI I QUADRATI.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -18.0 
  });
  
  p14a_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p14a_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p14a_inTime"
  p14a_inTimeClock = new util.Clock();
  // Initialize components for Routine "p14b_TMT_Letters"
  p14b_TMT_LettersClock = new util.Clock();
  p14b_txt_instr1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt_instr1',
    text: 'UNISCI I PUNTINI',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.9], draggable: false, height: 0.1,  wrapWidth: 1.8, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  p14b_txt_instr2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt_instr2',
    text: 'ALTERNA I NUMERI E LE LETTERE. \nINIZIA DAL NUMERO 1, COLLEGALO ALLA PRIMA LETTERA, A. POI, COLLEGA LA LETTERA A AL NUMERO 2, E IL NUMERO 2 ALLA LETTERA SUCCESSIVA. CONTINUA FINCHÉ NON ARRIVI ALLA FINE.',
    font: 'Arial',
    units: 'norm', 
    pos: [0, 0.65], draggable: false, height: 0.06,  wrapWidth: 1.6, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Run 'Begin Experiment' code from p14b_code
  p14b_ans = "";
  lenString_p14b = 0;
  p14b_isCorrect = 0;
  p14b_keyNum = ["", "1", "A", "2", "B", "3", "C", "4", "D"];
  p14b_corrAns = ["", "1", "A", "2", "B", "3", "C", "4", "D"];
  p14b_isPicked = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  p14b_nErrors = 0;
  p14b_countNext = 0;
  p14b_points = 0;
  p14b_stimIDX = [1, 2, 3, 4, 5, 6, 7, 8];
  p14b_stimColors = {};
  for (var k, _pj_c = 0, _pj_a = p14b_stimIDX, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
      k = _pj_a[_pj_c];
      p14b_stimColors[k] = cWhite;
  }
  p14b_opTryBox = 0;
  p14b_opTryTxt = 0;
  p14b_opNextBox = 1;
  p14b_opNextTxt = 1;
  
  p14b_sq1 = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sq1', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [(- 0.25), (- 0.15)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -3, 
    interpolate: true, 
  });
  
  p14b_sqA = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sqA', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.2, 0.04], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -4, 
    interpolate: true, 
  });
  
  p14b_sq2 = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sq2', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.57, 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -5, 
    interpolate: true, 
  });
  
  p14b_sqB = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sqB', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.35, (- 0.14)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -6, 
    interpolate: true, 
  });
  
  p14b_sq3 = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sq3', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [0.1, (- 0.3)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -7, 
    interpolate: true, 
  });
  
  p14b_sqC = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sqC', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [(- 0.44), (- 0.39)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -8, 
    interpolate: true, 
  });
  
  p14b_sq4 = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sq4', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [(- 0.53), 0.03], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -9, 
    interpolate: true, 
  });
  
  p14b_sqD = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_sqD', units : 'height', 
    width: [0.09, 0.09][0], height: [0.09, 0.09][1],
    ori: 0, 
    pos: [(- 0.09), 0.1], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color([1, 1, 1]), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1, 
    depth: -10, 
    interpolate: true, 
  });
  
  p14b_txt1 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt1',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.25), (- 0.15)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -11.0 
  });
  
  p14b_txtA = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtA',
    text: 'A',
    font: 'Arial',
    units: undefined, 
    pos: [0.2, 0.04], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -12.0 
  });
  
  p14b_txt2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt2',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [0.57, 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -13.0 
  });
  
  p14b_txtB = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtB',
    text: 'B',
    font: 'Arial',
    units: undefined, 
    pos: [0.35, (- 0.14)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -14.0 
  });
  
  p14b_txt3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt3',
    text: '3',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, (- 0.3)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -15.0 
  });
  
  p14b_txtC = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtC',
    text: 'C',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.44), (- 0.39)], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -16.0 
  });
  
  p14b_txt4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt4',
    text: '4',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.53), 0.03], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -17.0 
  });
  
  p14b_txtD = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtD',
    text: 'D',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.09), 0.1], draggable: false, height: 0.05,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -18.0 
  });
  
  p14b_txtEND = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtEND',
    text: 'FINE\n',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.09), 0.15], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -19.0 
  });
  
  p14b_txtSTART = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txtSTART',
    text: 'INIZIO',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.25), (- 0.22)], draggable: false, height: 0.03,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color('black'),  opacity: 1,
    depth: -20.0 
  });
  
  p14b_box_try = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_box_try', units : 'norm', 
    width: [0.4, 0.6][0], height: [0.4, 0.6][1],
    ori: 0, 
    pos: [0.8, (- 0.7)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -21, 
    interpolate: true, 
  });
  
  p14b_box_next = new visual.Rect ({
    win: psychoJS.window, name: 'p14b_box_next', 
    width: [0.15, 0.05][0], height: [0.15, 0.05][1],
    ori: 0, 
    pos: [0.45, (- 0.4)], 
    draggable: false, 
    anchor: 'center', 
    lineWidth: 1, 
    lineColor: new util.Color('white'), 
    fillColor: new util.Color('white'), 
    colorSpace: 'rgb', 
    opacity: 1.0, 
    depth: -22, 
    interpolate: true, 
  });
  
  p14b_txt_next = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt_next',
    text: 'AVANTI',
    font: 'Arial',
    units: undefined, 
    pos: [0.45, (- 0.4)], draggable: false, height: 0.04,  wrapWidth: undefined, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -23.0 
  });
  
  p14b_txt_try = new visual.TextStim({
    win: psychoJS.window,
    name: 'p14b_txt_try',
    text: 'NON ANCORA!\n\nDEVI TOCCARE TUTTI I QUADRATI.',
    font: 'Arial',
    units: 'norm', 
    pos: [0.8, (- 0.7)], draggable: false, height: 0.04,  wrapWidth: 0.3, ori: 0,
    languageStyle: 'LTR',
    color: new util.Color([(- 1), (- 1), (- 1)]),  opacity: 1.0,
    depth: -24.0 
  });
  
  p14b_mouse = new core.Mouse({
    win: psychoJS.window,
  });
  p14b_mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "p14b_inTime"
  p14b_inTimeClock = new util.Clock();
  // Initialize components for Routine "r_end"
  r_endClock = new util.Clock();
  pEND_img_instr = new visual.ImageStim({
    win : psychoJS.window,
    name : 'pEND_img_instr', units : undefined, 
    image : 'instructions/p_end.png', mask : undefined,
    anchor : 'center',
    ori : 0, 
    pos : [0, 0], 
    draggable: false,
    size : [1.2, 0.8],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : 0.0 
  });
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}


var t;
var frameN;
var continueRoutine;
var routineForceEnded;
var r_welcomeMaxDurationReached;
var r_welcomeMaxDuration;
var r_welcomeComponents;
function r_welcomeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'r_welcome' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    r_welcomeClock.reset(routineTimer.getTime());
    routineTimer.add(4.000000);
    r_welcomeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('r_welcome.started', globalClock.getTime());
    r_welcomeMaxDuration = null
    // keep track of which components have finished
    r_welcomeComponents = [];
    r_welcomeComponents.push(txt_welcome);
    
    r_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


var frameRemains;
function r_welcomeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'r_welcome' ---
    // get current time
    t = r_welcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *txt_welcome* updates
    if (t >= 0.0 && txt_welcome.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      txt_welcome.tStart = t;  // (not accounting for frame time here)
      txt_welcome.frameNStart = frameN;  // exact frame index
      
      txt_welcome.setAutoDraw(true);
    }
    
    
    // if txt_welcome is active this frame...
    if (txt_welcome.status === PsychoJS.Status.STARTED) {
    }
    
    frameRemains = 0.0 + 4.0 - psychoJS.window.monitorFramePeriod * 0.75;// most of one frame period left
    if (txt_welcome.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      // keep track of stop time/frame for later
      txt_welcome.tStop = t;  // not accounting for scr refresh
      txt_welcome.frameNStop = frameN;  // exact frame index
      // update status
      txt_welcome.status = PsychoJS.Status.FINISHED;
      txt_welcome.setAutoDraw(false);
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    r_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function r_welcomeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'r_welcome' ---
    r_welcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('r_welcome.stopped', globalClock.getTime());
    if (routineForceEnded) {
        routineTimer.reset();} else if (r_welcomeMaxDurationReached) {
        r_welcomeClock.add(r_welcomeMaxDuration);
    } else {
        r_welcomeClock.add(4.000000);
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var loop_inTime_p1;
function loop_inTime_p1LoopBegin(loop_inTime_p1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p1'
    });
    psychoJS.experiment.addLoop(loop_inTime_p1); // add the loop to the experiment
    currentLoop = loop_inTime_p1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p1.forEach(function() {
      snapshot = loop_inTime_p1.getSnapshot();
    
      loop_inTime_p1LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p1LoopScheduler.add(p1aRoutineBegin(snapshot));
      loop_inTime_p1LoopScheduler.add(p1aRoutineEachFrame());
      loop_inTime_p1LoopScheduler.add(p1aRoutineEnd(snapshot));
      const loop_waitTillOK_p1LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p1LoopScheduler.add(loop_waitTillOK_p1LoopBegin(loop_waitTillOK_p1LoopScheduler, snapshot));
      loop_inTime_p1LoopScheduler.add(loop_waitTillOK_p1LoopScheduler);
      loop_inTime_p1LoopScheduler.add(loop_waitTillOK_p1LoopEnd);
      loop_inTime_p1LoopScheduler.add(p1_inTimeRoutineBegin(snapshot));
      loop_inTime_p1LoopScheduler.add(p1_inTimeRoutineEachFrame());
      loop_inTime_p1LoopScheduler.add(p1_inTimeRoutineEnd(snapshot));
      loop_inTime_p1LoopScheduler.add(loop_inTime_p1LoopEndIteration(loop_inTime_p1LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p1;
function loop_waitTillOK_p1LoopBegin(loop_waitTillOK_p1LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p1 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p1'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p1); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p1;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p1.forEach(function() {
      snapshot = loop_waitTillOK_p1.getSnapshot();
    
      loop_waitTillOK_p1LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p1LoopScheduler.add(p1_ReadingRoutineBegin(snapshot));
      loop_waitTillOK_p1LoopScheduler.add(p1_ReadingRoutineEachFrame());
      loop_waitTillOK_p1LoopScheduler.add(p1_ReadingRoutineEnd(snapshot));
      loop_waitTillOK_p1LoopScheduler.add(loop_waitTillOK_p1LoopEndIteration(loop_waitTillOK_p1LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p1LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p1);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p1LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p2;
function loop_inTime_p2LoopBegin(loop_inTime_p2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p2'
    });
    psychoJS.experiment.addLoop(loop_inTime_p2); // add the loop to the experiment
    currentLoop = loop_inTime_p2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p2.forEach(function() {
      snapshot = loop_inTime_p2.getSnapshot();
    
      loop_inTime_p2LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p2LoopScheduler.add(p1bRoutineBegin(snapshot));
      loop_inTime_p2LoopScheduler.add(p1bRoutineEachFrame());
      loop_inTime_p2LoopScheduler.add(p1bRoutineEnd(snapshot));
      loop_inTime_p2LoopScheduler.add(p2aRoutineBegin(snapshot));
      loop_inTime_p2LoopScheduler.add(p2aRoutineEachFrame());
      loop_inTime_p2LoopScheduler.add(p2aRoutineEnd(snapshot));
      const loop_waitTillOK_p2LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p2LoopScheduler.add(loop_waitTillOK_p2LoopBegin(loop_waitTillOK_p2LoopScheduler, snapshot));
      loop_inTime_p2LoopScheduler.add(loop_waitTillOK_p2LoopScheduler);
      loop_inTime_p2LoopScheduler.add(loop_waitTillOK_p2LoopEnd);
      loop_inTime_p2LoopScheduler.add(p2_inTimeRoutineBegin(snapshot));
      loop_inTime_p2LoopScheduler.add(p2_inTimeRoutineEachFrame());
      loop_inTime_p2LoopScheduler.add(p2_inTimeRoutineEnd(snapshot));
      loop_inTime_p2LoopScheduler.add(loop_inTime_p2LoopEndIteration(loop_inTime_p2LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p2;
function loop_waitTillOK_p2LoopBegin(loop_waitTillOK_p2LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p2 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p2'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p2); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p2;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p2.forEach(function() {
      snapshot = loop_waitTillOK_p2.getSnapshot();
    
      loop_waitTillOK_p2LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p2LoopScheduler.add(p2_Att_JWordRoutineBegin(snapshot));
      loop_waitTillOK_p2LoopScheduler.add(p2_Att_JWordRoutineEachFrame());
      loop_waitTillOK_p2LoopScheduler.add(p2_Att_JWordRoutineEnd(snapshot));
      loop_waitTillOK_p2LoopScheduler.add(loop_waitTillOK_p2LoopEndIteration(loop_waitTillOK_p2LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p2LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p2);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p2LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p3;
function loop_inTime_p3LoopBegin(loop_inTime_p3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p3'
    });
    psychoJS.experiment.addLoop(loop_inTime_p3); // add the loop to the experiment
    currentLoop = loop_inTime_p3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p3.forEach(function() {
      snapshot = loop_inTime_p3.getSnapshot();
    
      loop_inTime_p3LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p3LoopScheduler.add(p3aRoutineBegin(snapshot));
      loop_inTime_p3LoopScheduler.add(p3aRoutineEachFrame());
      loop_inTime_p3LoopScheduler.add(p3aRoutineEnd(snapshot));
      const loop_waitTillOK_p3LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p3LoopScheduler.add(loop_waitTillOK_p3LoopBegin(loop_waitTillOK_p3LoopScheduler, snapshot));
      loop_inTime_p3LoopScheduler.add(loop_waitTillOK_p3LoopScheduler);
      loop_inTime_p3LoopScheduler.add(loop_waitTillOK_p3LoopEnd);
      loop_inTime_p3LoopScheduler.add(p3_inTimeRoutineBegin(snapshot));
      loop_inTime_p3LoopScheduler.add(p3_inTimeRoutineEachFrame());
      loop_inTime_p3LoopScheduler.add(p3_inTimeRoutineEnd(snapshot));
      loop_inTime_p3LoopScheduler.add(loop_inTime_p3LoopEndIteration(loop_inTime_p3LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p3;
function loop_waitTillOK_p3LoopBegin(loop_waitTillOK_p3LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p3 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p3'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p3); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p3;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p3.forEach(function() {
      snapshot = loop_waitTillOK_p3.getSnapshot();
    
      loop_waitTillOK_p3LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p3LoopScheduler.add(p3_Att_FruitsRoutineBegin(snapshot));
      loop_waitTillOK_p3LoopScheduler.add(p3_Att_FruitsRoutineEachFrame());
      loop_waitTillOK_p3LoopScheduler.add(p3_Att_FruitsRoutineEnd(snapshot));
      loop_waitTillOK_p3LoopScheduler.add(loop_waitTillOK_p3LoopEndIteration(loop_waitTillOK_p3LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p3LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p3);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p3LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p4;
function loop_inTime_p4LoopBegin(loop_inTime_p4LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p4 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p4'
    });
    psychoJS.experiment.addLoop(loop_inTime_p4); // add the loop to the experiment
    currentLoop = loop_inTime_p4;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p4.forEach(function() {
      snapshot = loop_inTime_p4.getSnapshot();
    
      loop_inTime_p4LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p4LoopScheduler.add(p4aRoutineBegin(snapshot));
      loop_inTime_p4LoopScheduler.add(p4aRoutineEachFrame());
      loop_inTime_p4LoopScheduler.add(p4aRoutineEnd(snapshot));
      const loop_waitTillOK_p4LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p4LoopScheduler.add(loop_waitTillOK_p4LoopBegin(loop_waitTillOK_p4LoopScheduler, snapshot));
      loop_inTime_p4LoopScheduler.add(loop_waitTillOK_p4LoopScheduler);
      loop_inTime_p4LoopScheduler.add(loop_waitTillOK_p4LoopEnd);
      loop_inTime_p4LoopScheduler.add(p4_inTimeRoutineBegin(snapshot));
      loop_inTime_p4LoopScheduler.add(p4_inTimeRoutineEachFrame());
      loop_inTime_p4LoopScheduler.add(p4_inTimeRoutineEnd(snapshot));
      loop_inTime_p4LoopScheduler.add(loop_inTime_p4LoopEndIteration(loop_inTime_p4LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p4;
function loop_waitTillOK_p4LoopBegin(loop_waitTillOK_p4LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p4 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p4'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p4); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p4;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p4.forEach(function() {
      snapshot = loop_waitTillOK_p4.getSnapshot();
    
      loop_waitTillOK_p4LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p4LoopScheduler.add(p4_Att_NumpadRoutineBegin(snapshot));
      loop_waitTillOK_p4LoopScheduler.add(p4_Att_NumpadRoutineEachFrame());
      loop_waitTillOK_p4LoopScheduler.add(p4_Att_NumpadRoutineEnd(snapshot));
      loop_waitTillOK_p4LoopScheduler.add(loop_waitTillOK_p4LoopEndIteration(loop_waitTillOK_p4LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p4LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p4);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p4LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p4LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p4);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p4LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p5;
function loop_inTime_p5LoopBegin(loop_inTime_p5LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p5 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p5'
    });
    psychoJS.experiment.addLoop(loop_inTime_p5); // add the loop to the experiment
    currentLoop = loop_inTime_p5;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p5.forEach(function() {
      snapshot = loop_inTime_p5.getSnapshot();
    
      loop_inTime_p5LoopScheduler.add(importConditions(snapshot));
      const loop_instr_p5LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p5LoopScheduler.add(loop_instr_p5LoopBegin(loop_instr_p5LoopScheduler, snapshot));
      loop_inTime_p5LoopScheduler.add(loop_instr_p5LoopScheduler);
      loop_inTime_p5LoopScheduler.add(loop_instr_p5LoopEnd);
      const loop_words_p5LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p5LoopScheduler.add(loop_words_p5LoopBegin(loop_words_p5LoopScheduler, snapshot));
      loop_inTime_p5LoopScheduler.add(loop_words_p5LoopScheduler);
      loop_inTime_p5LoopScheduler.add(loop_words_p5LoopEnd);
      loop_inTime_p5LoopScheduler.add(p5_inTimeRoutineBegin(snapshot));
      loop_inTime_p5LoopScheduler.add(p5_inTimeRoutineEachFrame());
      loop_inTime_p5LoopScheduler.add(p5_inTimeRoutineEnd(snapshot));
      loop_inTime_p5LoopScheduler.add(loop_inTime_p5LoopEndIteration(loop_inTime_p5LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_instr_p5;
function loop_instr_p5LoopBegin(loop_instr_p5LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_instr_p5 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'instructions/list_instr_p5.csv',
      seed: undefined, name: 'loop_instr_p5'
    });
    psychoJS.experiment.addLoop(loop_instr_p5); // add the loop to the experiment
    currentLoop = loop_instr_p5;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_instr_p5.forEach(function() {
      snapshot = loop_instr_p5.getSnapshot();
    
      loop_instr_p5LoopScheduler.add(importConditions(snapshot));
      loop_instr_p5LoopScheduler.add(p5aRoutineBegin(snapshot));
      loop_instr_p5LoopScheduler.add(p5aRoutineEachFrame());
      loop_instr_p5LoopScheduler.add(p5aRoutineEnd(snapshot));
      loop_instr_p5LoopScheduler.add(loop_instr_p5LoopEndIteration(loop_instr_p5LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_instr_p5LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_instr_p5);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_instr_p5LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_words_p5;
function loop_words_p5LoopBegin(loop_words_p5LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_words_p5 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'conditions/conditionsP5.csv',
      seed: undefined, name: 'loop_words_p5'
    });
    psychoJS.experiment.addLoop(loop_words_p5); // add the loop to the experiment
    currentLoop = loop_words_p5;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_words_p5.forEach(function() {
      snapshot = loop_words_p5.getSnapshot();
    
      loop_words_p5LoopScheduler.add(importConditions(snapshot));
      loop_words_p5LoopScheduler.add(p5_Mem_wordListRoutineBegin(snapshot));
      loop_words_p5LoopScheduler.add(p5_Mem_wordListRoutineEachFrame());
      loop_words_p5LoopScheduler.add(p5_Mem_wordListRoutineEnd(snapshot));
      loop_words_p5LoopScheduler.add(loop_words_p5LoopEndIteration(loop_words_p5LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_words_p5LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_words_p5);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_words_p5LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p5LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p5);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p5LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p6;
function loop_inTime_p6LoopBegin(loop_inTime_p6LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p6 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p6'
    });
    psychoJS.experiment.addLoop(loop_inTime_p6); // add the loop to the experiment
    currentLoop = loop_inTime_p6;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p6.forEach(function() {
      snapshot = loop_inTime_p6.getSnapshot();
    
      loop_inTime_p6LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p6LoopScheduler.add(p6aRoutineBegin(snapshot));
      loop_inTime_p6LoopScheduler.add(p6aRoutineEachFrame());
      loop_inTime_p6LoopScheduler.add(p6aRoutineEnd(snapshot));
      const loop_waitTillOK_p6LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p6LoopScheduler.add(loop_waitTillOK_p6LoopBegin(loop_waitTillOK_p6LoopScheduler, snapshot));
      loop_inTime_p6LoopScheduler.add(loop_waitTillOK_p6LoopScheduler);
      loop_inTime_p6LoopScheduler.add(loop_waitTillOK_p6LoopEnd);
      loop_inTime_p6LoopScheduler.add(p6_inTimeRoutineBegin(snapshot));
      loop_inTime_p6LoopScheduler.add(p6_inTimeRoutineEachFrame());
      loop_inTime_p6LoopScheduler.add(p6_inTimeRoutineEnd(snapshot));
      loop_inTime_p6LoopScheduler.add(loop_inTime_p6LoopEndIteration(loop_inTime_p6LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p6;
function loop_waitTillOK_p6LoopBegin(loop_waitTillOK_p6LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p6 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p6'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p6); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p6;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p6.forEach(function() {
      snapshot = loop_waitTillOK_p6.getSnapshot();
    
      loop_waitTillOK_p6LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p6LoopScheduler.add(p6_IM_shapeRoutineBegin(snapshot));
      loop_waitTillOK_p6LoopScheduler.add(p6_IM_shapeRoutineEachFrame());
      loop_waitTillOK_p6LoopScheduler.add(p6_IM_shapeRoutineEnd(snapshot));
      loop_waitTillOK_p6LoopScheduler.add(loop_waitTillOK_p6LoopEndIteration(loop_waitTillOK_p6LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p6LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p6);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p6LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p6LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p6);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p6LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p7;
function loop_inTime_p7LoopBegin(loop_inTime_p7LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p7 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p7'
    });
    psychoJS.experiment.addLoop(loop_inTime_p7); // add the loop to the experiment
    currentLoop = loop_inTime_p7;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p7.forEach(function() {
      snapshot = loop_inTime_p7.getSnapshot();
    
      loop_inTime_p7LoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p7LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p7LoopScheduler.add(loop_waitTillOK_p7LoopBegin(loop_waitTillOK_p7LoopScheduler, snapshot));
      loop_inTime_p7LoopScheduler.add(loop_waitTillOK_p7LoopScheduler);
      loop_inTime_p7LoopScheduler.add(loop_waitTillOK_p7LoopEnd);
      loop_inTime_p7LoopScheduler.add(p7_inTimeRoutineBegin(snapshot));
      loop_inTime_p7LoopScheduler.add(p7_inTimeRoutineEachFrame());
      loop_inTime_p7LoopScheduler.add(p7_inTimeRoutineEnd(snapshot));
      loop_inTime_p7LoopScheduler.add(loop_inTime_p7LoopEndIteration(loop_inTime_p7LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p7;
function loop_waitTillOK_p7LoopBegin(loop_waitTillOK_p7LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p7 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p7'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p7); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p7;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p7.forEach(function() {
      snapshot = loop_waitTillOK_p7.getSnapshot();
    
      loop_waitTillOK_p7LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p7LoopScheduler.add(p7_IM_jwordRoutineBegin(snapshot));
      loop_waitTillOK_p7LoopScheduler.add(p7_IM_jwordRoutineEachFrame());
      loop_waitTillOK_p7LoopScheduler.add(p7_IM_jwordRoutineEnd(snapshot));
      loop_waitTillOK_p7LoopScheduler.add(loop_waitTillOK_p7LoopEndIteration(loop_waitTillOK_p7LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p7LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p7);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p7LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p7LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p7);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p7LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p8;
function loop_inTime_p8LoopBegin(loop_inTime_p8LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p8 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p8'
    });
    psychoJS.experiment.addLoop(loop_inTime_p8); // add the loop to the experiment
    currentLoop = loop_inTime_p8;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p8.forEach(function() {
      snapshot = loop_inTime_p8.getSnapshot();
    
      loop_inTime_p8LoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p8LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p8LoopScheduler.add(loop_waitTillOK_p8LoopBegin(loop_waitTillOK_p8LoopScheduler, snapshot));
      loop_inTime_p8LoopScheduler.add(loop_waitTillOK_p8LoopScheduler);
      loop_inTime_p8LoopScheduler.add(loop_waitTillOK_p8LoopEnd);
      loop_inTime_p8LoopScheduler.add(p8_inTimeRoutineBegin(snapshot));
      loop_inTime_p8LoopScheduler.add(p8_inTimeRoutineEachFrame());
      loop_inTime_p8LoopScheduler.add(p8_inTimeRoutineEnd(snapshot));
      loop_inTime_p8LoopScheduler.add(loop_inTime_p8LoopEndIteration(loop_inTime_p8LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p8;
function loop_waitTillOK_p8LoopBegin(loop_waitTillOK_p8LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p8 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p8'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p8); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p8;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p8.forEach(function() {
      snapshot = loop_waitTillOK_p8.getSnapshot();
    
      loop_waitTillOK_p8LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p8LoopScheduler.add(p8_IM_numberRoutineBegin(snapshot));
      loop_waitTillOK_p8LoopScheduler.add(p8_IM_numberRoutineEachFrame());
      loop_waitTillOK_p8LoopScheduler.add(p8_IM_numberRoutineEnd(snapshot));
      loop_waitTillOK_p8LoopScheduler.add(loop_waitTillOK_p8LoopEndIteration(loop_waitTillOK_p8LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p8LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p8);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p8LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p8LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p8);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p8LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p9a;
function loop_inTime_p9aLoopBegin(loop_inTime_p9aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p9a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p9a'
    });
    psychoJS.experiment.addLoop(loop_inTime_p9a); // add the loop to the experiment
    currentLoop = loop_inTime_p9a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p9a.forEach(function() {
      snapshot = loop_inTime_p9a.getSnapshot();
    
      loop_inTime_p9aLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p9aLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p9aLoopScheduler.add(loop_waitTillOK_p9aLoopBegin(loop_waitTillOK_p9aLoopScheduler, snapshot));
      loop_inTime_p9aLoopScheduler.add(loop_waitTillOK_p9aLoopScheduler);
      loop_inTime_p9aLoopScheduler.add(loop_waitTillOK_p9aLoopEnd);
      loop_inTime_p9aLoopScheduler.add(p9a_inTimeRoutineBegin(snapshot));
      loop_inTime_p9aLoopScheduler.add(p9a_inTimeRoutineEachFrame());
      loop_inTime_p9aLoopScheduler.add(p9a_inTimeRoutineEnd(snapshot));
      loop_inTime_p9aLoopScheduler.add(loop_inTime_p9aLoopEndIteration(loop_inTime_p9aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p9a;
function loop_waitTillOK_p9aLoopBegin(loop_waitTillOK_p9aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p9a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p9a'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p9a); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p9a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p9a.forEach(function() {
      snapshot = loop_waitTillOK_p9a.getSnapshot();
    
      loop_waitTillOK_p9aLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p9aLoopScheduler.add(p9_ST_monthRoutineBegin(snapshot));
      loop_waitTillOK_p9aLoopScheduler.add(p9_ST_monthRoutineEachFrame());
      loop_waitTillOK_p9aLoopScheduler.add(p9_ST_monthRoutineEnd(snapshot));
      loop_waitTillOK_p9aLoopScheduler.add(loop_waitTillOK_p9aLoopEndIteration(loop_waitTillOK_p9aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p9aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p9a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p9aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p9aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p9a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p9aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p9b;
function loop_inTime_p9bLoopBegin(loop_inTime_p9bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p9b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p9b'
    });
    psychoJS.experiment.addLoop(loop_inTime_p9b); // add the loop to the experiment
    currentLoop = loop_inTime_p9b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p9b.forEach(function() {
      snapshot = loop_inTime_p9b.getSnapshot();
    
      loop_inTime_p9bLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p9bLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p9bLoopScheduler.add(loop_waitTillOK_p9bLoopBegin(loop_waitTillOK_p9bLoopScheduler, snapshot));
      loop_inTime_p9bLoopScheduler.add(loop_waitTillOK_p9bLoopScheduler);
      loop_inTime_p9bLoopScheduler.add(loop_waitTillOK_p9bLoopEnd);
      loop_inTime_p9bLoopScheduler.add(p9b_inTimeRoutineBegin(snapshot));
      loop_inTime_p9bLoopScheduler.add(p9b_inTimeRoutineEachFrame());
      loop_inTime_p9bLoopScheduler.add(p9b_inTimeRoutineEnd(snapshot));
      loop_inTime_p9bLoopScheduler.add(loop_inTime_p9bLoopEndIteration(loop_inTime_p9bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p9b;
function loop_waitTillOK_p9bLoopBegin(loop_waitTillOK_p9bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p9b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p9b'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p9b); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p9b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p9b.forEach(function() {
      snapshot = loop_waitTillOK_p9b.getSnapshot();
    
      loop_waitTillOK_p9bLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p9bLoopScheduler.add(p9_ST_yearRoutineBegin(snapshot));
      loop_waitTillOK_p9bLoopScheduler.add(p9_ST_yearRoutineEachFrame());
      loop_waitTillOK_p9bLoopScheduler.add(p9_ST_yearRoutineEnd(snapshot));
      loop_waitTillOK_p9bLoopScheduler.add(loop_waitTillOK_p9bLoopEndIteration(loop_waitTillOK_p9bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p9bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p9b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p9bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p9bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p9b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p9bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p9c;
function loop_inTime_p9cLoopBegin(loop_inTime_p9cLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p9c = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p9c'
    });
    psychoJS.experiment.addLoop(loop_inTime_p9c); // add the loop to the experiment
    currentLoop = loop_inTime_p9c;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p9c.forEach(function() {
      snapshot = loop_inTime_p9c.getSnapshot();
    
      loop_inTime_p9cLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p9cLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p9cLoopScheduler.add(loop_waitTillOK_p9cLoopBegin(loop_waitTillOK_p9cLoopScheduler, snapshot));
      loop_inTime_p9cLoopScheduler.add(loop_waitTillOK_p9cLoopScheduler);
      loop_inTime_p9cLoopScheduler.add(loop_waitTillOK_p9cLoopEnd);
      loop_inTime_p9cLoopScheduler.add(p9c_inTimeRoutineBegin(snapshot));
      loop_inTime_p9cLoopScheduler.add(p9c_inTimeRoutineEachFrame());
      loop_inTime_p9cLoopScheduler.add(p9c_inTimeRoutineEnd(snapshot));
      loop_inTime_p9cLoopScheduler.add(loop_inTime_p9cLoopEndIteration(loop_inTime_p9cLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p9c;
function loop_waitTillOK_p9cLoopBegin(loop_waitTillOK_p9cLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p9c = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p9c'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p9c); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p9c;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p9c.forEach(function() {
      snapshot = loop_waitTillOK_p9c.getSnapshot();
    
      loop_waitTillOK_p9cLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p9cLoopScheduler.add(p9_ST_dayRoutineBegin(snapshot));
      loop_waitTillOK_p9cLoopScheduler.add(p9_ST_dayRoutineEachFrame());
      loop_waitTillOK_p9cLoopScheduler.add(p9_ST_dayRoutineEnd(snapshot));
      loop_waitTillOK_p9cLoopScheduler.add(loop_waitTillOK_p9cLoopEndIteration(loop_waitTillOK_p9cLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p9cLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p9c);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p9cLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p9cLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p9c);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p9cLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p10;
function loop_inTime_p10LoopBegin(loop_inTime_p10LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p10 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p10'
    });
    psychoJS.experiment.addLoop(loop_inTime_p10); // add the loop to the experiment
    currentLoop = loop_inTime_p10;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p10.forEach(function() {
      snapshot = loop_inTime_p10.getSnapshot();
    
      loop_inTime_p10LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p10LoopScheduler.add(bufferRoutineBegin(snapshot));
      loop_inTime_p10LoopScheduler.add(bufferRoutineEachFrame());
      loop_inTime_p10LoopScheduler.add(bufferRoutineEnd(snapshot));
      const loop_waitTillOK_p10LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p10LoopScheduler.add(loop_waitTillOK_p10LoopBegin(loop_waitTillOK_p10LoopScheduler, snapshot));
      loop_inTime_p10LoopScheduler.add(loop_waitTillOK_p10LoopScheduler);
      loop_inTime_p10LoopScheduler.add(loop_waitTillOK_p10LoopEnd);
      loop_inTime_p10LoopScheduler.add(p10_inTimeRoutineBegin(snapshot));
      loop_inTime_p10LoopScheduler.add(p10_inTimeRoutineEachFrame());
      loop_inTime_p10LoopScheduler.add(p10_inTimeRoutineEnd(snapshot));
      loop_inTime_p10LoopScheduler.add(loop_inTime_p10LoopEndIteration(loop_inTime_p10LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p10;
function loop_waitTillOK_p10LoopBegin(loop_waitTillOK_p10LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p10 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p10'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p10); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p10;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p10.forEach(function() {
      snapshot = loop_waitTillOK_p10.getSnapshot();
    
      loop_waitTillOK_p10LoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p10LoopScheduler.add(p10_MEM_wordListRoutineBegin(snapshot));
      loop_waitTillOK_p10LoopScheduler.add(p10_MEM_wordListRoutineEachFrame());
      loop_waitTillOK_p10LoopScheduler.add(p10_MEM_wordListRoutineEnd(snapshot));
      loop_waitTillOK_p10LoopScheduler.add(loop_waitTillOK_p10LoopEndIteration(loop_waitTillOK_p10LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p10LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p10);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p10LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p10LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p10);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p10LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p11a;
function loop_inTime_p11aLoopBegin(loop_inTime_p11aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p11a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p11a'
    });
    psychoJS.experiment.addLoop(loop_inTime_p11a); // add the loop to the experiment
    currentLoop = loop_inTime_p11a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p11a.forEach(function() {
      snapshot = loop_inTime_p11a.getSnapshot();
    
      loop_inTime_p11aLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p11aLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p11aLoopScheduler.add(loop_waitTillOK_p11aLoopBegin(loop_waitTillOK_p11aLoopScheduler, snapshot));
      loop_inTime_p11aLoopScheduler.add(loop_waitTillOK_p11aLoopScheduler);
      loop_inTime_p11aLoopScheduler.add(loop_waitTillOK_p11aLoopEnd);
      loop_inTime_p11aLoopScheduler.add(p11a_inTimeRoutineBegin(snapshot));
      loop_inTime_p11aLoopScheduler.add(p11a_inTimeRoutineEachFrame());
      loop_inTime_p11aLoopScheduler.add(p11a_inTimeRoutineEnd(snapshot));
      loop_inTime_p11aLoopScheduler.add(loop_inTime_p11aLoopEndIteration(loop_inTime_p11aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p11a;
function loop_waitTillOK_p11aLoopBegin(loop_waitTillOK_p11aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p11a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.RANDOM,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p11a'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p11a); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p11a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p11a.forEach(function() {
      snapshot = loop_waitTillOK_p11a.getSnapshot();
    
      loop_waitTillOK_p11aLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p11aLoopScheduler.add(p11a_CALC_sumRoutineBegin(snapshot));
      loop_waitTillOK_p11aLoopScheduler.add(p11a_CALC_sumRoutineEachFrame());
      loop_waitTillOK_p11aLoopScheduler.add(p11a_CALC_sumRoutineEnd(snapshot));
      loop_waitTillOK_p11aLoopScheduler.add(loop_waitTillOK_p11aLoopEndIteration(loop_waitTillOK_p11aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p11aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p11a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p11aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p11aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p11a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p11aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p11b;
function loop_inTime_p11bLoopBegin(loop_inTime_p11bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p11b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p11b'
    });
    psychoJS.experiment.addLoop(loop_inTime_p11b); // add the loop to the experiment
    currentLoop = loop_inTime_p11b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p11b.forEach(function() {
      snapshot = loop_inTime_p11b.getSnapshot();
    
      loop_inTime_p11bLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p11bLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p11bLoopScheduler.add(loop_waitTillOK_p11bLoopBegin(loop_waitTillOK_p11bLoopScheduler, snapshot));
      loop_inTime_p11bLoopScheduler.add(loop_waitTillOK_p11bLoopScheduler);
      loop_inTime_p11bLoopScheduler.add(loop_waitTillOK_p11bLoopEnd);
      loop_inTime_p11bLoopScheduler.add(p11b_inTimeRoutineBegin(snapshot));
      loop_inTime_p11bLoopScheduler.add(p11b_inTimeRoutineEachFrame());
      loop_inTime_p11bLoopScheduler.add(p11b_inTimeRoutineEnd(snapshot));
      loop_inTime_p11bLoopScheduler.add(loop_inTime_p11bLoopEndIteration(loop_inTime_p11bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p11b;
function loop_waitTillOK_p11bLoopBegin(loop_waitTillOK_p11bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p11b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p11b'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p11b); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p11b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p11b.forEach(function() {
      snapshot = loop_waitTillOK_p11b.getSnapshot();
    
      loop_waitTillOK_p11bLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p11bLoopScheduler.add(p11b_CALC_diffRoutineBegin(snapshot));
      loop_waitTillOK_p11bLoopScheduler.add(p11b_CALC_diffRoutineEachFrame());
      loop_waitTillOK_p11bLoopScheduler.add(p11b_CALC_diffRoutineEnd(snapshot));
      loop_waitTillOK_p11bLoopScheduler.add(loop_waitTillOK_p11bLoopEndIteration(loop_waitTillOK_p11bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p11bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p11b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p11bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p11bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p11b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p11bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p12a;
function loop_inTime_p12aLoopBegin(loop_inTime_p12aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p12a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p12a'
    });
    psychoJS.experiment.addLoop(loop_inTime_p12a); // add the loop to the experiment
    currentLoop = loop_inTime_p12a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p12a.forEach(function() {
      snapshot = loop_inTime_p12a.getSnapshot();
    
      loop_inTime_p12aLoopScheduler.add(importConditions(snapshot));
      loop_inTime_p12aLoopScheduler.add(p12RoutineBegin(snapshot));
      loop_inTime_p12aLoopScheduler.add(p12RoutineEachFrame());
      loop_inTime_p12aLoopScheduler.add(p12RoutineEnd(snapshot));
      const loop_waitTillOK_p12aLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p12aLoopScheduler.add(loop_waitTillOK_p12aLoopBegin(loop_waitTillOK_p12aLoopScheduler, snapshot));
      loop_inTime_p12aLoopScheduler.add(loop_waitTillOK_p12aLoopScheduler);
      loop_inTime_p12aLoopScheduler.add(loop_waitTillOK_p12aLoopEnd);
      loop_inTime_p12aLoopScheduler.add(p12a_inTimeRoutineBegin(snapshot));
      loop_inTime_p12aLoopScheduler.add(p12a_inTimeRoutineEachFrame());
      loop_inTime_p12aLoopScheduler.add(p12a_inTimeRoutineEnd(snapshot));
      loop_inTime_p12aLoopScheduler.add(loop_inTime_p12aLoopEndIteration(loop_inTime_p12aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p12a;
function loop_waitTillOK_p12aLoopBegin(loop_waitTillOK_p12aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p12a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p12a'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p12a); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p12a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p12a.forEach(function() {
      snapshot = loop_waitTillOK_p12a.getSnapshot();
    
      loop_waitTillOK_p12aLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p12aLoopScheduler.add(p12a_VS_shapesRoutineBegin(snapshot));
      loop_waitTillOK_p12aLoopScheduler.add(p12a_VS_shapesRoutineEachFrame());
      loop_waitTillOK_p12aLoopScheduler.add(p12a_VS_shapesRoutineEnd(snapshot));
      loop_waitTillOK_p12aLoopScheduler.add(loop_waitTillOK_p12aLoopEndIteration(loop_waitTillOK_p12aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p12aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p12a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p12aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p12aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p12a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p12aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p12b;
function loop_inTime_p12bLoopBegin(loop_inTime_p12bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p12b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p12b'
    });
    psychoJS.experiment.addLoop(loop_inTime_p12b); // add the loop to the experiment
    currentLoop = loop_inTime_p12b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p12b.forEach(function() {
      snapshot = loop_inTime_p12b.getSnapshot();
    
      loop_inTime_p12bLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p12bLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p12bLoopScheduler.add(loop_waitTillOK_p12bLoopBegin(loop_waitTillOK_p12bLoopScheduler, snapshot));
      loop_inTime_p12bLoopScheduler.add(loop_waitTillOK_p12bLoopScheduler);
      loop_inTime_p12bLoopScheduler.add(loop_waitTillOK_p12bLoopEnd);
      loop_inTime_p12bLoopScheduler.add(p12b_inTimeRoutineBegin(snapshot));
      loop_inTime_p12bLoopScheduler.add(p12b_inTimeRoutineEachFrame());
      loop_inTime_p12bLoopScheduler.add(p12b_inTimeRoutineEnd(snapshot));
      loop_inTime_p12bLoopScheduler.add(loop_inTime_p12bLoopEndIteration(loop_inTime_p12bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p12b;
function loop_waitTillOK_p12bLoopBegin(loop_waitTillOK_p12bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p12b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p12b'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p12b); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p12b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p12b.forEach(function() {
      snapshot = loop_waitTillOK_p12b.getSnapshot();
    
      loop_waitTillOK_p12bLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p12bLoopScheduler.add(p12b_VS_facesRoutineBegin(snapshot));
      loop_waitTillOK_p12bLoopScheduler.add(p12b_VS_facesRoutineEachFrame());
      loop_waitTillOK_p12bLoopScheduler.add(p12b_VS_facesRoutineEnd(snapshot));
      loop_waitTillOK_p12bLoopScheduler.add(loop_waitTillOK_p12bLoopEndIteration(loop_waitTillOK_p12bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p12bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p12b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p12bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p12bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p12b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p12bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p12c;
function loop_inTime_p12cLoopBegin(loop_inTime_p12cLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p12c = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p12c'
    });
    psychoJS.experiment.addLoop(loop_inTime_p12c); // add the loop to the experiment
    currentLoop = loop_inTime_p12c;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p12c.forEach(function() {
      snapshot = loop_inTime_p12c.getSnapshot();
    
      loop_inTime_p12cLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p12cLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p12cLoopScheduler.add(loop_waitTillOK_p12cLoopBegin(loop_waitTillOK_p12cLoopScheduler, snapshot));
      loop_inTime_p12cLoopScheduler.add(loop_waitTillOK_p12cLoopScheduler);
      loop_inTime_p12cLoopScheduler.add(loop_waitTillOK_p12cLoopEnd);
      loop_inTime_p12cLoopScheduler.add(p12c_inTimeRoutineBegin(snapshot));
      loop_inTime_p12cLoopScheduler.add(p12c_inTimeRoutineEachFrame());
      loop_inTime_p12cLoopScheduler.add(p12c_inTimeRoutineEnd(snapshot));
      loop_inTime_p12cLoopScheduler.add(loop_inTime_p12cLoopEndIteration(loop_inTime_p12cLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p12c;
function loop_waitTillOK_p12cLoopBegin(loop_waitTillOK_p12cLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p12c = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p12c'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p12c); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p12c;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p12c.forEach(function() {
      snapshot = loop_waitTillOK_p12c.getSnapshot();
    
      loop_waitTillOK_p12cLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p12cLoopScheduler.add(p12c_VS_linesRoutineBegin(snapshot));
      loop_waitTillOK_p12cLoopScheduler.add(p12c_VS_linesRoutineEachFrame());
      loop_waitTillOK_p12cLoopScheduler.add(p12c_VS_linesRoutineEnd(snapshot));
      loop_waitTillOK_p12cLoopScheduler.add(loop_waitTillOK_p12cLoopEndIteration(loop_waitTillOK_p12cLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p12cLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p12c);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p12cLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p12cLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p12c);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p12cLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p12d;
function loop_inTime_p12dLoopBegin(loop_inTime_p12dLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p12d = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p12d'
    });
    psychoJS.experiment.addLoop(loop_inTime_p12d); // add the loop to the experiment
    currentLoop = loop_inTime_p12d;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p12d.forEach(function() {
      snapshot = loop_inTime_p12d.getSnapshot();
    
      loop_inTime_p12dLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p12dLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p12dLoopScheduler.add(loop_waitTillOK_p12dLoopBegin(loop_waitTillOK_p12dLoopScheduler, snapshot));
      loop_inTime_p12dLoopScheduler.add(loop_waitTillOK_p12dLoopScheduler);
      loop_inTime_p12dLoopScheduler.add(loop_waitTillOK_p12dLoopEnd);
      loop_inTime_p12dLoopScheduler.add(p12d_inTimeRoutineBegin(snapshot));
      loop_inTime_p12dLoopScheduler.add(p12d_inTimeRoutineEachFrame());
      loop_inTime_p12dLoopScheduler.add(p12d_inTimeRoutineEnd(snapshot));
      loop_inTime_p12dLoopScheduler.add(loop_inTime_p12dLoopEndIteration(loop_inTime_p12dLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p12d;
function loop_waitTillOK_p12dLoopBegin(loop_waitTillOK_p12dLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p12d = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p12d'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p12d); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p12d;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p12d.forEach(function() {
      snapshot = loop_waitTillOK_p12d.getSnapshot();
    
      loop_waitTillOK_p12dLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p12dLoopScheduler.add(p12d_VS_cubesRoutineBegin(snapshot));
      loop_waitTillOK_p12dLoopScheduler.add(p12d_VS_cubesRoutineEachFrame());
      loop_waitTillOK_p12dLoopScheduler.add(p12d_VS_cubesRoutineEnd(snapshot));
      loop_waitTillOK_p12dLoopScheduler.add(loop_waitTillOK_p12dLoopEndIteration(loop_waitTillOK_p12dLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p12dLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p12d);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p12dLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p12dLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p12d);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p12dLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p13;
function loop_inTime_p13LoopBegin(loop_inTime_p13LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p13 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p13'
    });
    psychoJS.experiment.addLoop(loop_inTime_p13); // add the loop to the experiment
    currentLoop = loop_inTime_p13;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p13.forEach(function() {
      snapshot = loop_inTime_p13.getSnapshot();
    
      loop_inTime_p13LoopScheduler.add(importConditions(snapshot));
      loop_inTime_p13LoopScheduler.add(p13RoutineBegin(snapshot));
      loop_inTime_p13LoopScheduler.add(p13RoutineEachFrame());
      loop_inTime_p13LoopScheduler.add(p13RoutineEnd(snapshot));
      const trials_practice_p13aLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p13LoopScheduler.add(trials_practice_p13aLoopBegin(trials_practice_p13aLoopScheduler, snapshot));
      loop_inTime_p13LoopScheduler.add(trials_practice_p13aLoopScheduler);
      loop_inTime_p13LoopScheduler.add(trials_practice_p13aLoopEnd);
      const trialsLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p13LoopScheduler.add(trialsLoopBegin(trialsLoopScheduler, snapshot));
      loop_inTime_p13LoopScheduler.add(trialsLoopScheduler);
      loop_inTime_p13LoopScheduler.add(trialsLoopEnd);
      loop_inTime_p13LoopScheduler.add(p13_inTimeRoutineBegin(snapshot));
      loop_inTime_p13LoopScheduler.add(p13_inTimeRoutineEachFrame());
      loop_inTime_p13LoopScheduler.add(p13_inTimeRoutineEnd(snapshot));
      loop_inTime_p13LoopScheduler.add(loop_inTime_p13LoopEndIteration(loop_inTime_p13LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var trials_practice_p13a;
function trials_practice_p13aLoopBegin(trials_practice_p13aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    trials_practice_p13a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'conditions/conditions_Stroop_practice.csv',
      seed: undefined, name: 'trials_practice_p13a'
    });
    psychoJS.experiment.addLoop(trials_practice_p13a); // add the loop to the experiment
    currentLoop = trials_practice_p13a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    trials_practice_p13a.forEach(function() {
      snapshot = trials_practice_p13a.getSnapshot();
    
      trials_practice_p13aLoopScheduler.add(importConditions(snapshot));
      trials_practice_p13aLoopScheduler.add(p13_leadinRoutineBegin(snapshot));
      trials_practice_p13aLoopScheduler.add(p13_leadinRoutineEachFrame());
      trials_practice_p13aLoopScheduler.add(p13_leadinRoutineEnd(snapshot));
      const loop_waitTillOK_p13aLoopScheduler = new Scheduler(psychoJS);
      trials_practice_p13aLoopScheduler.add(loop_waitTillOK_p13aLoopBegin(loop_waitTillOK_p13aLoopScheduler, snapshot));
      trials_practice_p13aLoopScheduler.add(loop_waitTillOK_p13aLoopScheduler);
      trials_practice_p13aLoopScheduler.add(loop_waitTillOK_p13aLoopEnd);
      trials_practice_p13aLoopScheduler.add(trials_practice_p13aLoopEndIteration(trials_practice_p13aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p13a;
function loop_waitTillOK_p13aLoopBegin(loop_waitTillOK_p13aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p13a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p13a'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p13a); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p13a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p13a.forEach(function() {
      snapshot = loop_waitTillOK_p13a.getSnapshot();
    
      loop_waitTillOK_p13aLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p13aLoopScheduler.add(p13a_Stroop_practiceRoutineBegin(snapshot));
      loop_waitTillOK_p13aLoopScheduler.add(p13a_Stroop_practiceRoutineEachFrame());
      loop_waitTillOK_p13aLoopScheduler.add(p13a_Stroop_practiceRoutineEnd(snapshot));
      loop_waitTillOK_p13aLoopScheduler.add(loop_waitTillOK_p13aLoopEndIteration(loop_waitTillOK_p13aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p13aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p13a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p13aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function trials_practice_p13aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(trials_practice_p13a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function trials_practice_p13aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var trials;
function trialsLoopBegin(trialsLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    trials = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'conditions/conditions_Stroop.csv',
      seed: undefined, name: 'trials'
    });
    psychoJS.experiment.addLoop(trials); // add the loop to the experiment
    currentLoop = trials;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    trials.forEach(function() {
      snapshot = trials.getSnapshot();
    
      trialsLoopScheduler.add(importConditions(snapshot));
      trialsLoopScheduler.add(p13_leadinRoutineBegin(snapshot));
      trialsLoopScheduler.add(p13_leadinRoutineEachFrame());
      trialsLoopScheduler.add(p13_leadinRoutineEnd(snapshot));
      const loop_waitTillOK_p13bLoopScheduler = new Scheduler(psychoJS);
      trialsLoopScheduler.add(loop_waitTillOK_p13bLoopBegin(loop_waitTillOK_p13bLoopScheduler, snapshot));
      trialsLoopScheduler.add(loop_waitTillOK_p13bLoopScheduler);
      trialsLoopScheduler.add(loop_waitTillOK_p13bLoopEnd);
      trialsLoopScheduler.add(trialsLoopEndIteration(trialsLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p13b;
function loop_waitTillOK_p13bLoopBegin(loop_waitTillOK_p13bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p13b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p13b'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p13b); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p13b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p13b.forEach(function() {
      snapshot = loop_waitTillOK_p13b.getSnapshot();
    
      loop_waitTillOK_p13bLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p13bLoopScheduler.add(p13b_StroopRoutineBegin(snapshot));
      loop_waitTillOK_p13bLoopScheduler.add(p13b_StroopRoutineEachFrame());
      loop_waitTillOK_p13bLoopScheduler.add(p13b_StroopRoutineEnd(snapshot));
      loop_waitTillOK_p13bLoopScheduler.add(loop_waitTillOK_p13bLoopEndIteration(loop_waitTillOK_p13bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p13bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p13b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p13bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function trialsLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(trials);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function trialsLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p13LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p13);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p13LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p14a;
function loop_inTime_p14aLoopBegin(loop_inTime_p14aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p14a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p14a'
    });
    psychoJS.experiment.addLoop(loop_inTime_p14a); // add the loop to the experiment
    currentLoop = loop_inTime_p14a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p14a.forEach(function() {
      snapshot = loop_inTime_p14a.getSnapshot();
    
      loop_inTime_p14aLoopScheduler.add(importConditions(snapshot));
      const loop_instr_p14LoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p14aLoopScheduler.add(loop_instr_p14LoopBegin(loop_instr_p14LoopScheduler, snapshot));
      loop_inTime_p14aLoopScheduler.add(loop_instr_p14LoopScheduler);
      loop_inTime_p14aLoopScheduler.add(loop_instr_p14LoopEnd);
      const loop_waitTillOK_p14aLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p14aLoopScheduler.add(loop_waitTillOK_p14aLoopBegin(loop_waitTillOK_p14aLoopScheduler, snapshot));
      loop_inTime_p14aLoopScheduler.add(loop_waitTillOK_p14aLoopScheduler);
      loop_inTime_p14aLoopScheduler.add(loop_waitTillOK_p14aLoopEnd);
      loop_inTime_p14aLoopScheduler.add(p14a_inTimeRoutineBegin(snapshot));
      loop_inTime_p14aLoopScheduler.add(p14a_inTimeRoutineEachFrame());
      loop_inTime_p14aLoopScheduler.add(p14a_inTimeRoutineEnd(snapshot));
      loop_inTime_p14aLoopScheduler.add(loop_inTime_p14aLoopEndIteration(loop_inTime_p14aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_instr_p14;
function loop_instr_p14LoopBegin(loop_instr_p14LoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_instr_p14 = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: 'instructions/list_instr_p14.csv',
      seed: undefined, name: 'loop_instr_p14'
    });
    psychoJS.experiment.addLoop(loop_instr_p14); // add the loop to the experiment
    currentLoop = loop_instr_p14;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_instr_p14.forEach(function() {
      snapshot = loop_instr_p14.getSnapshot();
    
      loop_instr_p14LoopScheduler.add(importConditions(snapshot));
      loop_instr_p14LoopScheduler.add(p14_TMTRoutineBegin(snapshot));
      loop_instr_p14LoopScheduler.add(p14_TMTRoutineEachFrame());
      loop_instr_p14LoopScheduler.add(p14_TMTRoutineEnd(snapshot));
      loop_instr_p14LoopScheduler.add(loop_instr_p14LoopEndIteration(loop_instr_p14LoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_instr_p14LoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_instr_p14);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_instr_p14LoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_waitTillOK_p14a;
function loop_waitTillOK_p14aLoopBegin(loop_waitTillOK_p14aLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p14a = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p14a'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p14a); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p14a;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p14a.forEach(function() {
      snapshot = loop_waitTillOK_p14a.getSnapshot();
    
      loop_waitTillOK_p14aLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p14aLoopScheduler.add(p14a_TMT_NumbersRoutineBegin(snapshot));
      loop_waitTillOK_p14aLoopScheduler.add(p14a_TMT_NumbersRoutineEachFrame());
      loop_waitTillOK_p14aLoopScheduler.add(p14a_TMT_NumbersRoutineEnd(snapshot));
      loop_waitTillOK_p14aLoopScheduler.add(loop_waitTillOK_p14aLoopEndIteration(loop_waitTillOK_p14aLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p14aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p14a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p14aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p14aLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p14a);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p14aLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var loop_inTime_p14b;
function loop_inTime_p14bLoopBegin(loop_inTime_p14bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_inTime_p14b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: inTime, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_inTime_p14b'
    });
    psychoJS.experiment.addLoop(loop_inTime_p14b); // add the loop to the experiment
    currentLoop = loop_inTime_p14b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_inTime_p14b.forEach(function() {
      snapshot = loop_inTime_p14b.getSnapshot();
    
      loop_inTime_p14bLoopScheduler.add(importConditions(snapshot));
      const loop_waitTillOK_p14bLoopScheduler = new Scheduler(psychoJS);
      loop_inTime_p14bLoopScheduler.add(loop_waitTillOK_p14bLoopBegin(loop_waitTillOK_p14bLoopScheduler, snapshot));
      loop_inTime_p14bLoopScheduler.add(loop_waitTillOK_p14bLoopScheduler);
      loop_inTime_p14bLoopScheduler.add(loop_waitTillOK_p14bLoopEnd);
      loop_inTime_p14bLoopScheduler.add(p14b_inTimeRoutineBegin(snapshot));
      loop_inTime_p14bLoopScheduler.add(p14b_inTimeRoutineEachFrame());
      loop_inTime_p14bLoopScheduler.add(p14b_inTimeRoutineEnd(snapshot));
      loop_inTime_p14bLoopScheduler.add(loop_inTime_p14bLoopEndIteration(loop_inTime_p14bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


var loop_waitTillOK_p14b;
function loop_waitTillOK_p14bLoopBegin(loop_waitTillOK_p14bLoopScheduler, snapshot) {
  return async function() {
    TrialHandler.fromSnapshot(snapshot); // update internal variables (.thisN etc) of the loop
    
    // set up handler to look after randomisation of conditions etc
    loop_waitTillOK_p14b = new TrialHandler({
      psychoJS: psychoJS,
      nReps: 200, method: TrialHandler.Method.SEQUENTIAL,
      extraInfo: expInfo, originPath: undefined,
      trialList: undefined,
      seed: undefined, name: 'loop_waitTillOK_p14b'
    });
    psychoJS.experiment.addLoop(loop_waitTillOK_p14b); // add the loop to the experiment
    currentLoop = loop_waitTillOK_p14b;  // we're now the current loop
    
    // Schedule all the trials in the trialList:
    loop_waitTillOK_p14b.forEach(function() {
      snapshot = loop_waitTillOK_p14b.getSnapshot();
    
      loop_waitTillOK_p14bLoopScheduler.add(importConditions(snapshot));
      loop_waitTillOK_p14bLoopScheduler.add(p14b_TMT_LettersRoutineBegin(snapshot));
      loop_waitTillOK_p14bLoopScheduler.add(p14b_TMT_LettersRoutineEachFrame());
      loop_waitTillOK_p14bLoopScheduler.add(p14b_TMT_LettersRoutineEnd(snapshot));
      loop_waitTillOK_p14bLoopScheduler.add(loop_waitTillOK_p14bLoopEndIteration(loop_waitTillOK_p14bLoopScheduler, snapshot));
    });
    
    return Scheduler.Event.NEXT;
  }
}


async function loop_waitTillOK_p14bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_waitTillOK_p14b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_waitTillOK_p14bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


async function loop_inTime_p14bLoopEnd() {
  // terminate loop
  psychoJS.experiment.removeLoop(loop_inTime_p14b);
  // update the current loop from the ExperimentHandler
  if (psychoJS.experiment._unfinishedLoops.length>0)
    currentLoop = psychoJS.experiment._unfinishedLoops.at(-1);
  else
    currentLoop = psychoJS.experiment;  // so we use addData from the experiment
  return Scheduler.Event.NEXT;
}


function loop_inTime_p14bLoopEndIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return async function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        psychoJS.experiment.nextEntry(snapshot);
      }
    return Scheduler.Event.NEXT;
    }
  };
}


var p1aMaxDurationReached;
var gotValidClick;
var p1aMaxDuration;
var p1aComponents;
function p1aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p1a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p1aClock.reset();
    routineTimer.reset();
    p1aMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p1a_mouse
    // current position of the mouse:
    p1a_mouse.x = [];
    p1a_mouse.y = [];
    p1a_mouse.leftButton = [];
    p1a_mouse.midButton = [];
    p1a_mouse.rightButton = [];
    p1a_mouse.time = [];
    p1a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p1a_mouse.mouseClock.reset();
    p1a_box_next.setFillColor(new util.Color(BoxNextColor));
    p1a_box_next.setLineColor(new util.Color(BoxNextColor));
    // Run 'Begin Routine' code from p1a_code_inTime
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    psychoJS.experiment.addData('p1a.started', globalClock.getTime());
    p1aMaxDuration = null
    // keep track of which components have finished
    p1aComponents = [];
    p1aComponents.push(p1a_instr);
    p1aComponents.push(p1a_mouse);
    p1aComponents.push(p1a_box_next);
    p1aComponents.push(p1a_txt_next);
    p1aComponents.push(p1a_txt_instr);
    
    p1aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


var prevButtonState;
var _mouseButtons;
var _mouseXYs;
function p1aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p1a' ---
    // get current time
    t = p1aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p1a_instr* updates
    if (t >= 0.0 && p1a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1a_instr.tStart = t;  // (not accounting for frame time here)
      p1a_instr.frameNStart = frameN;  // exact frame index
      
      p1a_instr.setAutoDraw(true);
    }
    
    
    // if p1a_instr is active this frame...
    if (p1a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p1a_mouse* updates
    if (t >= 0.0 && p1a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1a_mouse.tStart = t;  // (not accounting for frame time here)
      p1a_mouse.frameNStart = frameN;  // exact frame index
      
      p1a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p1a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p1a_mouse is active this frame...
    if (p1a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p1a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p1a_mouse.clickableObjects = eval(p1a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p1a_mouse.clickableObjects)) {
              p1a_mouse.clickableObjects = [p1a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p1a_mouse.clickableObjects) {
              if (obj.contains(p1a_mouse)) {
                  gotValidClick = true;
                  p1a_mouse.clicked_name.push(obj.name);
              }
          }
          if (!gotValidClick) {
              p1a_mouse.clicked_name.push(null);
          }
          _mouseXYs = p1a_mouse.getPos();
          p1a_mouse.x.push(_mouseXYs[0]);
          p1a_mouse.y.push(_mouseXYs[1]);
          p1a_mouse.leftButton.push(_mouseButtons[0]);
          p1a_mouse.midButton.push(_mouseButtons[1]);
          p1a_mouse.rightButton.push(_mouseButtons[2]);
          p1a_mouse.time.push(p1a_mouse.mouseClock.getTime());
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p1a_box_next* updates
    if (t >= 0.0 && p1a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1a_box_next.tStart = t;  // (not accounting for frame time here)
      p1a_box_next.frameNStart = frameN;  // exact frame index
      
      p1a_box_next.setAutoDraw(true);
    }
    
    
    // if p1a_box_next is active this frame...
    if (p1a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1a_txt_next* updates
    if (t >= 0.0 && p1a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1a_txt_next.tStart = t;  // (not accounting for frame time here)
      p1a_txt_next.frameNStart = frameN;  // exact frame index
      
      p1a_txt_next.setAutoDraw(true);
    }
    
    
    // if p1a_txt_next is active this frame...
    if (p1a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1a_txt_instr* updates
    if (t >= 0.0 && p1a_txt_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1a_txt_instr.tStart = t;  // (not accounting for frame time here)
      p1a_txt_instr.frameNStart = frameN;  // exact frame index
      
      p1a_txt_instr.setAutoDraw(true);
    }
    
    
    // if p1a_txt_instr is active this frame...
    if (p1a_txt_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p1aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p1aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p1a' ---
    p1aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p1a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p1a_mouse.x', p1a_mouse.x);
    psychoJS.experiment.addData('p1a_mouse.y', p1a_mouse.y);
    psychoJS.experiment.addData('p1a_mouse.leftButton', p1a_mouse.leftButton);
    psychoJS.experiment.addData('p1a_mouse.midButton', p1a_mouse.midButton);
    psychoJS.experiment.addData('p1a_mouse.rightButton', p1a_mouse.rightButton);
    psychoJS.experiment.addData('p1a_mouse.time', p1a_mouse.time);
    psychoJS.experiment.addData('p1a_mouse.clicked_name', p1a_mouse.clicked_name);
    
    // the Routine "p1a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p1_ReadingMaxDurationReached;
var p1_shapeID;
var k;
var skipThisTrial;
var p1_ReadingMaxDuration;
var p1_ReadingComponents;
function p1_ReadingRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p1_Reading' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p1_ReadingClock.reset();
    routineTimer.reset();
    p1_ReadingMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p1_code
    p1_shapeID = [p1_imgSX, p1_imgDX];
    k = 0;
    if ((p1_mouse.isPressedIn(p1_box_next) && (p1_isCorrect === 1))) {
        loop_waitTillOK_p1.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p1_mouse.isPressedIn(p1_box_next) && (p1_isCorrect === 0))) {
            p1_opTryBox = 1;
            p1_opTryTxt = 1;
            p1_opNextBox = 0;
            p1_opNextTxt = 0;
        } else {
            for (var thisShape, _pj_c = 0, _pj_a = p1_shapeID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisShape = _pj_a[_pj_c];
                k = (k + 1);
                if (p1_mouse.isPressedIn(thisShape)) {
                    p1_stimColors[k] = cAzul;
                    p1_opTryBox = 0;
                    p1_opTryTxt = 0;
                    p1_opNextBox = 1;
                    p1_opNextTxt = 1;
                    if ((k === p1_corrAns_Idx)) {
                        p1_isCorrect = 1;
                        p1_ans = "square";
                    } else {
                        p1_isCorrect = 0;
                        p1_ans = "triangle";
                    }
                } else {
                    p1_stimColors[k] = cWhite;
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p1_mouse
    // current position of the mouse:
    p1_mouse.x = [];
    p1_mouse.y = [];
    p1_mouse.leftButton = [];
    p1_mouse.midButton = [];
    p1_mouse.rightButton = [];
    p1_mouse.time = [];
    p1_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p1_mouse.mouseClock.reset();
    p1_imgSX.setFillColor(new util.Color(p1_stimColors[1]));
    p1_imgSX.setLineColor(new util.Color(p1_stimColors[1]));
    p1_imgDX.setFillColor(new util.Color(p1_stimColors[2]));
    p1_imgDX.setLineColor(new util.Color(p1_stimColors[2]));
    p1_box_next.setFillColor(new util.Color(BoxNextColor));
    p1_box_next.setOpacity(p1_opNextBox);
    p1_box_next.setLineColor(new util.Color(cGrey));
    p1_box_try.setFillColor(new util.Color(BoxTryColor));
    p1_box_try.setOpacity(p1_opTryBox);
    p1_box_try.setLineColor(new util.Color(cGrey));
    p1_txt_next.setOpacity(p1_opNextTxt);
    p1_txt_try.setOpacity(p1_opTryTxt);
    psychoJS.experiment.addData('p1_Reading.started', globalClock.getTime());
    p1_ReadingMaxDuration = null
    // keep track of which components have finished
    p1_ReadingComponents = [];
    p1_ReadingComponents.push(p1_txt);
    p1_ReadingComponents.push(p1_mouse);
    p1_ReadingComponents.push(p1_imgSX);
    p1_ReadingComponents.push(p1_imgDX);
    p1_ReadingComponents.push(p1_box_next);
    p1_ReadingComponents.push(p1_box_try);
    p1_ReadingComponents.push(p1_txt_next);
    p1_ReadingComponents.push(p1_txt_try);
    
    p1_ReadingComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p1_ReadingRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p1_Reading' ---
    // get current time
    t = p1_ReadingClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p1_txt* updates
    if (t >= 0.0 && p1_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_txt.tStart = t;  // (not accounting for frame time here)
      p1_txt.frameNStart = frameN;  // exact frame index
      
      p1_txt.setAutoDraw(true);
    }
    
    
    // if p1_txt is active this frame...
    if (p1_txt.status === PsychoJS.Status.STARTED) {
    }
    
    // *p1_mouse* updates
    if (t >= 0.0 && p1_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_mouse.tStart = t;  // (not accounting for frame time here)
      p1_mouse.frameNStart = frameN;  // exact frame index
      
      p1_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p1_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p1_mouse is active this frame...
    if (p1_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p1_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p1_mouse.clickableObjects = eval([p1_imgDX, p1_imgSX, p1_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p1_mouse.clickableObjects)) {
              p1_mouse.clickableObjects = [p1_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p1_mouse.clickableObjects) {
              if (obj.contains(p1_mouse)) {
                  gotValidClick = true;
                  p1_mouse.clicked_name.push(obj.name);
              }
          }
          if (!gotValidClick) {
              p1_mouse.clicked_name.push(null);
          }
          _mouseXYs = p1_mouse.getPos();
          p1_mouse.x.push(_mouseXYs[0]);
          p1_mouse.y.push(_mouseXYs[1]);
          p1_mouse.leftButton.push(_mouseButtons[0]);
          p1_mouse.midButton.push(_mouseButtons[1]);
          p1_mouse.rightButton.push(_mouseButtons[2]);
          p1_mouse.time.push(p1_mouse.mouseClock.getTime());
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p1_imgSX* updates
    if (t >= 0.0 && p1_imgSX.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_imgSX.tStart = t;  // (not accounting for frame time here)
      p1_imgSX.frameNStart = frameN;  // exact frame index
      
      p1_imgSX.setAutoDraw(true);
    }
    
    
    // if p1_imgSX is active this frame...
    if (p1_imgSX.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1_imgDX* updates
    if (t >= 0.0 && p1_imgDX.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_imgDX.tStart = t;  // (not accounting for frame time here)
      p1_imgDX.frameNStart = frameN;  // exact frame index
      
      p1_imgDX.setAutoDraw(true);
    }
    
    
    // if p1_imgDX is active this frame...
    if (p1_imgDX.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1_box_next* updates
    if (t >= 0.0 && p1_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_box_next.tStart = t;  // (not accounting for frame time here)
      p1_box_next.frameNStart = frameN;  // exact frame index
      
      p1_box_next.setAutoDraw(true);
    }
    
    
    // if p1_box_next is active this frame...
    if (p1_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1_box_try* updates
    if (t >= 0.0 && p1_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_box_try.tStart = t;  // (not accounting for frame time here)
      p1_box_try.frameNStart = frameN;  // exact frame index
      
      p1_box_try.setAutoDraw(true);
    }
    
    
    // if p1_box_try is active this frame...
    if (p1_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1_txt_next* updates
    if (t >= 0.0 && p1_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_txt_next.tStart = t;  // (not accounting for frame time here)
      p1_txt_next.frameNStart = frameN;  // exact frame index
      
      p1_txt_next.setAutoDraw(true);
    }
    
    
    // if p1_txt_next is active this frame...
    if (p1_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1_txt_try* updates
    if (t >= 0.0 && p1_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1_txt_try.tStart = t;  // (not accounting for frame time here)
      p1_txt_try.frameNStart = frameN;  // exact frame index
      
      p1_txt_try.setAutoDraw(true);
    }
    
    
    // if p1_txt_try is active this frame...
    if (p1_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p1_ReadingComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p1_ReadingRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p1_Reading' ---
    p1_ReadingComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p1_Reading.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p1_mouse.x', p1_mouse.x);
    psychoJS.experiment.addData('p1_mouse.y', p1_mouse.y);
    psychoJS.experiment.addData('p1_mouse.leftButton', p1_mouse.leftButton);
    psychoJS.experiment.addData('p1_mouse.midButton', p1_mouse.midButton);
    psychoJS.experiment.addData('p1_mouse.rightButton', p1_mouse.rightButton);
    psychoJS.experiment.addData('p1_mouse.time', p1_mouse.time);
    psychoJS.experiment.addData('p1_mouse.clicked_name', p1_mouse.clicked_name);
    
    // Run 'End Routine' code from p1_code_ans
    
    psychoJS.experiment.addData('p1_isCorrect',p1_isCorrect)
    psychoJS.experiment.addData('p1_ans', p1_ans)
    psychoJS.experiment.addData('p1_corrAns',p1_corrAns)
    // the Routine "p1_Reading" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p1_inTimeMaxDurationReached;
var p1_inTimeMaxDuration;
var p1_inTimeComponents;
function p1_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p1_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p1_inTimeClock.reset();
    routineTimer.reset();
    p1_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p1_inTime.started', globalClock.getTime());
    p1_inTimeMaxDuration = null
    // keep track of which components have finished
    p1_inTimeComponents = [];
    
    p1_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p1_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p1_inTime' ---
    // get current time
    t = p1_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p1_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p1_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p1_inTime' ---
    p1_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p1_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p1_code_inTime
    psychoJS.experiment.addData("p1_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p1_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p1bMaxDurationReached;
var p1bMaxDuration;
var p1bComponents;
function p1bRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p1b' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p1bClock.reset();
    routineTimer.reset();
    p1bMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p1b_mouse
    // current position of the mouse:
    p1b_mouse.x = [];
    p1b_mouse.y = [];
    p1b_mouse.leftButton = [];
    p1b_mouse.midButton = [];
    p1b_mouse.rightButton = [];
    p1b_mouse.time = [];
    p1b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p1b_mouse.mouseClock.reset();
    p1b_box_next.setFillColor(new util.Color(BoxNextColor));
    p1b_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p1b.started', globalClock.getTime());
    p1bMaxDuration = null
    // keep track of which components have finished
    p1bComponents = [];
    p1bComponents.push(p1b_instr);
    p1bComponents.push(p1b_mouse);
    p1bComponents.push(p1b_box_next);
    p1bComponents.push(p1b_txt_next);
    
    p1bComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p1bRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p1b' ---
    // get current time
    t = p1bClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p1b_instr* updates
    if (t >= 0.0 && p1b_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1b_instr.tStart = t;  // (not accounting for frame time here)
      p1b_instr.frameNStart = frameN;  // exact frame index
      
      p1b_instr.setAutoDraw(true);
    }
    
    
    // if p1b_instr is active this frame...
    if (p1b_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p1b_mouse* updates
    if (t >= 0.0 && p1b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1b_mouse.tStart = t;  // (not accounting for frame time here)
      p1b_mouse.frameNStart = frameN;  // exact frame index
      
      p1b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p1b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p1b_mouse is active this frame...
    if (p1b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p1b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p1b_mouse.clickableObjects = eval(p1b_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p1b_mouse.clickableObjects)) {
              p1b_mouse.clickableObjects = [p1b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p1b_mouse.clickableObjects) {
              if (obj.contains(p1b_mouse)) {
                  gotValidClick = true;
                  p1b_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p1b_mouse.clickableObjects = eval(p1b_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p1b_mouse.clickableObjects)) {
              p1b_mouse.clickableObjects = [p1b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p1b_mouse.clickableObjects) {
              if (obj.contains(p1b_mouse)) {
                  gotValidClick = true;
                  p1b_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p1b_mouse.getPos();
            p1b_mouse.x.push(_mouseXYs[0]);
            p1b_mouse.y.push(_mouseXYs[1]);
            p1b_mouse.leftButton.push(_mouseButtons[0]);
            p1b_mouse.midButton.push(_mouseButtons[1]);
            p1b_mouse.rightButton.push(_mouseButtons[2]);
            p1b_mouse.time.push(p1b_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p1b_box_next* updates
    if (t >= 0.0 && p1b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1b_box_next.tStart = t;  // (not accounting for frame time here)
      p1b_box_next.frameNStart = frameN;  // exact frame index
      
      p1b_box_next.setAutoDraw(true);
    }
    
    
    // if p1b_box_next is active this frame...
    if (p1b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p1b_txt_next* updates
    if (t >= 0.0 && p1b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p1b_txt_next.tStart = t;  // (not accounting for frame time here)
      p1b_txt_next.frameNStart = frameN;  // exact frame index
      
      p1b_txt_next.setAutoDraw(true);
    }
    
    
    // if p1b_txt_next is active this frame...
    if (p1b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p1bComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p1bRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p1b' ---
    p1bComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p1b.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p1b_mouse.x', p1b_mouse.x);
    psychoJS.experiment.addData('p1b_mouse.y', p1b_mouse.y);
    psychoJS.experiment.addData('p1b_mouse.leftButton', p1b_mouse.leftButton);
    psychoJS.experiment.addData('p1b_mouse.midButton', p1b_mouse.midButton);
    psychoJS.experiment.addData('p1b_mouse.rightButton', p1b_mouse.rightButton);
    psychoJS.experiment.addData('p1b_mouse.time', p1b_mouse.time);
    psychoJS.experiment.addData('p1b_mouse.clicked_name', p1b_mouse.clicked_name);
    
    // the Routine "p1b" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p2aMaxDurationReached;
var p2aMaxDuration;
var p2aComponents;
function p2aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p2a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p2aClock.reset();
    routineTimer.reset();
    p2aMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p2a_mouse
    // current position of the mouse:
    p2a_mouse.x = [];
    p2a_mouse.y = [];
    p2a_mouse.leftButton = [];
    p2a_mouse.midButton = [];
    p2a_mouse.rightButton = [];
    p2a_mouse.time = [];
    p2a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p2a_mouse.mouseClock.reset();
    p2a_box_next.setFillColor(new util.Color(BoxNextColor));
    p2a_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p2a.started', globalClock.getTime());
    p2aMaxDuration = null
    // keep track of which components have finished
    p2aComponents = [];
    p2aComponents.push(p2a_instr);
    p2aComponents.push(p2a_mouse);
    p2aComponents.push(p2a_box_next);
    p2aComponents.push(p2a_txt_next);
    
    p2aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p2aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p2a' ---
    // get current time
    t = p2aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p2a_instr* updates
    if (t >= 0.0 && p2a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2a_instr.tStart = t;  // (not accounting for frame time here)
      p2a_instr.frameNStart = frameN;  // exact frame index
      
      p2a_instr.setAutoDraw(true);
    }
    
    
    // if p2a_instr is active this frame...
    if (p2a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p2a_mouse* updates
    if (t >= 0.0 && p2a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2a_mouse.tStart = t;  // (not accounting for frame time here)
      p2a_mouse.frameNStart = frameN;  // exact frame index
      
      p2a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p2a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p2a_mouse is active this frame...
    if (p2a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p2a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p2a_mouse.clickableObjects = eval(p2a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p2a_mouse.clickableObjects)) {
              p2a_mouse.clickableObjects = [p2a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p2a_mouse.clickableObjects) {
              if (obj.contains(p2a_mouse)) {
                  gotValidClick = true;
                  p2a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p2a_mouse.clickableObjects = eval(p2a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p2a_mouse.clickableObjects)) {
              p2a_mouse.clickableObjects = [p2a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p2a_mouse.clickableObjects) {
              if (obj.contains(p2a_mouse)) {
                  gotValidClick = true;
                  p2a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p2a_mouse.getPos();
            p2a_mouse.x.push(_mouseXYs[0]);
            p2a_mouse.y.push(_mouseXYs[1]);
            p2a_mouse.leftButton.push(_mouseButtons[0]);
            p2a_mouse.midButton.push(_mouseButtons[1]);
            p2a_mouse.rightButton.push(_mouseButtons[2]);
            p2a_mouse.time.push(p2a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p2a_box_next* updates
    if (t >= 0.0 && p2a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2a_box_next.tStart = t;  // (not accounting for frame time here)
      p2a_box_next.frameNStart = frameN;  // exact frame index
      
      p2a_box_next.setAutoDraw(true);
    }
    
    
    // if p2a_box_next is active this frame...
    if (p2a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2a_txt_next* updates
    if (t >= 0.0 && p2a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2a_txt_next.tStart = t;  // (not accounting for frame time here)
      p2a_txt_next.frameNStart = frameN;  // exact frame index
      
      p2a_txt_next.setAutoDraw(true);
    }
    
    
    // if p2a_txt_next is active this frame...
    if (p2a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p2aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p2aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p2a' ---
    p2aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p2a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p2a_mouse.x', p2a_mouse.x);
    psychoJS.experiment.addData('p2a_mouse.y', p2a_mouse.y);
    psychoJS.experiment.addData('p2a_mouse.leftButton', p2a_mouse.leftButton);
    psychoJS.experiment.addData('p2a_mouse.midButton', p2a_mouse.midButton);
    psychoJS.experiment.addData('p2a_mouse.rightButton', p2a_mouse.rightButton);
    psychoJS.experiment.addData('p2a_mouse.time', p2a_mouse.time);
    psychoJS.experiment.addData('p2a_mouse.clicked_name', p2a_mouse.clicked_name);
    
    // the Routine "p2a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p2_Att_JWordMaxDurationReached;
var p2_stimID;
var i;
var p2_Att_JWordMaxDuration;
var p2_Att_JWordComponents;
function p2_Att_JWordRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p2_Att_JWord' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p2_Att_JWordClock.reset();
    routineTimer.reset();
    p2_Att_JWordMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p2_code
    p2_stimID = [p2_sq_1, p2_sq_2, p2_sq_3, p2_sq_4, p2_sq_5, p2_sq_6, p2_sq_7, p2_sq_8, p2_sq_9, p2_sq_10];
    k = 0;
    i = 0;
    if (((p2_mouse.isPressedIn(p2_box_next) && (util.sum(p2_isPicked) === 1)) && (p2_isPicked[5] === 1))) {
        p2_countNext = (p2_countNext + 1);
        loop_waitTillOK_p2.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
        for (var val, _pj_c = 0, _pj_a = p2_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p2_ans_Idx = (p2_ans_Idx + [i]);
                p2_ans = (p2_ans + p2_words[i]);
                p2_countCorrect = (p2_countCorrect + (p2_corrAns_Vec[i] * val));
            }
            i = (i + 1);
        }
        if (((p2_countCorrect === util.sum(p2_corrAns_Vec)) && (p2_countNext === 1))) {
            p2_isCorrect = 1;
            p2_points = 2;
        } else {
            p2_isCorrect = 0;
            p2_points = 0;
        }
    } else {
        if (((p2_mouse.isPressedIn(p2_box_next) && (util.sum(p2_isPicked) === 1)) && (p2_isPicked[5] === 0))) {
            p2_isCorrect = 0;
            p2_countNext = (p2_countNext + 1);
            p2_opTryBox = 1;
            p2_opTryTxt = 1;
            p2_opNextBox = 0;
            p2_opNextTxt = 0;
        } else {
            if ((p2_mouse.isPressedIn(p2_box_next) && (util.sum(p2_isPicked) !== 1))) {
                p2_isCorrect = 0;
                p2_countNext = (p2_countNext + 1);
                p2_opTryBox = 1;
                p2_opTryTxt = 1;
                p2_opNextBox = 0;
                p2_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p2_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p2_mouse.isPressedIn(thisStim) && (p2_isPicked[k] === 0))) {
                        p2_stimColors[k] = cAzul;
                        p2_isPicked[k] = 1;
                        p2_opTryBox = 0;
                        p2_opTryTxt = 0;
                        p2_opNextBox = 1;
                        p2_opNextTxt = 1;
                    } else {
                        p2_stimColors[k] = cGrey;
                        p2_isPicked[k] = 0;
                        p2_opTryBox = 0;
                        p2_opTryTxt = 0;
                        p2_opNextBox = 1;
                        p2_opNextTxt = 1;
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p2_mouse
    // current position of the mouse:
    p2_mouse.x = [];
    p2_mouse.y = [];
    p2_mouse.leftButton = [];
    p2_mouse.midButton = [];
    p2_mouse.rightButton = [];
    p2_mouse.time = [];
    p2_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p2_mouse.mouseClock.reset();
    p2_sq_10.setFillColor(new util.Color(p2_stimColors[10]));
    p2_sq_9.setFillColor(new util.Color(p2_stimColors[9]));
    p2_sq_8.setFillColor(new util.Color(p2_stimColors[8]));
    p2_sq_7.setFillColor(new util.Color(p2_stimColors[7]));
    p2_sq_6.setFillColor(new util.Color(p2_stimColors[6]));
    p2_sq_5.setFillColor(new util.Color(p2_stimColors[5]));
    p2_sq_4.setFillColor(new util.Color(p2_stimColors[4]));
    p2_sq_3.setFillColor(new util.Color(p2_stimColors[3]));
    p2_sq_2.setFillColor(new util.Color(p2_stimColors[2]));
    p2_sq_1.setFillColor(new util.Color(p2_stimColors[1]));
    p2_txt_1.setText(p2_words[1]);
    p2_txt_2.setText(p2_words[2]);
    p2_txt_3.setText(p2_words[3]);
    p2_txt_4.setText(p2_words[4]);
    p2_txt_5.setText(p2_words[5]);
    p2_txt_6.setText(p2_words[6]);
    p2_txt_7.setText(p2_words[7]);
    p2_txt_8.setText(p2_words[8]);
    p2_txt_9.setText(p2_words[9]);
    p2_txt_10.setText(p2_words[10]);
    p2_box_try.setFillColor(new util.Color(BoxTryColor));
    p2_box_try.setOpacity(p2_opTryBox);
    p2_box_try.setLineColor(new util.Color(cGrey));
    p2_txt_try.setOpacity(p2_opTryTxt);
    p2_box_next.setFillColor(new util.Color(BoxNextColor));
    p2_box_next.setOpacity(p2_opNextBox);
    p2_box_next.setLineColor(new util.Color(cGrey));
    p2_txt_next.setOpacity(p2_opNextTxt);
    psychoJS.experiment.addData('p2_Att_JWord.started', globalClock.getTime());
    p2_Att_JWordMaxDuration = null
    // keep track of which components have finished
    p2_Att_JWordComponents = [];
    p2_Att_JWordComponents.push(p2_mouse);
    p2_Att_JWordComponents.push(p2_txt_q);
    p2_Att_JWordComponents.push(p2_sq_10);
    p2_Att_JWordComponents.push(p2_sq_9);
    p2_Att_JWordComponents.push(p2_sq_8);
    p2_Att_JWordComponents.push(p2_sq_7);
    p2_Att_JWordComponents.push(p2_sq_6);
    p2_Att_JWordComponents.push(p2_sq_5);
    p2_Att_JWordComponents.push(p2_sq_4);
    p2_Att_JWordComponents.push(p2_sq_3);
    p2_Att_JWordComponents.push(p2_sq_2);
    p2_Att_JWordComponents.push(p2_sq_1);
    p2_Att_JWordComponents.push(p2_txt_1);
    p2_Att_JWordComponents.push(p2_txt_2);
    p2_Att_JWordComponents.push(p2_txt_3);
    p2_Att_JWordComponents.push(p2_txt_4);
    p2_Att_JWordComponents.push(p2_txt_5);
    p2_Att_JWordComponents.push(p2_txt_6);
    p2_Att_JWordComponents.push(p2_txt_7);
    p2_Att_JWordComponents.push(p2_txt_8);
    p2_Att_JWordComponents.push(p2_txt_9);
    p2_Att_JWordComponents.push(p2_txt_10);
    p2_Att_JWordComponents.push(p2_box_try);
    p2_Att_JWordComponents.push(p2_txt_try);
    p2_Att_JWordComponents.push(p2_box_next);
    p2_Att_JWordComponents.push(p2_txt_next);
    
    p2_Att_JWordComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p2_Att_JWordRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p2_Att_JWord' ---
    // get current time
    t = p2_Att_JWordClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // *p2_mouse* updates
    if (t >= 0 && p2_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_mouse.tStart = t;  // (not accounting for frame time here)
      p2_mouse.frameNStart = frameN;  // exact frame index
      
      p2_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p2_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p2_mouse is active this frame...
    if (p2_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p2_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p2_mouse.clickableObjects = eval([p2_sq_1, p2_sq_2, p2_sq_3, p2_sq_4, p2_sq_5, p2_sq_6, p2_sq_7, p2_sq_8, p2_sq_9, p2_sq_10, p2_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p2_mouse.clickableObjects)) {
              p2_mouse.clickableObjects = [p2_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p2_mouse.clickableObjects) {
              if (obj.contains(p2_mouse)) {
                  gotValidClick = true;
                  p2_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p2_mouse.clickableObjects = eval([p2_sq_1, p2_sq_2, p2_sq_3, p2_sq_4, p2_sq_5, p2_sq_6, p2_sq_7, p2_sq_8, p2_sq_9, p2_sq_10, p2_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p2_mouse.clickableObjects)) {
              p2_mouse.clickableObjects = [p2_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p2_mouse.clickableObjects) {
              if (obj.contains(p2_mouse)) {
                  gotValidClick = true;
                  p2_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p2_mouse.getPos();
            p2_mouse.x.push(_mouseXYs[0]);
            p2_mouse.y.push(_mouseXYs[1]);
            p2_mouse.leftButton.push(_mouseButtons[0]);
            p2_mouse.midButton.push(_mouseButtons[1]);
            p2_mouse.rightButton.push(_mouseButtons[2]);
            p2_mouse.time.push(p2_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p2_txt_q* updates
    if (t >= 0.0 && p2_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_q.tStart = t;  // (not accounting for frame time here)
      p2_txt_q.frameNStart = frameN;  // exact frame index
      
      p2_txt_q.setAutoDraw(true);
    }
    
    
    // if p2_txt_q is active this frame...
    if (p2_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_10* updates
    if (t >= 0.0 && p2_sq_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_10.tStart = t;  // (not accounting for frame time here)
      p2_sq_10.frameNStart = frameN;  // exact frame index
      
      p2_sq_10.setAutoDraw(true);
    }
    
    
    // if p2_sq_10 is active this frame...
    if (p2_sq_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_9* updates
    if (t >= 0.0 && p2_sq_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_9.tStart = t;  // (not accounting for frame time here)
      p2_sq_9.frameNStart = frameN;  // exact frame index
      
      p2_sq_9.setAutoDraw(true);
    }
    
    
    // if p2_sq_9 is active this frame...
    if (p2_sq_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_8* updates
    if (t >= 0.0 && p2_sq_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_8.tStart = t;  // (not accounting for frame time here)
      p2_sq_8.frameNStart = frameN;  // exact frame index
      
      p2_sq_8.setAutoDraw(true);
    }
    
    
    // if p2_sq_8 is active this frame...
    if (p2_sq_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_7* updates
    if (t >= 0.0 && p2_sq_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_7.tStart = t;  // (not accounting for frame time here)
      p2_sq_7.frameNStart = frameN;  // exact frame index
      
      p2_sq_7.setAutoDraw(true);
    }
    
    
    // if p2_sq_7 is active this frame...
    if (p2_sq_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_6* updates
    if (t >= 0.0 && p2_sq_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_6.tStart = t;  // (not accounting for frame time here)
      p2_sq_6.frameNStart = frameN;  // exact frame index
      
      p2_sq_6.setAutoDraw(true);
    }
    
    
    // if p2_sq_6 is active this frame...
    if (p2_sq_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_5* updates
    if (t >= 0.0 && p2_sq_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_5.tStart = t;  // (not accounting for frame time here)
      p2_sq_5.frameNStart = frameN;  // exact frame index
      
      p2_sq_5.setAutoDraw(true);
    }
    
    
    // if p2_sq_5 is active this frame...
    if (p2_sq_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_4* updates
    if (t >= 0.0 && p2_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_4.tStart = t;  // (not accounting for frame time here)
      p2_sq_4.frameNStart = frameN;  // exact frame index
      
      p2_sq_4.setAutoDraw(true);
    }
    
    
    // if p2_sq_4 is active this frame...
    if (p2_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_3* updates
    if (t >= 0.0 && p2_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_3.tStart = t;  // (not accounting for frame time here)
      p2_sq_3.frameNStart = frameN;  // exact frame index
      
      p2_sq_3.setAutoDraw(true);
    }
    
    
    // if p2_sq_3 is active this frame...
    if (p2_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_2* updates
    if (t >= 0.0 && p2_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_2.tStart = t;  // (not accounting for frame time here)
      p2_sq_2.frameNStart = frameN;  // exact frame index
      
      p2_sq_2.setAutoDraw(true);
    }
    
    
    // if p2_sq_2 is active this frame...
    if (p2_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_sq_1* updates
    if (t >= 0.0 && p2_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_sq_1.tStart = t;  // (not accounting for frame time here)
      p2_sq_1.frameNStart = frameN;  // exact frame index
      
      p2_sq_1.setAutoDraw(true);
    }
    
    
    // if p2_sq_1 is active this frame...
    if (p2_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_1* updates
    if (t >= 0.0 && p2_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_1.tStart = t;  // (not accounting for frame time here)
      p2_txt_1.frameNStart = frameN;  // exact frame index
      
      p2_txt_1.setAutoDraw(true);
    }
    
    
    // if p2_txt_1 is active this frame...
    if (p2_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_2* updates
    if (t >= 0.0 && p2_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_2.tStart = t;  // (not accounting for frame time here)
      p2_txt_2.frameNStart = frameN;  // exact frame index
      
      p2_txt_2.setAutoDraw(true);
    }
    
    
    // if p2_txt_2 is active this frame...
    if (p2_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_3* updates
    if (t >= 0.0 && p2_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_3.tStart = t;  // (not accounting for frame time here)
      p2_txt_3.frameNStart = frameN;  // exact frame index
      
      p2_txt_3.setAutoDraw(true);
    }
    
    
    // if p2_txt_3 is active this frame...
    if (p2_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_4* updates
    if (t >= 0.0 && p2_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_4.tStart = t;  // (not accounting for frame time here)
      p2_txt_4.frameNStart = frameN;  // exact frame index
      
      p2_txt_4.setAutoDraw(true);
    }
    
    
    // if p2_txt_4 is active this frame...
    if (p2_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_5* updates
    if (t >= 0.0 && p2_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_5.tStart = t;  // (not accounting for frame time here)
      p2_txt_5.frameNStart = frameN;  // exact frame index
      
      p2_txt_5.setAutoDraw(true);
    }
    
    
    // if p2_txt_5 is active this frame...
    if (p2_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_6* updates
    if (t >= 0.0 && p2_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_6.tStart = t;  // (not accounting for frame time here)
      p2_txt_6.frameNStart = frameN;  // exact frame index
      
      p2_txt_6.setAutoDraw(true);
    }
    
    
    // if p2_txt_6 is active this frame...
    if (p2_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_7* updates
    if (t >= 0.0 && p2_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_7.tStart = t;  // (not accounting for frame time here)
      p2_txt_7.frameNStart = frameN;  // exact frame index
      
      p2_txt_7.setAutoDraw(true);
    }
    
    
    // if p2_txt_7 is active this frame...
    if (p2_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_8* updates
    if (t >= 0.0 && p2_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_8.tStart = t;  // (not accounting for frame time here)
      p2_txt_8.frameNStart = frameN;  // exact frame index
      
      p2_txt_8.setAutoDraw(true);
    }
    
    
    // if p2_txt_8 is active this frame...
    if (p2_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_9* updates
    if (t >= 0.0 && p2_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_9.tStart = t;  // (not accounting for frame time here)
      p2_txt_9.frameNStart = frameN;  // exact frame index
      
      p2_txt_9.setAutoDraw(true);
    }
    
    
    // if p2_txt_9 is active this frame...
    if (p2_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_10* updates
    if (t >= 0.0 && p2_txt_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_10.tStart = t;  // (not accounting for frame time here)
      p2_txt_10.frameNStart = frameN;  // exact frame index
      
      p2_txt_10.setAutoDraw(true);
    }
    
    
    // if p2_txt_10 is active this frame...
    if (p2_txt_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_box_try* updates
    if (t >= 0 && p2_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_box_try.tStart = t;  // (not accounting for frame time here)
      p2_box_try.frameNStart = frameN;  // exact frame index
      
      p2_box_try.setAutoDraw(true);
    }
    
    
    // if p2_box_try is active this frame...
    if (p2_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_try* updates
    if (t >= 0 && p2_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_try.tStart = t;  // (not accounting for frame time here)
      p2_txt_try.frameNStart = frameN;  // exact frame index
      
      p2_txt_try.setAutoDraw(true);
    }
    
    
    // if p2_txt_try is active this frame...
    if (p2_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_box_next* updates
    if (t >= 0 && p2_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_box_next.tStart = t;  // (not accounting for frame time here)
      p2_box_next.frameNStart = frameN;  // exact frame index
      
      p2_box_next.setAutoDraw(true);
    }
    
    
    // if p2_box_next is active this frame...
    if (p2_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p2_txt_next* updates
    if (t >= 0 && p2_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p2_txt_next.tStart = t;  // (not accounting for frame time here)
      p2_txt_next.frameNStart = frameN;  // exact frame index
      
      p2_txt_next.setAutoDraw(true);
    }
    
    
    // if p2_txt_next is active this frame...
    if (p2_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p2_Att_JWordComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p2_Att_JWordRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p2_Att_JWord' ---
    p2_Att_JWordComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p2_Att_JWord.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p2_mouse.x', p2_mouse.x);
    psychoJS.experiment.addData('p2_mouse.y', p2_mouse.y);
    psychoJS.experiment.addData('p2_mouse.leftButton', p2_mouse.leftButton);
    psychoJS.experiment.addData('p2_mouse.midButton', p2_mouse.midButton);
    psychoJS.experiment.addData('p2_mouse.rightButton', p2_mouse.rightButton);
    psychoJS.experiment.addData('p2_mouse.time', p2_mouse.time);
    psychoJS.experiment.addData('p2_mouse.clicked_name', p2_mouse.clicked_name);
    
    // Run 'End Routine' code from p2_code_ans
    psychoJS.experiment.addData('p2_isCorrect',p2_isCorrect)
    psychoJS.experiment.addData('p2_ans', p2_ans)
    psychoJS.experiment.addData('p2_ans_Idx', p2_ans_Idx)
    psychoJS.experiment.addData('p2_corrAns',p2_corrAns)
    psychoJS.experiment.addData('p2_corrAns_Idx',p2_corrAns_Idx)
    psychoJS.experiment.addData('p2_countNext',p2_countNext)
    psychoJS.experiment.addData('p2_points',p2_points)
    // the Routine "p2_Att_JWord" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p2_inTimeMaxDurationReached;
var p2_inTimeMaxDuration;
var p2_inTimeComponents;
function p2_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p2_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p2_inTimeClock.reset();
    routineTimer.reset();
    p2_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p2_inTime.started', globalClock.getTime());
    p2_inTimeMaxDuration = null
    // keep track of which components have finished
    p2_inTimeComponents = [];
    
    p2_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p2_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p2_inTime' ---
    // get current time
    t = p2_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p2_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p2_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p2_inTime' ---
    p2_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p2_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p2_code_inTime
    psychoJS.experiment.addData("p2_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p2_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p3aMaxDurationReached;
var p3aMaxDuration;
var p3aComponents;
function p3aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p3a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p3aClock.reset();
    routineTimer.reset();
    p3aMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p3a_mouse
    // current position of the mouse:
    p3a_mouse.x = [];
    p3a_mouse.y = [];
    p3a_mouse.leftButton = [];
    p3a_mouse.midButton = [];
    p3a_mouse.rightButton = [];
    p3a_mouse.time = [];
    p3a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p3a_mouse.mouseClock.reset();
    p3a_box_next.setFillColor(new util.Color(BoxNextColor));
    p3a_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p3a.started', globalClock.getTime());
    p3aMaxDuration = null
    // keep track of which components have finished
    p3aComponents = [];
    p3aComponents.push(p3a_instr);
    p3aComponents.push(p3a_mouse);
    p3aComponents.push(p3a_box_next);
    p3aComponents.push(p3a_txt_next);
    
    p3aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p3aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p3a' ---
    // get current time
    t = p3aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p3a_instr* updates
    if (t >= 0.0 && p3a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3a_instr.tStart = t;  // (not accounting for frame time here)
      p3a_instr.frameNStart = frameN;  // exact frame index
      
      p3a_instr.setAutoDraw(true);
    }
    
    
    // if p3a_instr is active this frame...
    if (p3a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p3a_mouse* updates
    if (t >= 0.0 && p3a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3a_mouse.tStart = t;  // (not accounting for frame time here)
      p3a_mouse.frameNStart = frameN;  // exact frame index
      
      p3a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p3a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p3a_mouse is active this frame...
    if (p3a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p3a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p3a_mouse.clickableObjects = eval(p3a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p3a_mouse.clickableObjects)) {
              p3a_mouse.clickableObjects = [p3a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p3a_mouse.clickableObjects) {
              if (obj.contains(p3a_mouse)) {
                  gotValidClick = true;
                  p3a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p3a_mouse.clickableObjects = eval(p3a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p3a_mouse.clickableObjects)) {
              p3a_mouse.clickableObjects = [p3a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p3a_mouse.clickableObjects) {
              if (obj.contains(p3a_mouse)) {
                  gotValidClick = true;
                  p3a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p3a_mouse.getPos();
            p3a_mouse.x.push(_mouseXYs[0]);
            p3a_mouse.y.push(_mouseXYs[1]);
            p3a_mouse.leftButton.push(_mouseButtons[0]);
            p3a_mouse.midButton.push(_mouseButtons[1]);
            p3a_mouse.rightButton.push(_mouseButtons[2]);
            p3a_mouse.time.push(p3a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p3a_box_next* updates
    if (t >= 0.0 && p3a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3a_box_next.tStart = t;  // (not accounting for frame time here)
      p3a_box_next.frameNStart = frameN;  // exact frame index
      
      p3a_box_next.setAutoDraw(true);
    }
    
    
    // if p3a_box_next is active this frame...
    if (p3a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3a_txt_next* updates
    if (t >= 0.0 && p3a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3a_txt_next.tStart = t;  // (not accounting for frame time here)
      p3a_txt_next.frameNStart = frameN;  // exact frame index
      
      p3a_txt_next.setAutoDraw(true);
    }
    
    
    // if p3a_txt_next is active this frame...
    if (p3a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p3aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p3aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p3a' ---
    p3aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p3a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p3a_mouse.x', p3a_mouse.x);
    psychoJS.experiment.addData('p3a_mouse.y', p3a_mouse.y);
    psychoJS.experiment.addData('p3a_mouse.leftButton', p3a_mouse.leftButton);
    psychoJS.experiment.addData('p3a_mouse.midButton', p3a_mouse.midButton);
    psychoJS.experiment.addData('p3a_mouse.rightButton', p3a_mouse.rightButton);
    psychoJS.experiment.addData('p3a_mouse.time', p3a_mouse.time);
    psychoJS.experiment.addData('p3a_mouse.clicked_name', p3a_mouse.clicked_name);
    
    // the Routine "p3a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p3_Att_FruitsMaxDurationReached;
var p3_stimID;
var p3_Att_FruitsMaxDuration;
var p3_Att_FruitsComponents;
function p3_Att_FruitsRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p3_Att_Fruits' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p3_Att_FruitsClock.reset();
    routineTimer.reset();
    p3_Att_FruitsMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p3_code
    p3_stimID = [p3_sq_1, p3_sq_2, p3_sq_3, p3_sq_4];
    k = 0;
    i = 0;
    if (((p3_mouse.isPressedIn(p3_box_next) && ((p3_isPicked[1] === 1) && (p3_isPicked[3] === 1))) && (util.sum(p3_isPicked) === 2))) {
        p3_countNext = (p3_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p3_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p3_ans_Idx = (p3_ans_Idx + [i]);
                p3_ans = ((p3_ans + ",") + p3_words[i]);
                p3_countCorrect = (p3_countCorrect + (val * p3_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if (((p3_countCorrect === util.sum(p3_corrAns_Vec)) && (p3_countNext === 1))) {
            p3_isCorrect = 1;
            p3_points = 2;
        } else {
            p3_isCorrect = 0;
            p3_points = 0;
        }
        loop_waitTillOK_p3.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if (((p3_mouse.isPressedIn(p3_box_next) && (util.sum(p3_isPicked) === 1)) && ((p3_isPicked[1] === 1) || (p3_isPicked[3] === 1)))) {
            p3_isCorrect = 0;
            p3_countNext = (p3_countNext + 1);
            p3_opTryBox = 1;
            p3_opTry2Txt = 1;
            p3_opTryTxt = 0;
            p3_opNextBox = 0;
            p3_opNextTxt = 0;
        } else {
            if ((p3_mouse.isPressedIn(p3_box_next) && (util.sum(p3_isPicked) === 0))) {
                p3_isCorrect = 0;
                p3_countNext = (p3_countNext + 1);
                p3_opTryBox = 1;
                p3_opTry2Txt = 1;
                p3_opTryTxt = 0;
                p3_opNextBox = 0;
                p3_opNextTxt = 0;
            } else {
                if ((p3_mouse.isPressedIn(p3_box_next) && (util.sum(p3_isPicked) > 0))) {
                    p3_isCorrect = 0;
                    p3_countNext = (p3_countNext + 1);
                    p3_opTry2Txt = 0;
                    p3_opTryBox = 1;
                    p3_opTryTxt = 1;
                    p3_opNextBox = 0;
                    p3_opNextTxt = 0;
                } else {
                    for (var thisStim, _pj_c = 0, _pj_a = p3_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                        thisStim = _pj_a[_pj_c];
                        k = (k + 1);
                        if ((p3_mouse.isPressedIn(thisStim) && (p3_isPicked[k] === 0))) {
                            p3_stimColors[k] = cAzul;
                            p3_isPicked[k] = 1;
                            p3_opTryBox = 0;
                            p3_opTry2Txt = 0;
                            p3_opTryTxt = 0;
                            p3_opNextBox = 1;
                            p3_opNextTxt = 1;
                        } else {
                            if ((p3_mouse.isPressedIn(thisStim) && (p3_isPicked[k] === 1))) {
                                p3_stimColors[k] = cGrey;
                                p3_isPicked[k] = 0;
                                p3_opTry2Txt = 0;
                                p3_opTryBox = 0;
                                p3_opTryTxt = 0;
                                p3_opNextBox = 1;
                                p3_opNextTxt = 1;
                            }
                        }
                        if (((((p3_isPicked[1] === 1) && (p3_isPicked[3] === 1)) && (p3_isPicked[2] === 0)) && (p3_isPicked[4] === 0))) {
                            p3_isCorrect = 1;
                            p3_opTry2Txt = 0;
                            p3_opTryBox = 0;
                            p3_opTryTxt = 0;
                            p3_opNextBox = 1;
                            p3_opNextTxt = 1;
                        } else {
                            p3_isCorrect = 0;
                        }
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p3_mouse
    // current position of the mouse:
    p3_mouse.x = [];
    p3_mouse.y = [];
    p3_mouse.leftButton = [];
    p3_mouse.midButton = [];
    p3_mouse.rightButton = [];
    p3_mouse.time = [];
    p3_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p3_mouse.mouseClock.reset();
    p3_sq_1.setFillColor(new util.Color(p3_stimColors[1]));
    p3_sq_2.setFillColor(new util.Color(p3_stimColors[2]));
    p3_sq_3.setFillColor(new util.Color(p3_stimColors[3]));
    p3_sq_4.setFillColor(new util.Color(p3_stimColors[4]));
    p3_txt_1.setText(p3_words[1]);
    p3_txt_2.setText(p3_words[2]);
    p3_txt_3.setText(p3_words[3]);
    p3_txt_4.setText(p3_words[4]);
    p3_box_try.setFillColor(new util.Color(BoxTryColor));
    p3_box_try.setOpacity(p3_opTryBox);
    p3_box_try.setLineColor(new util.Color(cGrey));
    p3_txt_try.setOpacity(p3_opTryTxt);
    p3_txt_try2.setOpacity(p3_opTry2Txt);
    p3_box_next.setFillColor(new util.Color(BoxNextColor));
    p3_box_next.setOpacity(p3_opNextBox);
    p3_box_next.setLineColor(new util.Color(cGrey));
    p3_txt_next.setOpacity(p3_opNextTxt);
    psychoJS.experiment.addData('p3_Att_Fruits.started', globalClock.getTime());
    p3_Att_FruitsMaxDuration = null
    // keep track of which components have finished
    p3_Att_FruitsComponents = [];
    p3_Att_FruitsComponents.push(p3_mouse);
    p3_Att_FruitsComponents.push(p3_txt_q);
    p3_Att_FruitsComponents.push(p3_sq_1);
    p3_Att_FruitsComponents.push(p3_sq_2);
    p3_Att_FruitsComponents.push(p3_sq_3);
    p3_Att_FruitsComponents.push(p3_sq_4);
    p3_Att_FruitsComponents.push(p3_txt_1);
    p3_Att_FruitsComponents.push(p3_txt_2);
    p3_Att_FruitsComponents.push(p3_txt_3);
    p3_Att_FruitsComponents.push(p3_txt_4);
    p3_Att_FruitsComponents.push(p3_box_try);
    p3_Att_FruitsComponents.push(p3_txt_try);
    p3_Att_FruitsComponents.push(p3_txt_try2);
    p3_Att_FruitsComponents.push(p3_box_next);
    p3_Att_FruitsComponents.push(p3_txt_next);
    
    p3_Att_FruitsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p3_Att_FruitsRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p3_Att_Fruits' ---
    // get current time
    t = p3_Att_FruitsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // *p3_mouse* updates
    if (t >= 0 && p3_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_mouse.tStart = t;  // (not accounting for frame time here)
      p3_mouse.frameNStart = frameN;  // exact frame index
      
      p3_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p3_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p3_mouse is active this frame...
    if (p3_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p3_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p3_mouse.clickableObjects = eval([p3_sq_1, p3_sq_2, p3_sq_3, p3_sq_4, p3_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p3_mouse.clickableObjects)) {
              p3_mouse.clickableObjects = [p3_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p3_mouse.clickableObjects) {
              if (obj.contains(p3_mouse)) {
                  gotValidClick = true;
                  p3_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p3_mouse.clickableObjects = eval([p3_sq_1, p3_sq_2, p3_sq_3, p3_sq_4, p3_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p3_mouse.clickableObjects)) {
              p3_mouse.clickableObjects = [p3_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p3_mouse.clickableObjects) {
              if (obj.contains(p3_mouse)) {
                  gotValidClick = true;
                  p3_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p3_mouse.getPos();
            p3_mouse.x.push(_mouseXYs[0]);
            p3_mouse.y.push(_mouseXYs[1]);
            p3_mouse.leftButton.push(_mouseButtons[0]);
            p3_mouse.midButton.push(_mouseButtons[1]);
            p3_mouse.rightButton.push(_mouseButtons[2]);
            p3_mouse.time.push(p3_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p3_txt_q* updates
    if (t >= 0.0 && p3_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_q.tStart = t;  // (not accounting for frame time here)
      p3_txt_q.frameNStart = frameN;  // exact frame index
      
      p3_txt_q.setAutoDraw(true);
    }
    
    
    // if p3_txt_q is active this frame...
    if (p3_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_sq_1* updates
    if (t >= 0.0 && p3_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_sq_1.tStart = t;  // (not accounting for frame time here)
      p3_sq_1.frameNStart = frameN;  // exact frame index
      
      p3_sq_1.setAutoDraw(true);
    }
    
    
    // if p3_sq_1 is active this frame...
    if (p3_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_sq_2* updates
    if (t >= 0.0 && p3_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_sq_2.tStart = t;  // (not accounting for frame time here)
      p3_sq_2.frameNStart = frameN;  // exact frame index
      
      p3_sq_2.setAutoDraw(true);
    }
    
    
    // if p3_sq_2 is active this frame...
    if (p3_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_sq_3* updates
    if (t >= 0.0 && p3_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_sq_3.tStart = t;  // (not accounting for frame time here)
      p3_sq_3.frameNStart = frameN;  // exact frame index
      
      p3_sq_3.setAutoDraw(true);
    }
    
    
    // if p3_sq_3 is active this frame...
    if (p3_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_sq_4* updates
    if (t >= 0.0 && p3_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_sq_4.tStart = t;  // (not accounting for frame time here)
      p3_sq_4.frameNStart = frameN;  // exact frame index
      
      p3_sq_4.setAutoDraw(true);
    }
    
    
    // if p3_sq_4 is active this frame...
    if (p3_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_1* updates
    if (t >= 0.0 && p3_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_1.tStart = t;  // (not accounting for frame time here)
      p3_txt_1.frameNStart = frameN;  // exact frame index
      
      p3_txt_1.setAutoDraw(true);
    }
    
    
    // if p3_txt_1 is active this frame...
    if (p3_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_2* updates
    if (t >= 0.0 && p3_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_2.tStart = t;  // (not accounting for frame time here)
      p3_txt_2.frameNStart = frameN;  // exact frame index
      
      p3_txt_2.setAutoDraw(true);
    }
    
    
    // if p3_txt_2 is active this frame...
    if (p3_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_3* updates
    if (t >= 0.0 && p3_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_3.tStart = t;  // (not accounting for frame time here)
      p3_txt_3.frameNStart = frameN;  // exact frame index
      
      p3_txt_3.setAutoDraw(true);
    }
    
    
    // if p3_txt_3 is active this frame...
    if (p3_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_4* updates
    if (t >= 0.0 && p3_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_4.tStart = t;  // (not accounting for frame time here)
      p3_txt_4.frameNStart = frameN;  // exact frame index
      
      p3_txt_4.setAutoDraw(true);
    }
    
    
    // if p3_txt_4 is active this frame...
    if (p3_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_box_try* updates
    if (t >= 0 && p3_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_box_try.tStart = t;  // (not accounting for frame time here)
      p3_box_try.frameNStart = frameN;  // exact frame index
      
      p3_box_try.setAutoDraw(true);
    }
    
    
    // if p3_box_try is active this frame...
    if (p3_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_try* updates
    if (t >= 0 && p3_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_try.tStart = t;  // (not accounting for frame time here)
      p3_txt_try.frameNStart = frameN;  // exact frame index
      
      p3_txt_try.setAutoDraw(true);
    }
    
    
    // if p3_txt_try is active this frame...
    if (p3_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_try2* updates
    if (t >= 0 && p3_txt_try2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_try2.tStart = t;  // (not accounting for frame time here)
      p3_txt_try2.frameNStart = frameN;  // exact frame index
      
      p3_txt_try2.setAutoDraw(true);
    }
    
    
    // if p3_txt_try2 is active this frame...
    if (p3_txt_try2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_box_next* updates
    if (t >= 0 && p3_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_box_next.tStart = t;  // (not accounting for frame time here)
      p3_box_next.frameNStart = frameN;  // exact frame index
      
      p3_box_next.setAutoDraw(true);
    }
    
    
    // if p3_box_next is active this frame...
    if (p3_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p3_txt_next* updates
    if (t >= 0 && p3_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p3_txt_next.tStart = t;  // (not accounting for frame time here)
      p3_txt_next.frameNStart = frameN;  // exact frame index
      
      p3_txt_next.setAutoDraw(true);
    }
    
    
    // if p3_txt_next is active this frame...
    if (p3_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p3_Att_FruitsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p3_Att_FruitsRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p3_Att_Fruits' ---
    p3_Att_FruitsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p3_Att_Fruits.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p3_mouse.x', p3_mouse.x);
    psychoJS.experiment.addData('p3_mouse.y', p3_mouse.y);
    psychoJS.experiment.addData('p3_mouse.leftButton', p3_mouse.leftButton);
    psychoJS.experiment.addData('p3_mouse.midButton', p3_mouse.midButton);
    psychoJS.experiment.addData('p3_mouse.rightButton', p3_mouse.rightButton);
    psychoJS.experiment.addData('p3_mouse.time', p3_mouse.time);
    psychoJS.experiment.addData('p3_mouse.clicked_name', p3_mouse.clicked_name);
    
    // Run 'End Routine' code from p3_code_ans
    psychoJS.experiment.addData('p3_isCorrect',p3_isCorrect)
    psychoJS.experiment.addData('p3_ans', p3_ans)
    psychoJS.experiment.addData('p3_ans_Idx', p3_ans_Idx)
    psychoJS.experiment.addData('p3_corrAns',p3_corrAns)
    psychoJS.experiment.addData('p3_corrAns_Idx',p3_corrAns_Idx)
    psychoJS.experiment.addData('p3_countNext',p3_countNext)
    psychoJS.experiment.addData('p3_points',p3_points)
    // the Routine "p3_Att_Fruits" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p3_inTimeMaxDurationReached;
var p3_inTimeMaxDuration;
var p3_inTimeComponents;
function p3_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p3_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p3_inTimeClock.reset();
    routineTimer.reset();
    p3_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p3_inTime.started', globalClock.getTime());
    p3_inTimeMaxDuration = null
    // keep track of which components have finished
    p3_inTimeComponents = [];
    
    p3_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p3_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p3_inTime' ---
    // get current time
    t = p3_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p3_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p3_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p3_inTime' ---
    p3_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p3_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p3_code_inTime
    psychoJS.experiment.addData("p3_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p3_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p4aMaxDurationReached;
var p4aMaxDuration;
var p4aComponents;
function p4aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p4a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p4aClock.reset();
    routineTimer.reset();
    p4aMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p4a_mouse
    // current position of the mouse:
    p4a_mouse.x = [];
    p4a_mouse.y = [];
    p4a_mouse.leftButton = [];
    p4a_mouse.midButton = [];
    p4a_mouse.rightButton = [];
    p4a_mouse.time = [];
    p4a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p4a_mouse.mouseClock.reset();
    p4a_box_next.setFillColor(new util.Color(BoxNextColor));
    p4a_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p4a.started', globalClock.getTime());
    p4aMaxDuration = null
    // keep track of which components have finished
    p4aComponents = [];
    p4aComponents.push(p4a_instr);
    p4aComponents.push(p4a_mouse);
    p4aComponents.push(p4a_box_next);
    p4aComponents.push(p4a_txt_next);
    
    p4aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p4aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p4a' ---
    // get current time
    t = p4aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p4a_instr* updates
    if (t >= 0.0 && p4a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4a_instr.tStart = t;  // (not accounting for frame time here)
      p4a_instr.frameNStart = frameN;  // exact frame index
      
      p4a_instr.setAutoDraw(true);
    }
    
    
    // if p4a_instr is active this frame...
    if (p4a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p4a_mouse* updates
    if (t >= 0.0 && p4a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4a_mouse.tStart = t;  // (not accounting for frame time here)
      p4a_mouse.frameNStart = frameN;  // exact frame index
      
      p4a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p4a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p4a_mouse is active this frame...
    if (p4a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p4a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p4a_mouse.clickableObjects = eval(p4a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p4a_mouse.clickableObjects)) {
              p4a_mouse.clickableObjects = [p4a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p4a_mouse.clickableObjects) {
              if (obj.contains(p4a_mouse)) {
                  gotValidClick = true;
                  p4a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p4a_mouse.clickableObjects = eval(p4a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p4a_mouse.clickableObjects)) {
              p4a_mouse.clickableObjects = [p4a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p4a_mouse.clickableObjects) {
              if (obj.contains(p4a_mouse)) {
                  gotValidClick = true;
                  p4a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p4a_mouse.getPos();
            p4a_mouse.x.push(_mouseXYs[0]);
            p4a_mouse.y.push(_mouseXYs[1]);
            p4a_mouse.leftButton.push(_mouseButtons[0]);
            p4a_mouse.midButton.push(_mouseButtons[1]);
            p4a_mouse.rightButton.push(_mouseButtons[2]);
            p4a_mouse.time.push(p4a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p4a_box_next* updates
    if (t >= 0.0 && p4a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4a_box_next.tStart = t;  // (not accounting for frame time here)
      p4a_box_next.frameNStart = frameN;  // exact frame index
      
      p4a_box_next.setAutoDraw(true);
    }
    
    
    // if p4a_box_next is active this frame...
    if (p4a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4a_txt_next* updates
    if (t >= 0.0 && p4a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4a_txt_next.tStart = t;  // (not accounting for frame time here)
      p4a_txt_next.frameNStart = frameN;  // exact frame index
      
      p4a_txt_next.setAutoDraw(true);
    }
    
    
    // if p4a_txt_next is active this frame...
    if (p4a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p4aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p4aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p4a' ---
    p4aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p4a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p4a_mouse.x', p4a_mouse.x);
    psychoJS.experiment.addData('p4a_mouse.y', p4a_mouse.y);
    psychoJS.experiment.addData('p4a_mouse.leftButton', p4a_mouse.leftButton);
    psychoJS.experiment.addData('p4a_mouse.midButton', p4a_mouse.midButton);
    psychoJS.experiment.addData('p4a_mouse.rightButton', p4a_mouse.rightButton);
    psychoJS.experiment.addData('p4a_mouse.time', p4a_mouse.time);
    psychoJS.experiment.addData('p4a_mouse.clicked_name', p4a_mouse.clicked_name);
    
    // the Routine "p4a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p4_Att_NumpadMaxDurationReached;
var p4_keyID;
var p4_Att_NumpadMaxDuration;
var p4_Att_NumpadComponents;
function p4_Att_NumpadRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p4_Att_Numpad' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p4_Att_NumpadClock.reset();
    routineTimer.reset();
    p4_Att_NumpadMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p4_code
    p4_keyID = [p4_key_1, p4_key_2, p4_key_3, p4_key_4, p4_key_5, p4_key_6, p4_key_7, p4_key_8, p4_key_9, p4_key_0, p4_key_DEL];
    k = 0;
    if (((p4_mouse.isPressedIn(p4_box_next) && (lenString_p4 === 4)) && (p4_isCorrect === 1))) {
        p4_countNext = (p4_countNext + 1);
        if ((p4_countNext === 1)) {
            p4_isCorrect = 1;
            p4_points = 2;
        } else {
            p4_isCorrect = 0;
            p4_points = 0;
        }
        loop_waitTillOK_p4.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if (((p4_mouse.isPressedIn(p4_box_next) && (lenString_p4 === 4)) && (p4_isCorrect === 0))) {
            p4_countNext = (p4_countNext + 1);
            p4_opTryBox = 1;
            p4_opTryTxt = 1;
            p4_opNextBox = 0;
            p4_opNextTxt = 0;
        } else {
            if (((p4_mouse.isPressedIn(p4_box_next) && (lenString_p4 < 4)) && (p4_isCorrect === 0))) {
                p4_countNext = (p4_countNext + 1);
                p4_opTryBox = 1;
                p4_opTryTxt = 1;
                p4_opNextBox = 0;
                p4_opNextTxt = 0;
            } else {
                for (var thisKey, _pj_c = 0, _pj_a = p4_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisKey = _pj_a[_pj_c];
                    k = (k + 1);
                    if (p4_mouse.isPressedIn(thisKey)) {
                        if ((lenString_p4 < 4)) {
                            p4_ans = (p4_ans + p4_keyNum[k]);
                            lenString_p4 = (lenString_p4 + 1);
                            p4_screen_txt.text = p4_ans;
                            p4_opTryBox = 0;
                            p4_opTryTxt = 0;
                            p4_opNextBox = 1;
                            p4_opNextTxt = 1;
                            if ((p4_ans === p4_corrAns)) {
                                p4_isCorrect = 1;
                            } else {
                                p4_isCorrect = 0;
                            }
                        }
                        if ((p4_keyNum[k] === "DEL")) {
                            p4_ans = "";
                            lenString_p4 = 0;
                            p4_screen_txt.text = p4_ans;
                            p4_isCorrect = 0;
                            p4_opTryBox = 0;
                            p4_opTryTxt = 0;
                            p4_opNextBox = 1;
                            p4_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p4_mouse
    // current position of the mouse:
    p4_mouse.x = [];
    p4_mouse.y = [];
    p4_mouse.leftButton = [];
    p4_mouse.midButton = [];
    p4_mouse.rightButton = [];
    p4_mouse.time = [];
    p4_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p4_mouse.mouseClock.reset();
    p4_screen_txt.setText(p4_ans);
    p4_box_next.setFillColor(new util.Color(BoxNextColor));
    p4_box_next.setOpacity(p4_opNextBox);
    p4_box_next.setLineColor(new util.Color(cGrey));
    p4_txt_next.setOpacity(p4_opNextTxt);
    p4_box_try.setFillColor(new util.Color(BoxTryColor));
    p4_box_try.setOpacity(p4_opTryBox);
    p4_box_try.setLineColor(new util.Color(cGrey));
    p4_txt_try.setOpacity(p4_opTryTxt);
    psychoJS.experiment.addData('p4_Att_Numpad.started', globalClock.getTime());
    p4_Att_NumpadMaxDuration = null
    // keep track of which components have finished
    p4_Att_NumpadComponents = [];
    p4_Att_NumpadComponents.push(p4_txt_q1);
    p4_Att_NumpadComponents.push(p4_txt_q2);
    p4_Att_NumpadComponents.push(p4_mouse);
    p4_Att_NumpadComponents.push(p4_screen_box);
    p4_Att_NumpadComponents.push(p4_screen_txt);
    p4_Att_NumpadComponents.push(p4_key_1);
    p4_Att_NumpadComponents.push(p4_key_2);
    p4_Att_NumpadComponents.push(p4_key_3);
    p4_Att_NumpadComponents.push(p4_key_4);
    p4_Att_NumpadComponents.push(p4_key_5);
    p4_Att_NumpadComponents.push(p4_key_6);
    p4_Att_NumpadComponents.push(p4_key_7);
    p4_Att_NumpadComponents.push(p4_key_8);
    p4_Att_NumpadComponents.push(p4_key_9);
    p4_Att_NumpadComponents.push(p4_key_0);
    p4_Att_NumpadComponents.push(p4_key_DEL);
    p4_Att_NumpadComponents.push(p4_box_next);
    p4_Att_NumpadComponents.push(p4_txt_next);
    p4_Att_NumpadComponents.push(p4_box_try);
    p4_Att_NumpadComponents.push(p4_txt_try);
    p4_Att_NumpadComponents.push(p4_key_txt_1);
    p4_Att_NumpadComponents.push(p4_key_txt_2);
    p4_Att_NumpadComponents.push(p4_key_txt_3);
    p4_Att_NumpadComponents.push(p4_key_txt_4);
    p4_Att_NumpadComponents.push(p4_key_txt_5);
    p4_Att_NumpadComponents.push(p4_key_txt_6);
    p4_Att_NumpadComponents.push(p4_key_txt_7);
    p4_Att_NumpadComponents.push(p4_key_txt_8);
    p4_Att_NumpadComponents.push(p4_key_txt_9);
    p4_Att_NumpadComponents.push(p4_key_txt_0);
    p4_Att_NumpadComponents.push(p4_key_txt_DEL);
    
    p4_Att_NumpadComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p4_Att_NumpadRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p4_Att_Numpad' ---
    // get current time
    t = p4_Att_NumpadClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p4_txt_q1* updates
    if (t >= 0.0 && p4_txt_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_txt_q1.tStart = t;  // (not accounting for frame time here)
      p4_txt_q1.frameNStart = frameN;  // exact frame index
      
      p4_txt_q1.setAutoDraw(true);
    }
    
    
    // if p4_txt_q1 is active this frame...
    if (p4_txt_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_txt_q2* updates
    if (t >= 0.0 && p4_txt_q2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_txt_q2.tStart = t;  // (not accounting for frame time here)
      p4_txt_q2.frameNStart = frameN;  // exact frame index
      
      p4_txt_q2.setAutoDraw(true);
    }
    
    
    // if p4_txt_q2 is active this frame...
    if (p4_txt_q2.status === PsychoJS.Status.STARTED) {
    }
    
    // *p4_mouse* updates
    if (t >= 0.0 && p4_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_mouse.tStart = t;  // (not accounting for frame time here)
      p4_mouse.frameNStart = frameN;  // exact frame index
      
      p4_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p4_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p4_mouse is active this frame...
    if (p4_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p4_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p4_mouse.clickableObjects = eval([p4_key_1, p4_key_2, p4_key_3, p4_key_4, p4_key_5, p4_key_6, p4_key_7, p4_key_8, p4_key_9, p4_key_0, p4_key_DEL, p4_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p4_mouse.clickableObjects)) {
              p4_mouse.clickableObjects = [p4_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p4_mouse.clickableObjects) {
              if (obj.contains(p4_mouse)) {
                  gotValidClick = true;
                  p4_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p4_mouse.clickableObjects = eval([p4_key_1, p4_key_2, p4_key_3, p4_key_4, p4_key_5, p4_key_6, p4_key_7, p4_key_8, p4_key_9, p4_key_0, p4_key_DEL, p4_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p4_mouse.clickableObjects)) {
              p4_mouse.clickableObjects = [p4_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p4_mouse.clickableObjects) {
              if (obj.contains(p4_mouse)) {
                  gotValidClick = true;
                  p4_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p4_mouse.getPos();
            p4_mouse.x.push(_mouseXYs[0]);
            p4_mouse.y.push(_mouseXYs[1]);
            p4_mouse.leftButton.push(_mouseButtons[0]);
            p4_mouse.midButton.push(_mouseButtons[1]);
            p4_mouse.rightButton.push(_mouseButtons[2]);
            p4_mouse.time.push(p4_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p4_screen_box* updates
    if (t >= 0.0 && p4_screen_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_screen_box.tStart = t;  // (not accounting for frame time here)
      p4_screen_box.frameNStart = frameN;  // exact frame index
      
      p4_screen_box.setAutoDraw(true);
    }
    
    
    // if p4_screen_box is active this frame...
    if (p4_screen_box.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_screen_txt* updates
    if (t >= 0.0 && p4_screen_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_screen_txt.tStart = t;  // (not accounting for frame time here)
      p4_screen_txt.frameNStart = frameN;  // exact frame index
      
      p4_screen_txt.setAutoDraw(true);
    }
    
    
    // if p4_screen_txt is active this frame...
    if (p4_screen_txt.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_1* updates
    if (t >= 0.0 && p4_key_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_1.tStart = t;  // (not accounting for frame time here)
      p4_key_1.frameNStart = frameN;  // exact frame index
      
      p4_key_1.setAutoDraw(true);
    }
    
    
    // if p4_key_1 is active this frame...
    if (p4_key_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_2* updates
    if (t >= 0.0 && p4_key_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_2.tStart = t;  // (not accounting for frame time here)
      p4_key_2.frameNStart = frameN;  // exact frame index
      
      p4_key_2.setAutoDraw(true);
    }
    
    
    // if p4_key_2 is active this frame...
    if (p4_key_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_3* updates
    if (t >= 0.0 && p4_key_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_3.tStart = t;  // (not accounting for frame time here)
      p4_key_3.frameNStart = frameN;  // exact frame index
      
      p4_key_3.setAutoDraw(true);
    }
    
    
    // if p4_key_3 is active this frame...
    if (p4_key_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_4* updates
    if (t >= 0.0 && p4_key_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_4.tStart = t;  // (not accounting for frame time here)
      p4_key_4.frameNStart = frameN;  // exact frame index
      
      p4_key_4.setAutoDraw(true);
    }
    
    
    // if p4_key_4 is active this frame...
    if (p4_key_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_5* updates
    if (t >= 0.0 && p4_key_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_5.tStart = t;  // (not accounting for frame time here)
      p4_key_5.frameNStart = frameN;  // exact frame index
      
      p4_key_5.setAutoDraw(true);
    }
    
    
    // if p4_key_5 is active this frame...
    if (p4_key_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_6* updates
    if (t >= 0.0 && p4_key_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_6.tStart = t;  // (not accounting for frame time here)
      p4_key_6.frameNStart = frameN;  // exact frame index
      
      p4_key_6.setAutoDraw(true);
    }
    
    
    // if p4_key_6 is active this frame...
    if (p4_key_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_7* updates
    if (t >= 0.0 && p4_key_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_7.tStart = t;  // (not accounting for frame time here)
      p4_key_7.frameNStart = frameN;  // exact frame index
      
      p4_key_7.setAutoDraw(true);
    }
    
    
    // if p4_key_7 is active this frame...
    if (p4_key_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_8* updates
    if (t >= 0.0 && p4_key_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_8.tStart = t;  // (not accounting for frame time here)
      p4_key_8.frameNStart = frameN;  // exact frame index
      
      p4_key_8.setAutoDraw(true);
    }
    
    
    // if p4_key_8 is active this frame...
    if (p4_key_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_9* updates
    if (t >= 0.0 && p4_key_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_9.tStart = t;  // (not accounting for frame time here)
      p4_key_9.frameNStart = frameN;  // exact frame index
      
      p4_key_9.setAutoDraw(true);
    }
    
    
    // if p4_key_9 is active this frame...
    if (p4_key_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_0* updates
    if (t >= 0.0 && p4_key_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_0.tStart = t;  // (not accounting for frame time here)
      p4_key_0.frameNStart = frameN;  // exact frame index
      
      p4_key_0.setAutoDraw(true);
    }
    
    
    // if p4_key_0 is active this frame...
    if (p4_key_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_DEL* updates
    if (t >= 0.0 && p4_key_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_DEL.tStart = t;  // (not accounting for frame time here)
      p4_key_DEL.frameNStart = frameN;  // exact frame index
      
      p4_key_DEL.setAutoDraw(true);
    }
    
    
    // if p4_key_DEL is active this frame...
    if (p4_key_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_box_next* updates
    if (t >= 0.0 && p4_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_box_next.tStart = t;  // (not accounting for frame time here)
      p4_box_next.frameNStart = frameN;  // exact frame index
      
      p4_box_next.setAutoDraw(true);
    }
    
    
    // if p4_box_next is active this frame...
    if (p4_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_txt_next* updates
    if (t >= 0.0 && p4_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_txt_next.tStart = t;  // (not accounting for frame time here)
      p4_txt_next.frameNStart = frameN;  // exact frame index
      
      p4_txt_next.setAutoDraw(true);
    }
    
    
    // if p4_txt_next is active this frame...
    if (p4_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_box_try* updates
    if (t >= 0.0 && p4_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_box_try.tStart = t;  // (not accounting for frame time here)
      p4_box_try.frameNStart = frameN;  // exact frame index
      
      p4_box_try.setAutoDraw(true);
    }
    
    
    // if p4_box_try is active this frame...
    if (p4_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_txt_try* updates
    if (t >= 0.0 && p4_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_txt_try.tStart = t;  // (not accounting for frame time here)
      p4_txt_try.frameNStart = frameN;  // exact frame index
      
      p4_txt_try.setAutoDraw(true);
    }
    
    
    // if p4_txt_try is active this frame...
    if (p4_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_1* updates
    if (t >= 0.0 && p4_key_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_1.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_1.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_1.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_1 is active this frame...
    if (p4_key_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_2* updates
    if (t >= 0.0 && p4_key_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_2.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_2.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_2.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_2 is active this frame...
    if (p4_key_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_3* updates
    if (t >= 0.0 && p4_key_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_3.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_3.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_3.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_3 is active this frame...
    if (p4_key_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_4* updates
    if (t >= 0.0 && p4_key_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_4.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_4.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_4.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_4 is active this frame...
    if (p4_key_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_5* updates
    if (t >= 0.0 && p4_key_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_5.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_5.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_5.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_5 is active this frame...
    if (p4_key_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_6* updates
    if (t >= 0.0 && p4_key_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_6.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_6.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_6.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_6 is active this frame...
    if (p4_key_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_7* updates
    if (t >= 0.0 && p4_key_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_7.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_7.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_7.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_7 is active this frame...
    if (p4_key_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_8* updates
    if (t >= 0.0 && p4_key_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_8.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_8.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_8.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_8 is active this frame...
    if (p4_key_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_9* updates
    if (t >= 0.0 && p4_key_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_9.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_9.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_9.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_9 is active this frame...
    if (p4_key_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_0* updates
    if (t >= 0.0 && p4_key_txt_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_0.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_0.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_0.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_0 is active this frame...
    if (p4_key_txt_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p4_key_txt_DEL* updates
    if (t >= 0.0 && p4_key_txt_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p4_key_txt_DEL.tStart = t;  // (not accounting for frame time here)
      p4_key_txt_DEL.frameNStart = frameN;  // exact frame index
      
      p4_key_txt_DEL.setAutoDraw(true);
    }
    
    
    // if p4_key_txt_DEL is active this frame...
    if (p4_key_txt_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p4_Att_NumpadComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p4_Att_NumpadRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p4_Att_Numpad' ---
    p4_Att_NumpadComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p4_Att_Numpad.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p4_mouse.x', p4_mouse.x);
    psychoJS.experiment.addData('p4_mouse.y', p4_mouse.y);
    psychoJS.experiment.addData('p4_mouse.leftButton', p4_mouse.leftButton);
    psychoJS.experiment.addData('p4_mouse.midButton', p4_mouse.midButton);
    psychoJS.experiment.addData('p4_mouse.rightButton', p4_mouse.rightButton);
    psychoJS.experiment.addData('p4_mouse.time', p4_mouse.time);
    psychoJS.experiment.addData('p4_mouse.clicked_name', p4_mouse.clicked_name);
    
    // Run 'End Routine' code from p4_code_ans
    psychoJS.experiment.addData('p4_isCorrect',p4_isCorrect)
    psychoJS.experiment.addData('p4_ans', p4_ans)
    psychoJS.experiment.addData('p4_corrAns',p4_corrAns)
    psychoJS.experiment.addData('p4_countNext',p4_countNext)
    psychoJS.experiment.addData('p4_points',p4_points)
    // the Routine "p4_Att_Numpad" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p4_inTimeMaxDurationReached;
var p4_inTimeMaxDuration;
var p4_inTimeComponents;
function p4_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p4_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p4_inTimeClock.reset();
    routineTimer.reset();
    p4_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p4_inTime.started', globalClock.getTime());
    p4_inTimeMaxDuration = null
    // keep track of which components have finished
    p4_inTimeComponents = [];
    
    p4_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p4_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p4_inTime' ---
    // get current time
    t = p4_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p4_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p4_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p4_inTime' ---
    p4_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p4_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p4_code_inTime
    psychoJS.experiment.addData("p4_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p4_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p5aMaxDurationReached;
var p5aMaxDuration;
var p5aComponents;
function p5aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p5a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p5aClock.reset();
    routineTimer.reset();
    p5aMaxDurationReached = false;
    // update component parameters for each repeat
    p5a_instr.setImage(instrPath);
    // setup some python lists for storing info about the p5a_mouse
    // current position of the mouse:
    p5a_mouse.x = [];
    p5a_mouse.y = [];
    p5a_mouse.leftButton = [];
    p5a_mouse.midButton = [];
    p5a_mouse.rightButton = [];
    p5a_mouse.time = [];
    p5a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p5a_mouse.mouseClock.reset();
    p5a_box_next.setFillColor(new util.Color(BoxNextColor));
    p5a_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p5a.started', globalClock.getTime());
    p5aMaxDuration = null
    // keep track of which components have finished
    p5aComponents = [];
    p5aComponents.push(p5a_instr);
    p5aComponents.push(p5a_mouse);
    p5aComponents.push(p5a_box_next);
    p5aComponents.push(p5a_txt_next);
    
    p5aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p5aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p5a' ---
    // get current time
    t = p5aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p5a_instr* updates
    if (t >= 0.0 && p5a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p5a_instr.tStart = t;  // (not accounting for frame time here)
      p5a_instr.frameNStart = frameN;  // exact frame index
      
      p5a_instr.setAutoDraw(true);
    }
    
    
    // if p5a_instr is active this frame...
    if (p5a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p5a_mouse* updates
    if (t >= 0.0 && p5a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p5a_mouse.tStart = t;  // (not accounting for frame time here)
      p5a_mouse.frameNStart = frameN;  // exact frame index
      
      p5a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p5a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p5a_mouse is active this frame...
    if (p5a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p5a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p5a_mouse.clickableObjects = eval(p5a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p5a_mouse.clickableObjects)) {
              p5a_mouse.clickableObjects = [p5a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p5a_mouse.clickableObjects) {
              if (obj.contains(p5a_mouse)) {
                  gotValidClick = true;
                  p5a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p5a_mouse.clickableObjects = eval(p5a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p5a_mouse.clickableObjects)) {
              p5a_mouse.clickableObjects = [p5a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p5a_mouse.clickableObjects) {
              if (obj.contains(p5a_mouse)) {
                  gotValidClick = true;
                  p5a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p5a_mouse.getPos();
            p5a_mouse.x.push(_mouseXYs[0]);
            p5a_mouse.y.push(_mouseXYs[1]);
            p5a_mouse.leftButton.push(_mouseButtons[0]);
            p5a_mouse.midButton.push(_mouseButtons[1]);
            p5a_mouse.rightButton.push(_mouseButtons[2]);
            p5a_mouse.time.push(p5a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p5a_box_next* updates
    if (t >= 0.0 && p5a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p5a_box_next.tStart = t;  // (not accounting for frame time here)
      p5a_box_next.frameNStart = frameN;  // exact frame index
      
      p5a_box_next.setAutoDraw(true);
    }
    
    
    // if p5a_box_next is active this frame...
    if (p5a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p5a_txt_next* updates
    if (t >= 0.0 && p5a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p5a_txt_next.tStart = t;  // (not accounting for frame time here)
      p5a_txt_next.frameNStart = frameN;  // exact frame index
      
      p5a_txt_next.setAutoDraw(true);
    }
    
    
    // if p5a_txt_next is active this frame...
    if (p5a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p5aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p5aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p5a' ---
    p5aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p5a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p5a_mouse.x', p5a_mouse.x);
    psychoJS.experiment.addData('p5a_mouse.y', p5a_mouse.y);
    psychoJS.experiment.addData('p5a_mouse.leftButton', p5a_mouse.leftButton);
    psychoJS.experiment.addData('p5a_mouse.midButton', p5a_mouse.midButton);
    psychoJS.experiment.addData('p5a_mouse.rightButton', p5a_mouse.rightButton);
    psychoJS.experiment.addData('p5a_mouse.time', p5a_mouse.time);
    psychoJS.experiment.addData('p5a_mouse.clicked_name', p5a_mouse.clicked_name);
    
    // the Routine "p5a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p5_Mem_wordListMaxDurationReached;
var p5_Mem_wordListMaxDuration;
var p5_Mem_wordListComponents;
function p5_Mem_wordListRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p5_Mem_wordList' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p5_Mem_wordListClock.reset(routineTimer.getTime());
    routineTimer.add(3.000000);
    p5_Mem_wordListMaxDurationReached = false;
    // update component parameters for each repeat
    p5_txt.setText(p5_word);
    psychoJS.experiment.addData('p5_Mem_wordList.started', globalClock.getTime());
    p5_Mem_wordListMaxDuration = null
    // keep track of which components have finished
    p5_Mem_wordListComponents = [];
    p5_Mem_wordListComponents.push(p5_txt);
    
    p5_Mem_wordListComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p5_Mem_wordListRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p5_Mem_wordList' ---
    // get current time
    t = p5_Mem_wordListClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p5_txt* updates
    if (t >= 1 && p5_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p5_txt.tStart = t;  // (not accounting for frame time here)
      p5_txt.frameNStart = frameN;  // exact frame index
      
      p5_txt.setAutoDraw(true);
    }
    
    
    // if p5_txt is active this frame...
    if (p5_txt.status === PsychoJS.Status.STARTED) {
    }
    
    frameRemains = 1 + 2 - psychoJS.window.monitorFramePeriod * 0.75;// most of one frame period left
    if (p5_txt.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      // keep track of stop time/frame for later
      p5_txt.tStop = t;  // not accounting for scr refresh
      p5_txt.frameNStop = frameN;  // exact frame index
      // update status
      p5_txt.status = PsychoJS.Status.FINISHED;
      p5_txt.setAutoDraw(false);
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p5_Mem_wordListComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p5_Mem_wordListRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p5_Mem_wordList' ---
    p5_Mem_wordListComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p5_Mem_wordList.stopped', globalClock.getTime());
    if (routineForceEnded) {
        routineTimer.reset();} else if (p5_Mem_wordListMaxDurationReached) {
        p5_Mem_wordListClock.add(p5_Mem_wordListMaxDuration);
    } else {
        p5_Mem_wordListClock.add(3.000000);
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p5_inTimeMaxDurationReached;
var p5_inTimeMaxDuration;
var p5_inTimeComponents;
function p5_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p5_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p5_inTimeClock.reset();
    routineTimer.reset();
    p5_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p5_inTime.started', globalClock.getTime());
    p5_inTimeMaxDuration = null
    // keep track of which components have finished
    p5_inTimeComponents = [];
    
    p5_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p5_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p5_inTime' ---
    // get current time
    t = p5_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p5_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p5_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p5_inTime' ---
    p5_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p5_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p5_code_inTime
    psychoJS.experiment.addData("p5_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p5_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p6aMaxDurationReached;
var p6aMaxDuration;
var p6aComponents;
function p6aRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p6a' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p6aClock.reset();
    routineTimer.reset();
    p6aMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p6a_mouse
    // current position of the mouse:
    p6a_mouse.x = [];
    p6a_mouse.y = [];
    p6a_mouse.leftButton = [];
    p6a_mouse.midButton = [];
    p6a_mouse.rightButton = [];
    p6a_mouse.time = [];
    p6a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p6a_mouse.mouseClock.reset();
    p6a_box_next.setFillColor(new util.Color(BoxNextColor));
    p6a_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p6a.started', globalClock.getTime());
    p6aMaxDuration = null
    // keep track of which components have finished
    p6aComponents = [];
    p6aComponents.push(p6a_instr);
    p6aComponents.push(p6a_mouse);
    p6aComponents.push(p6a_box_next);
    p6aComponents.push(p6a_txt_next);
    
    p6aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p6aRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p6a' ---
    // get current time
    t = p6aClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p6a_instr* updates
    if (t >= 0.0 && p6a_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6a_instr.tStart = t;  // (not accounting for frame time here)
      p6a_instr.frameNStart = frameN;  // exact frame index
      
      p6a_instr.setAutoDraw(true);
    }
    
    
    // if p6a_instr is active this frame...
    if (p6a_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p6a_mouse* updates
    if (t >= 0.0 && p6a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6a_mouse.tStart = t;  // (not accounting for frame time here)
      p6a_mouse.frameNStart = frameN;  // exact frame index
      
      p6a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p6a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p6a_mouse is active this frame...
    if (p6a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p6a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p6a_mouse.clickableObjects = eval(p6a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p6a_mouse.clickableObjects)) {
              p6a_mouse.clickableObjects = [p6a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p6a_mouse.clickableObjects) {
              if (obj.contains(p6a_mouse)) {
                  gotValidClick = true;
                  p6a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p6a_mouse.clickableObjects = eval(p6a_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p6a_mouse.clickableObjects)) {
              p6a_mouse.clickableObjects = [p6a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p6a_mouse.clickableObjects) {
              if (obj.contains(p6a_mouse)) {
                  gotValidClick = true;
                  p6a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p6a_mouse.getPos();
            p6a_mouse.x.push(_mouseXYs[0]);
            p6a_mouse.y.push(_mouseXYs[1]);
            p6a_mouse.leftButton.push(_mouseButtons[0]);
            p6a_mouse.midButton.push(_mouseButtons[1]);
            p6a_mouse.rightButton.push(_mouseButtons[2]);
            p6a_mouse.time.push(p6a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p6a_box_next* updates
    if (t >= 0.0 && p6a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6a_box_next.tStart = t;  // (not accounting for frame time here)
      p6a_box_next.frameNStart = frameN;  // exact frame index
      
      p6a_box_next.setAutoDraw(true);
    }
    
    
    // if p6a_box_next is active this frame...
    if (p6a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6a_txt_next* updates
    if (t >= 0.0 && p6a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6a_txt_next.tStart = t;  // (not accounting for frame time here)
      p6a_txt_next.frameNStart = frameN;  // exact frame index
      
      p6a_txt_next.setAutoDraw(true);
    }
    
    
    // if p6a_txt_next is active this frame...
    if (p6a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p6aComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p6aRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p6a' ---
    p6aComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p6a.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p6a_mouse.x', p6a_mouse.x);
    psychoJS.experiment.addData('p6a_mouse.y', p6a_mouse.y);
    psychoJS.experiment.addData('p6a_mouse.leftButton', p6a_mouse.leftButton);
    psychoJS.experiment.addData('p6a_mouse.midButton', p6a_mouse.midButton);
    psychoJS.experiment.addData('p6a_mouse.rightButton', p6a_mouse.rightButton);
    psychoJS.experiment.addData('p6a_mouse.time', p6a_mouse.time);
    psychoJS.experiment.addData('p6a_mouse.clicked_name', p6a_mouse.clicked_name);
    
    // the Routine "p6a" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p6_IM_shapeMaxDurationReached;
var p6_stimID;
var p6_IM_shapeMaxDuration;
var p6_IM_shapeComponents;
function p6_IM_shapeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p6_IM_shape' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p6_IM_shapeClock.reset();
    routineTimer.reset();
    p6_IM_shapeMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p6_code
    p6_stimID = [p6_sq_1, p6_sq_2, p6_sq_3, p6_sq_4, p6_sq_5, p6_sq_6];
    k = 0;
    i = 0;
    if ((p6_mouse.isPressedIn(p6_box_next) && (util.sum(p6_isPicked) === 1))) {
        p6_countNext = (p6_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p6_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p6_ans_Idx = (p6_ans_Idx + [i]);
                p6_ans = ((p6_ans + ",") + p6_words[i]);
                p6_countCorrect = (p6_countCorrect + (val * p6_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p6_countCorrect === util.sum(p6_corrAns_Vec))) {
            p6_isCorrect = 1;
            p6_points = 1;
        } else {
            p6_isCorrect = 0;
            p6_points = 0;
        }
        loop_waitTillOK_p6.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p6_mouse.isPressedIn(p6_box_next) && (util.sum(p6_isPicked) !== 1))) {
            p6_opTryBox = 1;
            p6_opTryTxt = 1;
            p6_opNextBox = 0;
            p6_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p6_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p6_mouse.isPressedIn(thisStim) && (p6_isPicked[k] === 0))) {
                    p6_stimColors[k] = cAzul;
                    p6_isPicked[k] = 1;
                    p6_opTryBox = 0;
                    p6_opTryTxt = 0;
                    p6_opNextBox = 1;
                    p6_opNextTxt = 1;
                } else {
                    p6_stimColors[k] = cGrey;
                    p6_isPicked[k] = 0;
                    p6_opTryBox = 0;
                    p6_opTryTxt = 0;
                    p6_opNextBox = 1;
                    p6_opNextTxt = 1;
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p6_mouse
    // current position of the mouse:
    p6_mouse.x = [];
    p6_mouse.y = [];
    p6_mouse.leftButton = [];
    p6_mouse.midButton = [];
    p6_mouse.rightButton = [];
    p6_mouse.time = [];
    p6_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p6_mouse.mouseClock.reset();
    p6_sq_1.setFillColor(new util.Color(p6_stimColors[1]));
    p6_sq_2.setFillColor(new util.Color(p6_stimColors[2]));
    p6_sq_3.setFillColor(new util.Color(p6_stimColors[3]));
    p6_sq_4.setFillColor(new util.Color(p6_stimColors[4]));
    p6_sq_5.setFillColor(new util.Color(p6_stimColors[5]));
    p6_sq_6.setFillColor(new util.Color(p6_stimColors[6]));
    p6_txt_1.setText(p6_words[1]);
    p6_txt_2.setText(p6_words[2]);
    p6_txt_3.setText(p6_words[3]);
    p6_txt_4.setText(p6_words[4]);
    p6_txt_5.setText(p6_words[5]);
    p6_txt_6.setText(p6_words[6]);
    p6_box_next.setFillColor(new util.Color(BoxNextColor));
    p6_box_next.setOpacity(p6_opNextBox);
    p6_box_next.setLineColor(new util.Color(cGrey));
    p6_box_try.setFillColor(new util.Color(BoxTryColor));
    p6_box_try.setOpacity(p6_opTryBox);
    p6_box_try.setLineColor(new util.Color(cGrey));
    p6_txt_next.setOpacity(p6_opNextTxt);
    p6_txt_try.setOpacity(p6_opTryTxt);
    psychoJS.experiment.addData('p6_IM_shape.started', globalClock.getTime());
    p6_IM_shapeMaxDuration = null
    // keep track of which components have finished
    p6_IM_shapeComponents = [];
    p6_IM_shapeComponents.push(p6_mouse);
    p6_IM_shapeComponents.push(p6_txt_q);
    p6_IM_shapeComponents.push(p6_sq_1);
    p6_IM_shapeComponents.push(p6_sq_2);
    p6_IM_shapeComponents.push(p6_sq_3);
    p6_IM_shapeComponents.push(p6_sq_4);
    p6_IM_shapeComponents.push(p6_sq_5);
    p6_IM_shapeComponents.push(p6_sq_6);
    p6_IM_shapeComponents.push(p6_txt_1);
    p6_IM_shapeComponents.push(p6_txt_2);
    p6_IM_shapeComponents.push(p6_txt_3);
    p6_IM_shapeComponents.push(p6_txt_4);
    p6_IM_shapeComponents.push(p6_txt_5);
    p6_IM_shapeComponents.push(p6_txt_6);
    p6_IM_shapeComponents.push(p6_box_next);
    p6_IM_shapeComponents.push(p6_box_try);
    p6_IM_shapeComponents.push(p6_txt_next);
    p6_IM_shapeComponents.push(p6_txt_try);
    
    p6_IM_shapeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p6_IM_shapeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p6_IM_shape' ---
    // get current time
    t = p6_IM_shapeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // *p6_mouse* updates
    if (t >= 0 && p6_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_mouse.tStart = t;  // (not accounting for frame time here)
      p6_mouse.frameNStart = frameN;  // exact frame index
      
      p6_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p6_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p6_mouse is active this frame...
    if (p6_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p6_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p6_mouse.clickableObjects = eval([p6_sq_1, p6_sq_2, p6_sq_3, p6_sq_4, p6_sq_5, p6_sq_6, p6_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p6_mouse.clickableObjects)) {
              p6_mouse.clickableObjects = [p6_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p6_mouse.clickableObjects) {
              if (obj.contains(p6_mouse)) {
                  gotValidClick = true;
                  p6_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p6_mouse.clickableObjects = eval([p6_sq_1, p6_sq_2, p6_sq_3, p6_sq_4, p6_sq_5, p6_sq_6, p6_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p6_mouse.clickableObjects)) {
              p6_mouse.clickableObjects = [p6_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p6_mouse.clickableObjects) {
              if (obj.contains(p6_mouse)) {
                  gotValidClick = true;
                  p6_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p6_mouse.getPos();
            p6_mouse.x.push(_mouseXYs[0]);
            p6_mouse.y.push(_mouseXYs[1]);
            p6_mouse.leftButton.push(_mouseButtons[0]);
            p6_mouse.midButton.push(_mouseButtons[1]);
            p6_mouse.rightButton.push(_mouseButtons[2]);
            p6_mouse.time.push(p6_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p6_txt_q* updates
    if (t >= 0.0 && p6_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_q.tStart = t;  // (not accounting for frame time here)
      p6_txt_q.frameNStart = frameN;  // exact frame index
      
      p6_txt_q.setAutoDraw(true);
    }
    
    
    // if p6_txt_q is active this frame...
    if (p6_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_1* updates
    if (t >= 0.0 && p6_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_1.tStart = t;  // (not accounting for frame time here)
      p6_sq_1.frameNStart = frameN;  // exact frame index
      
      p6_sq_1.setAutoDraw(true);
    }
    
    
    // if p6_sq_1 is active this frame...
    if (p6_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_2* updates
    if (t >= 0.0 && p6_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_2.tStart = t;  // (not accounting for frame time here)
      p6_sq_2.frameNStart = frameN;  // exact frame index
      
      p6_sq_2.setAutoDraw(true);
    }
    
    
    // if p6_sq_2 is active this frame...
    if (p6_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_3* updates
    if (t >= 0.0 && p6_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_3.tStart = t;  // (not accounting for frame time here)
      p6_sq_3.frameNStart = frameN;  // exact frame index
      
      p6_sq_3.setAutoDraw(true);
    }
    
    
    // if p6_sq_3 is active this frame...
    if (p6_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_4* updates
    if (t >= 0.0 && p6_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_4.tStart = t;  // (not accounting for frame time here)
      p6_sq_4.frameNStart = frameN;  // exact frame index
      
      p6_sq_4.setAutoDraw(true);
    }
    
    
    // if p6_sq_4 is active this frame...
    if (p6_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_5* updates
    if (t >= 0.0 && p6_sq_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_5.tStart = t;  // (not accounting for frame time here)
      p6_sq_5.frameNStart = frameN;  // exact frame index
      
      p6_sq_5.setAutoDraw(true);
    }
    
    
    // if p6_sq_5 is active this frame...
    if (p6_sq_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_sq_6* updates
    if (t >= 0.0 && p6_sq_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_sq_6.tStart = t;  // (not accounting for frame time here)
      p6_sq_6.frameNStart = frameN;  // exact frame index
      
      p6_sq_6.setAutoDraw(true);
    }
    
    
    // if p6_sq_6 is active this frame...
    if (p6_sq_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_1* updates
    if (t >= 0.0 && p6_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_1.tStart = t;  // (not accounting for frame time here)
      p6_txt_1.frameNStart = frameN;  // exact frame index
      
      p6_txt_1.setAutoDraw(true);
    }
    
    
    // if p6_txt_1 is active this frame...
    if (p6_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_2* updates
    if (t >= 0.0 && p6_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_2.tStart = t;  // (not accounting for frame time here)
      p6_txt_2.frameNStart = frameN;  // exact frame index
      
      p6_txt_2.setAutoDraw(true);
    }
    
    
    // if p6_txt_2 is active this frame...
    if (p6_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_3* updates
    if (t >= 0.0 && p6_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_3.tStart = t;  // (not accounting for frame time here)
      p6_txt_3.frameNStart = frameN;  // exact frame index
      
      p6_txt_3.setAutoDraw(true);
    }
    
    
    // if p6_txt_3 is active this frame...
    if (p6_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_4* updates
    if (t >= 0.0 && p6_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_4.tStart = t;  // (not accounting for frame time here)
      p6_txt_4.frameNStart = frameN;  // exact frame index
      
      p6_txt_4.setAutoDraw(true);
    }
    
    
    // if p6_txt_4 is active this frame...
    if (p6_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_5* updates
    if (t >= 0.0 && p6_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_5.tStart = t;  // (not accounting for frame time here)
      p6_txt_5.frameNStart = frameN;  // exact frame index
      
      p6_txt_5.setAutoDraw(true);
    }
    
    
    // if p6_txt_5 is active this frame...
    if (p6_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_6* updates
    if (t >= 0.0 && p6_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_6.tStart = t;  // (not accounting for frame time here)
      p6_txt_6.frameNStart = frameN;  // exact frame index
      
      p6_txt_6.setAutoDraw(true);
    }
    
    
    // if p6_txt_6 is active this frame...
    if (p6_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_box_next* updates
    if (t >= 0 && p6_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_box_next.tStart = t;  // (not accounting for frame time here)
      p6_box_next.frameNStart = frameN;  // exact frame index
      
      p6_box_next.setAutoDraw(true);
    }
    
    
    // if p6_box_next is active this frame...
    if (p6_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_box_try* updates
    if (t >= 0 && p6_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_box_try.tStart = t;  // (not accounting for frame time here)
      p6_box_try.frameNStart = frameN;  // exact frame index
      
      p6_box_try.setAutoDraw(true);
    }
    
    
    // if p6_box_try is active this frame...
    if (p6_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_next* updates
    if (t >= 0 && p6_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_next.tStart = t;  // (not accounting for frame time here)
      p6_txt_next.frameNStart = frameN;  // exact frame index
      
      p6_txt_next.setAutoDraw(true);
    }
    
    
    // if p6_txt_next is active this frame...
    if (p6_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p6_txt_try* updates
    if (t >= 0 && p6_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p6_txt_try.tStart = t;  // (not accounting for frame time here)
      p6_txt_try.frameNStart = frameN;  // exact frame index
      
      p6_txt_try.setAutoDraw(true);
    }
    
    
    // if p6_txt_try is active this frame...
    if (p6_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p6_IM_shapeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p6_IM_shapeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p6_IM_shape' ---
    p6_IM_shapeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p6_IM_shape.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p6_mouse.x', p6_mouse.x);
    psychoJS.experiment.addData('p6_mouse.y', p6_mouse.y);
    psychoJS.experiment.addData('p6_mouse.leftButton', p6_mouse.leftButton);
    psychoJS.experiment.addData('p6_mouse.midButton', p6_mouse.midButton);
    psychoJS.experiment.addData('p6_mouse.rightButton', p6_mouse.rightButton);
    psychoJS.experiment.addData('p6_mouse.time', p6_mouse.time);
    psychoJS.experiment.addData('p6_mouse.clicked_name', p6_mouse.clicked_name);
    
    // Run 'End Routine' code from p6_code_ans
    psychoJS.experiment.addData('p6_isCorrect',p6_isCorrect)
    psychoJS.experiment.addData('p6_ans', p6_ans)
    psychoJS.experiment.addData('p6_ans_Idx', p6_ans_Idx)
    psychoJS.experiment.addData('p6_corrAns',p6_corrAns)
    psychoJS.experiment.addData('p6_corrAns_Idx',p6_corrAns_Idx)
    psychoJS.experiment.addData('p6_countNext',p6_countNext)
    psychoJS.experiment.addData('p6_points',p6_points)
    // the Routine "p6_IM_shape" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p6_inTimeMaxDurationReached;
var p6_inTimeMaxDuration;
var p6_inTimeComponents;
function p6_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p6_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p6_inTimeClock.reset();
    routineTimer.reset();
    p6_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p6_inTime.started', globalClock.getTime());
    p6_inTimeMaxDuration = null
    // keep track of which components have finished
    p6_inTimeComponents = [];
    
    p6_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p6_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p6_inTime' ---
    // get current time
    t = p6_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p6_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p6_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p6_inTime' ---
    p6_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p6_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p6_code_inTime
    psychoJS.experiment.addData("p6_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p6_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p7_IM_jwordMaxDurationReached;
var p7_stimID;
var p7_IM_jwordMaxDuration;
var p7_IM_jwordComponents;
function p7_IM_jwordRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p7_IM_jword' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p7_IM_jwordClock.reset();
    routineTimer.reset();
    p7_IM_jwordMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p7_code
    p7_stimID = [p7_sq_1, p7_sq_2, p7_sq_3, p7_sq_4, p7_sq_5, p7_sq_6, p7_sq_7, p7_sq_8, p7_sq_9, p7_sq_10];
    k = 0;
    i = 0;
    if ((p7_mouse.isPressedIn(p7_box_next) && (util.sum(p7_isPicked) === 1))) {
        p7_countNext = (p7_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p7_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p7_ans_Idx = (p7_ans_Idx + [i]);
                p7_ans = ((p7_ans + ",") + p7_words[i]);
                p7_countCorrect = (p7_countCorrect + (val * p7_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p7_countCorrect === util.sum(p7_corrAns_Vec))) {
            p7_isCorrect = 1;
            p7_points = 1;
        } else {
            p7_isCorrect = 0;
            p7_points = 0;
        }
        loop_waitTillOK_p7.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p7_mouse.isPressedIn(p7_box_next) && (util.sum(p7_isPicked) !== 1))) {
            p7_opTryBox = 1;
            p7_opTryTxt = 1;
            p7_opNextBox = 0;
            p7_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p7_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p7_mouse.isPressedIn(thisStim) && (p7_isPicked[k] === 0))) {
                    p7_stimColors[k] = cAzul;
                    p7_isPicked[k] = 1;
                    p7_opTryBox = 0;
                    p7_opTryTxt = 0;
                    p7_opNextBox = 1;
                    p7_opNextTxt = 1;
                } else {
                    p7_stimColors[k] = cGrey;
                    p7_isPicked[k] = 0;
                    p7_opTryBox = 0;
                    p7_opTryTxt = 0;
                    p7_opNextBox = 1;
                    p7_opNextTxt = 1;
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p7_mouse
    // current position of the mouse:
    p7_mouse.x = [];
    p7_mouse.y = [];
    p7_mouse.leftButton = [];
    p7_mouse.midButton = [];
    p7_mouse.rightButton = [];
    p7_mouse.time = [];
    p7_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p7_mouse.mouseClock.reset();
    p7_sq_10.setFillColor(new util.Color(p7_stimColors[10]));
    p7_sq_9.setFillColor(new util.Color(p7_stimColors[9]));
    p7_sq_8.setFillColor(new util.Color(p7_stimColors[8]));
    p7_sq_7.setFillColor(new util.Color(p7_stimColors[7]));
    p7_sq_6.setFillColor(new util.Color(p7_stimColors[6]));
    p7_sq_5.setFillColor(new util.Color(p7_stimColors[5]));
    p7_sq_4.setFillColor(new util.Color(p7_stimColors[4]));
    p7_sq_3.setFillColor(new util.Color(p7_stimColors[3]));
    p7_sq_2.setFillColor(new util.Color(p7_stimColors[2]));
    p7_sq_1.setFillColor(new util.Color(p7_stimColors[1]));
    p7_txt_1.setText(p7_words[1]);
    p7_txt_2.setText(p7_words[2]);
    p7_txt_3.setText(p7_words[3]);
    p7_txt_4.setText(p7_words[4]);
    p7_txt_5.setText(p7_words[5]);
    p7_txt_6.setText(p7_words[6]);
    p7_txt_7.setText(p7_words[7]);
    p7_txt_8.setText(p7_words[8]);
    p7_txt_9.setText(p7_words[9]);
    p7_txt_10.setText(p7_words[10]);
    p7_box_next.setFillColor(new util.Color(BoxNextColor));
    p7_box_next.setOpacity(p7_opNextBox);
    p7_box_next.setLineColor(new util.Color(cGrey));
    p7_txt_next.setOpacity(p7_opNextTxt);
    p7_box_try.setFillColor(new util.Color(BoxTryColor));
    p7_box_try.setOpacity(p7_opTryBox);
    p7_box_try.setLineColor(new util.Color(cGrey));
    p7_txt_try.setOpacity(p7_opTryTxt);
    psychoJS.experiment.addData('p7_IM_jword.started', globalClock.getTime());
    p7_IM_jwordMaxDuration = null
    // keep track of which components have finished
    p7_IM_jwordComponents = [];
    p7_IM_jwordComponents.push(p7_txt_q);
    p7_IM_jwordComponents.push(p7_mouse);
    p7_IM_jwordComponents.push(p7_sq_10);
    p7_IM_jwordComponents.push(p7_sq_9);
    p7_IM_jwordComponents.push(p7_sq_8);
    p7_IM_jwordComponents.push(p7_sq_7);
    p7_IM_jwordComponents.push(p7_sq_6);
    p7_IM_jwordComponents.push(p7_sq_5);
    p7_IM_jwordComponents.push(p7_sq_4);
    p7_IM_jwordComponents.push(p7_sq_3);
    p7_IM_jwordComponents.push(p7_sq_2);
    p7_IM_jwordComponents.push(p7_sq_1);
    p7_IM_jwordComponents.push(p7_txt_1);
    p7_IM_jwordComponents.push(p7_txt_2);
    p7_IM_jwordComponents.push(p7_txt_3);
    p7_IM_jwordComponents.push(p7_txt_4);
    p7_IM_jwordComponents.push(p7_txt_5);
    p7_IM_jwordComponents.push(p7_txt_6);
    p7_IM_jwordComponents.push(p7_txt_7);
    p7_IM_jwordComponents.push(p7_txt_8);
    p7_IM_jwordComponents.push(p7_txt_9);
    p7_IM_jwordComponents.push(p7_txt_10);
    p7_IM_jwordComponents.push(p7_box_next);
    p7_IM_jwordComponents.push(p7_txt_next);
    p7_IM_jwordComponents.push(p7_box_try);
    p7_IM_jwordComponents.push(p7_txt_try);
    
    p7_IM_jwordComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p7_IM_jwordRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p7_IM_jword' ---
    // get current time
    t = p7_IM_jwordClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p7_txt_q* updates
    if (t >= 0.0 && p7_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_q.tStart = t;  // (not accounting for frame time here)
      p7_txt_q.frameNStart = frameN;  // exact frame index
      
      p7_txt_q.setAutoDraw(true);
    }
    
    
    // if p7_txt_q is active this frame...
    if (p7_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    // *p7_mouse* updates
    if (t >= 0 && p7_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_mouse.tStart = t;  // (not accounting for frame time here)
      p7_mouse.frameNStart = frameN;  // exact frame index
      
      p7_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p7_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p7_mouse is active this frame...
    if (p7_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p7_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p7_mouse.clickableObjects = eval([p7_sq_1, p7_sq_2, p7_sq_3, p7_sq_4, p7_sq_5, p7_sq_6, p7_sq_7, p7_sq_8, p7_sq_9, p7_sq_10, p7_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p7_mouse.clickableObjects)) {
              p7_mouse.clickableObjects = [p7_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p7_mouse.clickableObjects) {
              if (obj.contains(p7_mouse)) {
                  gotValidClick = true;
                  p7_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p7_mouse.clickableObjects = eval([p7_sq_1, p7_sq_2, p7_sq_3, p7_sq_4, p7_sq_5, p7_sq_6, p7_sq_7, p7_sq_8, p7_sq_9, p7_sq_10, p7_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p7_mouse.clickableObjects)) {
              p7_mouse.clickableObjects = [p7_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p7_mouse.clickableObjects) {
              if (obj.contains(p7_mouse)) {
                  gotValidClick = true;
                  p7_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p7_mouse.getPos();
            p7_mouse.x.push(_mouseXYs[0]);
            p7_mouse.y.push(_mouseXYs[1]);
            p7_mouse.leftButton.push(_mouseButtons[0]);
            p7_mouse.midButton.push(_mouseButtons[1]);
            p7_mouse.rightButton.push(_mouseButtons[2]);
            p7_mouse.time.push(p7_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p7_sq_10* updates
    if (t >= 0.0 && p7_sq_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_10.tStart = t;  // (not accounting for frame time here)
      p7_sq_10.frameNStart = frameN;  // exact frame index
      
      p7_sq_10.setAutoDraw(true);
    }
    
    
    // if p7_sq_10 is active this frame...
    if (p7_sq_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_9* updates
    if (t >= 0.0 && p7_sq_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_9.tStart = t;  // (not accounting for frame time here)
      p7_sq_9.frameNStart = frameN;  // exact frame index
      
      p7_sq_9.setAutoDraw(true);
    }
    
    
    // if p7_sq_9 is active this frame...
    if (p7_sq_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_8* updates
    if (t >= 0.0 && p7_sq_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_8.tStart = t;  // (not accounting for frame time here)
      p7_sq_8.frameNStart = frameN;  // exact frame index
      
      p7_sq_8.setAutoDraw(true);
    }
    
    
    // if p7_sq_8 is active this frame...
    if (p7_sq_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_7* updates
    if (t >= 0.0 && p7_sq_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_7.tStart = t;  // (not accounting for frame time here)
      p7_sq_7.frameNStart = frameN;  // exact frame index
      
      p7_sq_7.setAutoDraw(true);
    }
    
    
    // if p7_sq_7 is active this frame...
    if (p7_sq_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_6* updates
    if (t >= 0.0 && p7_sq_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_6.tStart = t;  // (not accounting for frame time here)
      p7_sq_6.frameNStart = frameN;  // exact frame index
      
      p7_sq_6.setAutoDraw(true);
    }
    
    
    // if p7_sq_6 is active this frame...
    if (p7_sq_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_5* updates
    if (t >= 0.0 && p7_sq_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_5.tStart = t;  // (not accounting for frame time here)
      p7_sq_5.frameNStart = frameN;  // exact frame index
      
      p7_sq_5.setAutoDraw(true);
    }
    
    
    // if p7_sq_5 is active this frame...
    if (p7_sq_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_4* updates
    if (t >= 0.0 && p7_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_4.tStart = t;  // (not accounting for frame time here)
      p7_sq_4.frameNStart = frameN;  // exact frame index
      
      p7_sq_4.setAutoDraw(true);
    }
    
    
    // if p7_sq_4 is active this frame...
    if (p7_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_3* updates
    if (t >= 0.0 && p7_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_3.tStart = t;  // (not accounting for frame time here)
      p7_sq_3.frameNStart = frameN;  // exact frame index
      
      p7_sq_3.setAutoDraw(true);
    }
    
    
    // if p7_sq_3 is active this frame...
    if (p7_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_2* updates
    if (t >= 0.0 && p7_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_2.tStart = t;  // (not accounting for frame time here)
      p7_sq_2.frameNStart = frameN;  // exact frame index
      
      p7_sq_2.setAutoDraw(true);
    }
    
    
    // if p7_sq_2 is active this frame...
    if (p7_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_sq_1* updates
    if (t >= 0.0 && p7_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_sq_1.tStart = t;  // (not accounting for frame time here)
      p7_sq_1.frameNStart = frameN;  // exact frame index
      
      p7_sq_1.setAutoDraw(true);
    }
    
    
    // if p7_sq_1 is active this frame...
    if (p7_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_1* updates
    if (t >= 0.0 && p7_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_1.tStart = t;  // (not accounting for frame time here)
      p7_txt_1.frameNStart = frameN;  // exact frame index
      
      p7_txt_1.setAutoDraw(true);
    }
    
    
    // if p7_txt_1 is active this frame...
    if (p7_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_2* updates
    if (t >= 0.0 && p7_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_2.tStart = t;  // (not accounting for frame time here)
      p7_txt_2.frameNStart = frameN;  // exact frame index
      
      p7_txt_2.setAutoDraw(true);
    }
    
    
    // if p7_txt_2 is active this frame...
    if (p7_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_3* updates
    if (t >= 0.0 && p7_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_3.tStart = t;  // (not accounting for frame time here)
      p7_txt_3.frameNStart = frameN;  // exact frame index
      
      p7_txt_3.setAutoDraw(true);
    }
    
    
    // if p7_txt_3 is active this frame...
    if (p7_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_4* updates
    if (t >= 0.0 && p7_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_4.tStart = t;  // (not accounting for frame time here)
      p7_txt_4.frameNStart = frameN;  // exact frame index
      
      p7_txt_4.setAutoDraw(true);
    }
    
    
    // if p7_txt_4 is active this frame...
    if (p7_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_5* updates
    if (t >= 0.0 && p7_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_5.tStart = t;  // (not accounting for frame time here)
      p7_txt_5.frameNStart = frameN;  // exact frame index
      
      p7_txt_5.setAutoDraw(true);
    }
    
    
    // if p7_txt_5 is active this frame...
    if (p7_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_6* updates
    if (t >= 0.0 && p7_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_6.tStart = t;  // (not accounting for frame time here)
      p7_txt_6.frameNStart = frameN;  // exact frame index
      
      p7_txt_6.setAutoDraw(true);
    }
    
    
    // if p7_txt_6 is active this frame...
    if (p7_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_7* updates
    if (t >= 0.0 && p7_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_7.tStart = t;  // (not accounting for frame time here)
      p7_txt_7.frameNStart = frameN;  // exact frame index
      
      p7_txt_7.setAutoDraw(true);
    }
    
    
    // if p7_txt_7 is active this frame...
    if (p7_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_8* updates
    if (t >= 0.0 && p7_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_8.tStart = t;  // (not accounting for frame time here)
      p7_txt_8.frameNStart = frameN;  // exact frame index
      
      p7_txt_8.setAutoDraw(true);
    }
    
    
    // if p7_txt_8 is active this frame...
    if (p7_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_9* updates
    if (t >= 0.0 && p7_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_9.tStart = t;  // (not accounting for frame time here)
      p7_txt_9.frameNStart = frameN;  // exact frame index
      
      p7_txt_9.setAutoDraw(true);
    }
    
    
    // if p7_txt_9 is active this frame...
    if (p7_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_10* updates
    if (t >= 0.0 && p7_txt_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_10.tStart = t;  // (not accounting for frame time here)
      p7_txt_10.frameNStart = frameN;  // exact frame index
      
      p7_txt_10.setAutoDraw(true);
    }
    
    
    // if p7_txt_10 is active this frame...
    if (p7_txt_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_box_next* updates
    if (t >= 0 && p7_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_box_next.tStart = t;  // (not accounting for frame time here)
      p7_box_next.frameNStart = frameN;  // exact frame index
      
      p7_box_next.setAutoDraw(true);
    }
    
    
    // if p7_box_next is active this frame...
    if (p7_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_next* updates
    if (t >= 0 && p7_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_next.tStart = t;  // (not accounting for frame time here)
      p7_txt_next.frameNStart = frameN;  // exact frame index
      
      p7_txt_next.setAutoDraw(true);
    }
    
    
    // if p7_txt_next is active this frame...
    if (p7_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_box_try* updates
    if (t >= 0 && p7_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_box_try.tStart = t;  // (not accounting for frame time here)
      p7_box_try.frameNStart = frameN;  // exact frame index
      
      p7_box_try.setAutoDraw(true);
    }
    
    
    // if p7_box_try is active this frame...
    if (p7_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p7_txt_try* updates
    if (t >= 0 && p7_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p7_txt_try.tStart = t;  // (not accounting for frame time here)
      p7_txt_try.frameNStart = frameN;  // exact frame index
      
      p7_txt_try.setAutoDraw(true);
    }
    
    
    // if p7_txt_try is active this frame...
    if (p7_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p7_IM_jwordComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p7_IM_jwordRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p7_IM_jword' ---
    p7_IM_jwordComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p7_IM_jword.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p7_mouse.x', p7_mouse.x);
    psychoJS.experiment.addData('p7_mouse.y', p7_mouse.y);
    psychoJS.experiment.addData('p7_mouse.leftButton', p7_mouse.leftButton);
    psychoJS.experiment.addData('p7_mouse.midButton', p7_mouse.midButton);
    psychoJS.experiment.addData('p7_mouse.rightButton', p7_mouse.rightButton);
    psychoJS.experiment.addData('p7_mouse.time', p7_mouse.time);
    psychoJS.experiment.addData('p7_mouse.clicked_name', p7_mouse.clicked_name);
    
    // Run 'End Routine' code from p7_code_ans
    psychoJS.experiment.addData('p7_isCorrect',p7_isCorrect)
    psychoJS.experiment.addData('p7_ans', p7_ans)
    psychoJS.experiment.addData('p7_ans_Idx', p7_ans_Idx)
    psychoJS.experiment.addData('p7_corrAns',p7_corrAns)
    psychoJS.experiment.addData('p7_corrAns_Idx',p7_corrAns_Idx)
    psychoJS.experiment.addData('p7_countNext',p7_countNext)
    psychoJS.experiment.addData('p7_points',p7_points)
    // the Routine "p7_IM_jword" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p7_inTimeMaxDurationReached;
var p7_inTimeMaxDuration;
var p7_inTimeComponents;
function p7_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p7_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p7_inTimeClock.reset();
    routineTimer.reset();
    p7_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p7_inTime.started', globalClock.getTime());
    p7_inTimeMaxDuration = null
    // keep track of which components have finished
    p7_inTimeComponents = [];
    
    p7_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p7_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p7_inTime' ---
    // get current time
    t = p7_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p7_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p7_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p7_inTime' ---
    p7_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p7_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p7_code_inTime
    psychoJS.experiment.addData("p7_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p7_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p8_IM_numberMaxDurationReached;
var p8_keyID;
var p8_IM_numberMaxDuration;
var p8_IM_numberComponents;
function p8_IM_numberRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p8_IM_number' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p8_IM_numberClock.reset();
    routineTimer.reset();
    p8_IM_numberMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p8_code
    p8_keyID = [p8_key_1, p8_key_2, p8_key_3, p8_key_4, p8_key_5, p8_key_6, p8_key_7, p8_key_8, p8_key_9, p8_key_0, p8_key_DEL];
    k = 0;
    if ((p8_mouse.isPressedIn(p8_box_next) && (lenString_p8 === 4))) {
        p8_countNext = (p8_countNext + 1);
        if (p8_isCorrect) {
            p8_points = 1;
        } else {
            p8_points = 0;
        }
        loop_waitTillOK_p8.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p8_mouse.isPressedIn(p8_box_next) && (lenString_p8 < 4))) {
            p8_countNext = (p8_countNext + 1);
            p8_opTryBox = 1;
            p8_opTryTxt = 1;
            p8_opNextBox = 0;
            p8_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p8_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p8_mouse.isPressedIn(thisKey)) {
                    if ((lenString_p8 < 4)) {
                        p8_ans = (p8_ans + p8_keyNum[k]);
                        lenString_p8 = (lenString_p8 + 1);
                        p8_screen_txt.text = p8_ans;
                        p8_opTryBox = 0;
                        p8_opTryTxt = 0;
                        p8_opNextBox = 1;
                        p8_opNextTxt = 1;
                        if ((p8_ans === p8_corrAns)) {
                            p8_isCorrect = 1;
                        } else {
                            p8_isCorrect = 0;
                        }
                    }
                    if ((p8_keyNum[k] === "DEL")) {
                        p8_ans = "";
                        lenString_p8 = 0;
                        p8_screen_txt.text = p8_ans;
                        p8_isCorrect = 0;
                        p8_opTryBox = 0;
                        p8_opTryTxt = 0;
                        p8_opNextBox = 1;
                        p8_opNextTxt = 1;
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p8_mouse
    // current position of the mouse:
    p8_mouse.x = [];
    p8_mouse.y = [];
    p8_mouse.leftButton = [];
    p8_mouse.midButton = [];
    p8_mouse.rightButton = [];
    p8_mouse.time = [];
    p8_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p8_mouse.mouseClock.reset();
    p8_screen_txt.setText(p8_ans);
    p8_box_next.setFillColor(new util.Color(BoxNextColor));
    p8_box_next.setOpacity(p8_opNextBox);
    p8_box_next.setLineColor(new util.Color(cGrey));
    p8_txt_next.setOpacity(p8_opNextTxt);
    p8_box_try.setFillColor(new util.Color(BoxTryColor));
    p8_box_try.setOpacity(p8_opTryBox);
    p8_box_try.setLineColor(new util.Color(cGrey));
    p8_txt_try.setOpacity(p8_opTryTxt);
    psychoJS.experiment.addData('p8_IM_number.started', globalClock.getTime());
    p8_IM_numberMaxDuration = null
    // keep track of which components have finished
    p8_IM_numberComponents = [];
    p8_IM_numberComponents.push(p8_txt_q);
    p8_IM_numberComponents.push(p8_mouse);
    p8_IM_numberComponents.push(p8_screen_box);
    p8_IM_numberComponents.push(p8_screen_txt);
    p8_IM_numberComponents.push(p8_key_1);
    p8_IM_numberComponents.push(p8_key_2);
    p8_IM_numberComponents.push(p8_key_3);
    p8_IM_numberComponents.push(p8_key_4);
    p8_IM_numberComponents.push(p8_key_5);
    p8_IM_numberComponents.push(p8_key_6);
    p8_IM_numberComponents.push(p8_key_7);
    p8_IM_numberComponents.push(p8_key_8);
    p8_IM_numberComponents.push(p8_key_9);
    p8_IM_numberComponents.push(p8_key_0);
    p8_IM_numberComponents.push(p8_key_DEL);
    p8_IM_numberComponents.push(p8_box_next);
    p8_IM_numberComponents.push(p8_txt_next);
    p8_IM_numberComponents.push(p8_box_try);
    p8_IM_numberComponents.push(p8_txt_try);
    p8_IM_numberComponents.push(p8_key_txt_1);
    p8_IM_numberComponents.push(p8_key_txt_2);
    p8_IM_numberComponents.push(p8_key_txt_3);
    p8_IM_numberComponents.push(p8_key_txt_4);
    p8_IM_numberComponents.push(p8_key_txt_5);
    p8_IM_numberComponents.push(p8_key_txt_6);
    p8_IM_numberComponents.push(p8_key_txt_7);
    p8_IM_numberComponents.push(p8_key_txt_8);
    p8_IM_numberComponents.push(p8_key_txt_9);
    p8_IM_numberComponents.push(p8_key_txt_0);
    p8_IM_numberComponents.push(p8_key_txt_DEL);
    
    p8_IM_numberComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p8_IM_numberRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p8_IM_number' ---
    // get current time
    t = p8_IM_numberClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p8_txt_q* updates
    if (t >= 0.0 && p8_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_txt_q.tStart = t;  // (not accounting for frame time here)
      p8_txt_q.frameNStart = frameN;  // exact frame index
      
      p8_txt_q.setAutoDraw(true);
    }
    
    
    // if p8_txt_q is active this frame...
    if (p8_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    // *p8_mouse* updates
    if (t >= 0.0 && p8_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_mouse.tStart = t;  // (not accounting for frame time here)
      p8_mouse.frameNStart = frameN;  // exact frame index
      
      p8_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p8_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p8_mouse is active this frame...
    if (p8_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p8_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p8_mouse.clickableObjects = eval([p8_key_1, p8_key_2, p8_key_3, p8_key_4, p8_key_5, p8_key_6, p8_key_7, p8_key_8, p8_key_9, p8_key_0, p8_key_DEL, p8_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p8_mouse.clickableObjects)) {
              p8_mouse.clickableObjects = [p8_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p8_mouse.clickableObjects) {
              if (obj.contains(p8_mouse)) {
                  gotValidClick = true;
                  p8_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p8_mouse.clickableObjects = eval([p8_key_1, p8_key_2, p8_key_3, p8_key_4, p8_key_5, p8_key_6, p8_key_7, p8_key_8, p8_key_9, p8_key_0, p8_key_DEL, p8_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p8_mouse.clickableObjects)) {
              p8_mouse.clickableObjects = [p8_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p8_mouse.clickableObjects) {
              if (obj.contains(p8_mouse)) {
                  gotValidClick = true;
                  p8_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p8_mouse.getPos();
            p8_mouse.x.push(_mouseXYs[0]);
            p8_mouse.y.push(_mouseXYs[1]);
            p8_mouse.leftButton.push(_mouseButtons[0]);
            p8_mouse.midButton.push(_mouseButtons[1]);
            p8_mouse.rightButton.push(_mouseButtons[2]);
            p8_mouse.time.push(p8_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p8_screen_box* updates
    if (t >= 0.0 && p8_screen_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_screen_box.tStart = t;  // (not accounting for frame time here)
      p8_screen_box.frameNStart = frameN;  // exact frame index
      
      p8_screen_box.setAutoDraw(true);
    }
    
    
    // if p8_screen_box is active this frame...
    if (p8_screen_box.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_screen_txt* updates
    if (t >= 0.0 && p8_screen_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_screen_txt.tStart = t;  // (not accounting for frame time here)
      p8_screen_txt.frameNStart = frameN;  // exact frame index
      
      p8_screen_txt.setAutoDraw(true);
    }
    
    
    // if p8_screen_txt is active this frame...
    if (p8_screen_txt.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_1* updates
    if (t >= 0.0 && p8_key_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_1.tStart = t;  // (not accounting for frame time here)
      p8_key_1.frameNStart = frameN;  // exact frame index
      
      p8_key_1.setAutoDraw(true);
    }
    
    
    // if p8_key_1 is active this frame...
    if (p8_key_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_2* updates
    if (t >= 0.0 && p8_key_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_2.tStart = t;  // (not accounting for frame time here)
      p8_key_2.frameNStart = frameN;  // exact frame index
      
      p8_key_2.setAutoDraw(true);
    }
    
    
    // if p8_key_2 is active this frame...
    if (p8_key_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_3* updates
    if (t >= 0.0 && p8_key_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_3.tStart = t;  // (not accounting for frame time here)
      p8_key_3.frameNStart = frameN;  // exact frame index
      
      p8_key_3.setAutoDraw(true);
    }
    
    
    // if p8_key_3 is active this frame...
    if (p8_key_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_4* updates
    if (t >= 0.0 && p8_key_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_4.tStart = t;  // (not accounting for frame time here)
      p8_key_4.frameNStart = frameN;  // exact frame index
      
      p8_key_4.setAutoDraw(true);
    }
    
    
    // if p8_key_4 is active this frame...
    if (p8_key_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_5* updates
    if (t >= 0.0 && p8_key_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_5.tStart = t;  // (not accounting for frame time here)
      p8_key_5.frameNStart = frameN;  // exact frame index
      
      p8_key_5.setAutoDraw(true);
    }
    
    
    // if p8_key_5 is active this frame...
    if (p8_key_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_6* updates
    if (t >= 0.0 && p8_key_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_6.tStart = t;  // (not accounting for frame time here)
      p8_key_6.frameNStart = frameN;  // exact frame index
      
      p8_key_6.setAutoDraw(true);
    }
    
    
    // if p8_key_6 is active this frame...
    if (p8_key_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_7* updates
    if (t >= 0.0 && p8_key_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_7.tStart = t;  // (not accounting for frame time here)
      p8_key_7.frameNStart = frameN;  // exact frame index
      
      p8_key_7.setAutoDraw(true);
    }
    
    
    // if p8_key_7 is active this frame...
    if (p8_key_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_8* updates
    if (t >= 0.0 && p8_key_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_8.tStart = t;  // (not accounting for frame time here)
      p8_key_8.frameNStart = frameN;  // exact frame index
      
      p8_key_8.setAutoDraw(true);
    }
    
    
    // if p8_key_8 is active this frame...
    if (p8_key_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_9* updates
    if (t >= 0.0 && p8_key_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_9.tStart = t;  // (not accounting for frame time here)
      p8_key_9.frameNStart = frameN;  // exact frame index
      
      p8_key_9.setAutoDraw(true);
    }
    
    
    // if p8_key_9 is active this frame...
    if (p8_key_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_0* updates
    if (t >= 0.0 && p8_key_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_0.tStart = t;  // (not accounting for frame time here)
      p8_key_0.frameNStart = frameN;  // exact frame index
      
      p8_key_0.setAutoDraw(true);
    }
    
    
    // if p8_key_0 is active this frame...
    if (p8_key_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_DEL* updates
    if (t >= 0.0 && p8_key_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_DEL.tStart = t;  // (not accounting for frame time here)
      p8_key_DEL.frameNStart = frameN;  // exact frame index
      
      p8_key_DEL.setAutoDraw(true);
    }
    
    
    // if p8_key_DEL is active this frame...
    if (p8_key_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_box_next* updates
    if (t >= 0.0 && p8_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_box_next.tStart = t;  // (not accounting for frame time here)
      p8_box_next.frameNStart = frameN;  // exact frame index
      
      p8_box_next.setAutoDraw(true);
    }
    
    
    // if p8_box_next is active this frame...
    if (p8_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_txt_next* updates
    if (t >= 0.0 && p8_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_txt_next.tStart = t;  // (not accounting for frame time here)
      p8_txt_next.frameNStart = frameN;  // exact frame index
      
      p8_txt_next.setAutoDraw(true);
    }
    
    
    // if p8_txt_next is active this frame...
    if (p8_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_box_try* updates
    if (t >= 0.0 && p8_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_box_try.tStart = t;  // (not accounting for frame time here)
      p8_box_try.frameNStart = frameN;  // exact frame index
      
      p8_box_try.setAutoDraw(true);
    }
    
    
    // if p8_box_try is active this frame...
    if (p8_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_txt_try* updates
    if (t >= 0.0 && p8_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_txt_try.tStart = t;  // (not accounting for frame time here)
      p8_txt_try.frameNStart = frameN;  // exact frame index
      
      p8_txt_try.setAutoDraw(true);
    }
    
    
    // if p8_txt_try is active this frame...
    if (p8_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_1* updates
    if (t >= 0.0 && p8_key_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_1.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_1.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_1.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_1 is active this frame...
    if (p8_key_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_2* updates
    if (t >= 0.0 && p8_key_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_2.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_2.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_2.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_2 is active this frame...
    if (p8_key_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_3* updates
    if (t >= 0.0 && p8_key_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_3.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_3.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_3.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_3 is active this frame...
    if (p8_key_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_4* updates
    if (t >= 0.0 && p8_key_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_4.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_4.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_4.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_4 is active this frame...
    if (p8_key_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_5* updates
    if (t >= 0.0 && p8_key_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_5.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_5.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_5.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_5 is active this frame...
    if (p8_key_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_6* updates
    if (t >= 0.0 && p8_key_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_6.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_6.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_6.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_6 is active this frame...
    if (p8_key_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_7* updates
    if (t >= 0.0 && p8_key_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_7.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_7.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_7.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_7 is active this frame...
    if (p8_key_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_8* updates
    if (t >= 0.0 && p8_key_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_8.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_8.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_8.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_8 is active this frame...
    if (p8_key_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_9* updates
    if (t >= 0.0 && p8_key_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_9.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_9.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_9.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_9 is active this frame...
    if (p8_key_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_0* updates
    if (t >= 0.0 && p8_key_txt_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_0.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_0.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_0.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_0 is active this frame...
    if (p8_key_txt_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p8_key_txt_DEL* updates
    if (t >= 0.0 && p8_key_txt_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p8_key_txt_DEL.tStart = t;  // (not accounting for frame time here)
      p8_key_txt_DEL.frameNStart = frameN;  // exact frame index
      
      p8_key_txt_DEL.setAutoDraw(true);
    }
    
    
    // if p8_key_txt_DEL is active this frame...
    if (p8_key_txt_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p8_IM_numberComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p8_IM_numberRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p8_IM_number' ---
    p8_IM_numberComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p8_IM_number.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p8_mouse.x', p8_mouse.x);
    psychoJS.experiment.addData('p8_mouse.y', p8_mouse.y);
    psychoJS.experiment.addData('p8_mouse.leftButton', p8_mouse.leftButton);
    psychoJS.experiment.addData('p8_mouse.midButton', p8_mouse.midButton);
    psychoJS.experiment.addData('p8_mouse.rightButton', p8_mouse.rightButton);
    psychoJS.experiment.addData('p8_mouse.time', p8_mouse.time);
    psychoJS.experiment.addData('p8_mouse.clicked_name', p8_mouse.clicked_name);
    
    // Run 'End Routine' code from p8_code_ans
    psychoJS.experiment.addData('p8_isCorrect',p8_isCorrect)
    psychoJS.experiment.addData('p8_ans', p8_ans)
    psychoJS.experiment.addData('p8_corrAns',p8_corrAns)
    psychoJS.experiment.addData('p8_countNext',p8_countNext)
    psychoJS.experiment.addData('p8_points',p8_points)
    // the Routine "p8_IM_number" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p8_inTimeMaxDurationReached;
var p8_inTimeMaxDuration;
var p8_inTimeComponents;
function p8_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p8_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p8_inTimeClock.reset();
    routineTimer.reset();
    p8_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p8_inTime.started', globalClock.getTime());
    p8_inTimeMaxDuration = null
    // keep track of which components have finished
    p8_inTimeComponents = [];
    
    p8_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p8_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p8_inTime' ---
    // get current time
    t = p8_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p8_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p8_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p8_inTime' ---
    p8_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p8_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p8_code_inTime
    psychoJS.experiment.addData("p8_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p8_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9_ST_monthMaxDurationReached;
var p9a_stimID;
var p9_ST_monthMaxDuration;
var p9_ST_monthComponents;
function p9_ST_monthRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9_ST_month' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9_ST_monthClock.reset();
    routineTimer.reset();
    p9_ST_monthMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p9a_code
    p9a_stimID = [p9a_sq_1, p9a_sq_2, p9a_sq_3, p9a_sq_4, p9a_sq_5, p9a_sq_6, p9a_sq_7, p9a_sq_8, p9a_sq_9, p9a_sq_10, p9a_sq_11, p9a_sq_12];
    k = 0;
    i = 0;
    if ((p9a_mouse.isPressedIn(p9a_box_next) && (util.sum(p9a_isPicked) === 1))) {
        p9a_countNext = (p9a_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p9a_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p9a_ans_Idx = (p9a_ans_Idx + [i]);
                p9a_ans = p9a_words[i];
            }
            i = (i + 1);
        }
        if ((p9a_ans_Idx === p9a_corrAns_Idx)) {
            p9a_isCorrect = 1;
            p9a_points = 1;
        } else {
            p9a_isCorrect = 0;
            p9a_points = 0;
        }
        loop_waitTillOK_p9a.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p9a_mouse.isPressedIn(p9a_box_next) && (util.sum(p9a_isPicked) !== 1))) {
            p9a_countNext = (p9a_countNext + 1);
            p9a_opTryBox = 1;
            p9a_opTryTxt = 1;
            p9a_opNextBox = 0;
            p9a_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p9a_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p9a_mouse.isPressedIn(thisStim) && (p9a_isPicked[k] === 0))) {
                    p9a_stimColors[k] = cAzul;
                    p9a_isPicked[k] = 1;
                    p9a_opTryBox = 0;
                    p9a_opTryTxt = 0;
                    p9a_opNextBox = 1;
                    p9a_opNextTxt = 1;
                } else {
                    p9a_stimColors[k] = cGrey;
                    p9a_isPicked[k] = 0;
                    p9a_opTryBox = 0;
                    p9a_opTryTxt = 0;
                    p9a_opNextBox = 1;
                    p9a_opNextTxt = 1;
                }
            }
        }
    }
    
    p9a_sq_1.setFillColor(new util.Color(p9a_stimColors[1]));
    p9a_sq_2.setFillColor(new util.Color(p9a_stimColors[2]));
    p9a_sq_3.setFillColor(new util.Color(p9a_stimColors[3]));
    p9a_sq_4.setFillColor(new util.Color(p9a_stimColors[4]));
    p9a_sq_5.setFillColor(new util.Color(p9a_stimColors[5]));
    p9a_sq_6.setFillColor(new util.Color(p9a_stimColors[6]));
    p9a_sq_7.setFillColor(new util.Color(p9a_stimColors[7]));
    p9a_sq_8.setFillColor(new util.Color(p9a_stimColors[8]));
    p9a_sq_9.setFillColor(new util.Color(p9a_stimColors[9]));
    p9a_sq_10.setFillColor(new util.Color(p9a_stimColors[10]));
    p9a_sq_11.setFillColor(new util.Color(p9a_stimColors[11]));
    p9a_sq_12.setFillColor(new util.Color(p9a_stimColors[12]));
    p9a_txt_1.setText(p9a_words[1]);
    p9a_txt_2.setText(p9a_words[2]);
    p9a_txt_3.setText(p9a_words[3]);
    p9a_txt_4.setText(p9a_words[4]);
    p9a_txt_5.setText(p9a_words[5]);
    p9a_txt_6.setText(p9a_words[6]);
    p9a_txt_7.setText(p9a_words[7]);
    p9a_txt_8.setText(p9a_words[8]);
    p9a_txt_9.setText(p9a_words[9]);
    p9a_txt_10.setText(p9a_words[10]);
    p9a_txt_11.setText(p9a_words[11]);
    p9a_txt_12.setText(p9a_words[12]);
    // setup some python lists for storing info about the p9a_mouse
    // current position of the mouse:
    p9a_mouse.x = [];
    p9a_mouse.y = [];
    p9a_mouse.leftButton = [];
    p9a_mouse.midButton = [];
    p9a_mouse.rightButton = [];
    p9a_mouse.time = [];
    p9a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p9a_mouse.mouseClock.reset();
    p9a_box_next.setFillColor(new util.Color(BoxNextColor));
    p9a_box_next.setOpacity(p9a_opNextBox);
    p9a_box_next.setLineColor(new util.Color(cGrey));
    p9a_txt_next.setOpacity(p9a_opNextTxt);
    p9a_box_try.setFillColor(new util.Color(BoxTryColor));
    p9a_box_try.setOpacity(p9a_opTryBox);
    p9a_box_try.setLineColor(new util.Color(cGrey));
    p9a_txt_try.setOpacity(p9a_opTryTxt);
    psychoJS.experiment.addData('p9_ST_month.started', globalClock.getTime());
    p9_ST_monthMaxDuration = null
    // keep track of which components have finished
    p9_ST_monthComponents = [];
    p9_ST_monthComponents.push(p9a_sq_1);
    p9_ST_monthComponents.push(p9a_sq_2);
    p9_ST_monthComponents.push(p9a_sq_3);
    p9_ST_monthComponents.push(p9a_sq_4);
    p9_ST_monthComponents.push(p9a_sq_5);
    p9_ST_monthComponents.push(p9a_sq_6);
    p9_ST_monthComponents.push(p9a_sq_7);
    p9_ST_monthComponents.push(p9a_sq_8);
    p9_ST_monthComponents.push(p9a_sq_9);
    p9_ST_monthComponents.push(p9a_sq_10);
    p9_ST_monthComponents.push(p9a_sq_11);
    p9_ST_monthComponents.push(p9a_sq_12);
    p9_ST_monthComponents.push(p9a_txt_1);
    p9_ST_monthComponents.push(p9a_txt_2);
    p9_ST_monthComponents.push(p9a_txt_3);
    p9_ST_monthComponents.push(p9a_txt_4);
    p9_ST_monthComponents.push(p9a_txt_5);
    p9_ST_monthComponents.push(p9a_txt_6);
    p9_ST_monthComponents.push(p9a_txt_7);
    p9_ST_monthComponents.push(p9a_txt_8);
    p9_ST_monthComponents.push(p9a_txt_9);
    p9_ST_monthComponents.push(p9a_txt_10);
    p9_ST_monthComponents.push(p9a_txt_11);
    p9_ST_monthComponents.push(p9a_txt_12);
    p9_ST_monthComponents.push(p9a_mouse);
    p9_ST_monthComponents.push(p9a_txt_q);
    p9_ST_monthComponents.push(p9a_box_next);
    p9_ST_monthComponents.push(p9a_txt_next);
    p9_ST_monthComponents.push(p9a_box_try);
    p9_ST_monthComponents.push(p9a_txt_try);
    
    p9_ST_monthComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9_ST_monthRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9_ST_month' ---
    // get current time
    t = p9_ST_monthClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p9a_sq_1* updates
    if (t >= 0.0 && p9a_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_1.tStart = t;  // (not accounting for frame time here)
      p9a_sq_1.frameNStart = frameN;  // exact frame index
      
      p9a_sq_1.setAutoDraw(true);
    }
    
    
    // if p9a_sq_1 is active this frame...
    if (p9a_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_2* updates
    if (t >= 0.0 && p9a_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_2.tStart = t;  // (not accounting for frame time here)
      p9a_sq_2.frameNStart = frameN;  // exact frame index
      
      p9a_sq_2.setAutoDraw(true);
    }
    
    
    // if p9a_sq_2 is active this frame...
    if (p9a_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_3* updates
    if (t >= 0.0 && p9a_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_3.tStart = t;  // (not accounting for frame time here)
      p9a_sq_3.frameNStart = frameN;  // exact frame index
      
      p9a_sq_3.setAutoDraw(true);
    }
    
    
    // if p9a_sq_3 is active this frame...
    if (p9a_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_4* updates
    if (t >= 0.0 && p9a_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_4.tStart = t;  // (not accounting for frame time here)
      p9a_sq_4.frameNStart = frameN;  // exact frame index
      
      p9a_sq_4.setAutoDraw(true);
    }
    
    
    // if p9a_sq_4 is active this frame...
    if (p9a_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_5* updates
    if (t >= 0.0 && p9a_sq_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_5.tStart = t;  // (not accounting for frame time here)
      p9a_sq_5.frameNStart = frameN;  // exact frame index
      
      p9a_sq_5.setAutoDraw(true);
    }
    
    
    // if p9a_sq_5 is active this frame...
    if (p9a_sq_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_6* updates
    if (t >= 0.0 && p9a_sq_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_6.tStart = t;  // (not accounting for frame time here)
      p9a_sq_6.frameNStart = frameN;  // exact frame index
      
      p9a_sq_6.setAutoDraw(true);
    }
    
    
    // if p9a_sq_6 is active this frame...
    if (p9a_sq_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_7* updates
    if (t >= 0.0 && p9a_sq_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_7.tStart = t;  // (not accounting for frame time here)
      p9a_sq_7.frameNStart = frameN;  // exact frame index
      
      p9a_sq_7.setAutoDraw(true);
    }
    
    
    // if p9a_sq_7 is active this frame...
    if (p9a_sq_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_8* updates
    if (t >= 0.0 && p9a_sq_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_8.tStart = t;  // (not accounting for frame time here)
      p9a_sq_8.frameNStart = frameN;  // exact frame index
      
      p9a_sq_8.setAutoDraw(true);
    }
    
    
    // if p9a_sq_8 is active this frame...
    if (p9a_sq_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_9* updates
    if (t >= 0.0 && p9a_sq_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_9.tStart = t;  // (not accounting for frame time here)
      p9a_sq_9.frameNStart = frameN;  // exact frame index
      
      p9a_sq_9.setAutoDraw(true);
    }
    
    
    // if p9a_sq_9 is active this frame...
    if (p9a_sq_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_10* updates
    if (t >= 0.0 && p9a_sq_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_10.tStart = t;  // (not accounting for frame time here)
      p9a_sq_10.frameNStart = frameN;  // exact frame index
      
      p9a_sq_10.setAutoDraw(true);
    }
    
    
    // if p9a_sq_10 is active this frame...
    if (p9a_sq_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_11* updates
    if (t >= 0.0 && p9a_sq_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_11.tStart = t;  // (not accounting for frame time here)
      p9a_sq_11.frameNStart = frameN;  // exact frame index
      
      p9a_sq_11.setAutoDraw(true);
    }
    
    
    // if p9a_sq_11 is active this frame...
    if (p9a_sq_11.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_sq_12* updates
    if (t >= 0.0 && p9a_sq_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_sq_12.tStart = t;  // (not accounting for frame time here)
      p9a_sq_12.frameNStart = frameN;  // exact frame index
      
      p9a_sq_12.setAutoDraw(true);
    }
    
    
    // if p9a_sq_12 is active this frame...
    if (p9a_sq_12.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_1* updates
    if (t >= 0.0 && p9a_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_1.tStart = t;  // (not accounting for frame time here)
      p9a_txt_1.frameNStart = frameN;  // exact frame index
      
      p9a_txt_1.setAutoDraw(true);
    }
    
    
    // if p9a_txt_1 is active this frame...
    if (p9a_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_2* updates
    if (t >= 0.0 && p9a_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_2.tStart = t;  // (not accounting for frame time here)
      p9a_txt_2.frameNStart = frameN;  // exact frame index
      
      p9a_txt_2.setAutoDraw(true);
    }
    
    
    // if p9a_txt_2 is active this frame...
    if (p9a_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_3* updates
    if (t >= 0.0 && p9a_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_3.tStart = t;  // (not accounting for frame time here)
      p9a_txt_3.frameNStart = frameN;  // exact frame index
      
      p9a_txt_3.setAutoDraw(true);
    }
    
    
    // if p9a_txt_3 is active this frame...
    if (p9a_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_4* updates
    if (t >= 0.0 && p9a_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_4.tStart = t;  // (not accounting for frame time here)
      p9a_txt_4.frameNStart = frameN;  // exact frame index
      
      p9a_txt_4.setAutoDraw(true);
    }
    
    
    // if p9a_txt_4 is active this frame...
    if (p9a_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_5* updates
    if (t >= 0.0 && p9a_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_5.tStart = t;  // (not accounting for frame time here)
      p9a_txt_5.frameNStart = frameN;  // exact frame index
      
      p9a_txt_5.setAutoDraw(true);
    }
    
    
    // if p9a_txt_5 is active this frame...
    if (p9a_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_6* updates
    if (t >= 0.0 && p9a_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_6.tStart = t;  // (not accounting for frame time here)
      p9a_txt_6.frameNStart = frameN;  // exact frame index
      
      p9a_txt_6.setAutoDraw(true);
    }
    
    
    // if p9a_txt_6 is active this frame...
    if (p9a_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_7* updates
    if (t >= 0.0 && p9a_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_7.tStart = t;  // (not accounting for frame time here)
      p9a_txt_7.frameNStart = frameN;  // exact frame index
      
      p9a_txt_7.setAutoDraw(true);
    }
    
    
    // if p9a_txt_7 is active this frame...
    if (p9a_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_8* updates
    if (t >= 0.0 && p9a_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_8.tStart = t;  // (not accounting for frame time here)
      p9a_txt_8.frameNStart = frameN;  // exact frame index
      
      p9a_txt_8.setAutoDraw(true);
    }
    
    
    // if p9a_txt_8 is active this frame...
    if (p9a_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_9* updates
    if (t >= 0.0 && p9a_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_9.tStart = t;  // (not accounting for frame time here)
      p9a_txt_9.frameNStart = frameN;  // exact frame index
      
      p9a_txt_9.setAutoDraw(true);
    }
    
    
    // if p9a_txt_9 is active this frame...
    if (p9a_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_10* updates
    if (t >= 0.0 && p9a_txt_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_10.tStart = t;  // (not accounting for frame time here)
      p9a_txt_10.frameNStart = frameN;  // exact frame index
      
      p9a_txt_10.setAutoDraw(true);
    }
    
    
    // if p9a_txt_10 is active this frame...
    if (p9a_txt_10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_11* updates
    if (t >= 0.0 && p9a_txt_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_11.tStart = t;  // (not accounting for frame time here)
      p9a_txt_11.frameNStart = frameN;  // exact frame index
      
      p9a_txt_11.setAutoDraw(true);
    }
    
    
    // if p9a_txt_11 is active this frame...
    if (p9a_txt_11.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_12* updates
    if (t >= 0.0 && p9a_txt_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_12.tStart = t;  // (not accounting for frame time here)
      p9a_txt_12.frameNStart = frameN;  // exact frame index
      
      p9a_txt_12.setAutoDraw(true);
    }
    
    
    // if p9a_txt_12 is active this frame...
    if (p9a_txt_12.status === PsychoJS.Status.STARTED) {
    }
    
    // *p9a_mouse* updates
    if (t >= 0 && p9a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_mouse.tStart = t;  // (not accounting for frame time here)
      p9a_mouse.frameNStart = frameN;  // exact frame index
      
      p9a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p9a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p9a_mouse is active this frame...
    if (p9a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p9a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9a_mouse.clickableObjects = eval([p9a_sq_1, p9a_sq_2, p9a_sq_3, p9a_sq_4, p9a_sq_5, p9a_sq_6, p9a_sq_7, p9a_sq_8, p9a_sq_9, p9a_sq_10, p9a_sq_11, p9a_sq_12, p9a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9a_mouse.clickableObjects)) {
              p9a_mouse.clickableObjects = [p9a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9a_mouse.clickableObjects) {
              if (obj.contains(p9a_mouse)) {
                  gotValidClick = true;
                  p9a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9a_mouse.clickableObjects = eval([p9a_sq_1, p9a_sq_2, p9a_sq_3, p9a_sq_4, p9a_sq_5, p9a_sq_6, p9a_sq_7, p9a_sq_8, p9a_sq_9, p9a_sq_10, p9a_sq_11, p9a_sq_12, p9a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9a_mouse.clickableObjects)) {
              p9a_mouse.clickableObjects = [p9a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9a_mouse.clickableObjects) {
              if (obj.contains(p9a_mouse)) {
                  gotValidClick = true;
                  p9a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p9a_mouse.getPos();
            p9a_mouse.x.push(_mouseXYs[0]);
            p9a_mouse.y.push(_mouseXYs[1]);
            p9a_mouse.leftButton.push(_mouseButtons[0]);
            p9a_mouse.midButton.push(_mouseButtons[1]);
            p9a_mouse.rightButton.push(_mouseButtons[2]);
            p9a_mouse.time.push(p9a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p9a_txt_q* updates
    if (t >= 0.0 && p9a_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_q.tStart = t;  // (not accounting for frame time here)
      p9a_txt_q.frameNStart = frameN;  // exact frame index
      
      p9a_txt_q.setAutoDraw(true);
    }
    
    
    // if p9a_txt_q is active this frame...
    if (p9a_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_box_next* updates
    if (t >= 0 && p9a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_box_next.tStart = t;  // (not accounting for frame time here)
      p9a_box_next.frameNStart = frameN;  // exact frame index
      
      p9a_box_next.setAutoDraw(true);
    }
    
    
    // if p9a_box_next is active this frame...
    if (p9a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_next* updates
    if (t >= 0 && p9a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_next.tStart = t;  // (not accounting for frame time here)
      p9a_txt_next.frameNStart = frameN;  // exact frame index
      
      p9a_txt_next.setAutoDraw(true);
    }
    
    
    // if p9a_txt_next is active this frame...
    if (p9a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_box_try* updates
    if (t >= 0 && p9a_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_box_try.tStart = t;  // (not accounting for frame time here)
      p9a_box_try.frameNStart = frameN;  // exact frame index
      
      p9a_box_try.setAutoDraw(true);
    }
    
    
    // if p9a_box_try is active this frame...
    if (p9a_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9a_txt_try* updates
    if (t >= 0 && p9a_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9a_txt_try.tStart = t;  // (not accounting for frame time here)
      p9a_txt_try.frameNStart = frameN;  // exact frame index
      
      p9a_txt_try.setAutoDraw(true);
    }
    
    
    // if p9a_txt_try is active this frame...
    if (p9a_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9_ST_monthComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9_ST_monthRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9_ST_month' ---
    p9_ST_monthComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9_ST_month.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p9a_mouse.x', p9a_mouse.x);
    psychoJS.experiment.addData('p9a_mouse.y', p9a_mouse.y);
    psychoJS.experiment.addData('p9a_mouse.leftButton', p9a_mouse.leftButton);
    psychoJS.experiment.addData('p9a_mouse.midButton', p9a_mouse.midButton);
    psychoJS.experiment.addData('p9a_mouse.rightButton', p9a_mouse.rightButton);
    psychoJS.experiment.addData('p9a_mouse.time', p9a_mouse.time);
    psychoJS.experiment.addData('p9a_mouse.clicked_name', p9a_mouse.clicked_name);
    
    // Run 'End Routine' code from p9a_code_ans
    psychoJS.experiment.addData('p9a_isCorrect',p9a_isCorrect)
    psychoJS.experiment.addData('p9a_ans', p9a_ans)
    psychoJS.experiment.addData('p9a_ans_Idx', p9a_ans_Idx)
    psychoJS.experiment.addData('p9a_corrAns',p9a_corrAns)
    psychoJS.experiment.addData('p9a_corrAns_Idx',p9a_corrAns_Idx)
    psychoJS.experiment.addData('p9a_countNext',p9a_countNext)
    psychoJS.experiment.addData('p9a_points',p9a_points)
    // the Routine "p9_ST_month" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9a_inTimeMaxDurationReached;
var p9a_inTimeMaxDuration;
var p9a_inTimeComponents;
function p9a_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9a_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9a_inTimeClock.reset();
    routineTimer.reset();
    p9a_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p9a_inTime.started', globalClock.getTime());
    p9a_inTimeMaxDuration = null
    // keep track of which components have finished
    p9a_inTimeComponents = [];
    
    p9a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9a_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9a_inTime' ---
    // get current time
    t = p9a_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9a_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9a_inTime' ---
    p9a_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9a_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p9a_code_inTime
    psychoJS.experiment.addData("p9a_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p9a_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9_ST_yearMaxDurationReached;
var p9b_keyID;
var p9_ST_yearMaxDuration;
var p9_ST_yearComponents;
function p9_ST_yearRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9_ST_year' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9_ST_yearClock.reset();
    routineTimer.reset();
    p9_ST_yearMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p9b_code
    p9b_keyID = [p9b_key_1, p9b_key_2, p9b_key_3, p9b_key_4, p9b_key_5, p9b_key_6, p9b_key_7, p9b_key_8, p9b_key_9, p9b_key_0, p9b_key_DEL];
    k = 0;
    if ((p9b_mouse.isPressedIn(p9b_box_next) && (lenString_p9b === 4))) {
        p9b_countNext = (p9b_countNext + 1);
        if ((p9b_ans === p9b_corrAns)) {
            p9b_isCorrect = 1;
            p9b_points = 1;
        } else {
            p9b_isCorrect = 0;
            p9b_points = 0;
        }
        loop_waitTillOK_p9b.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p9b_mouse.isPressedIn(p9b_box_next) && (lenString_p9b < 4))) {
            p9b_countNext = (p9b_countNext + 1);
            p9b_opTryBox = 1;
            p9b_opTryTxt = 1;
            p9b_opNextBox = 0;
            p9b_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p9b_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p9b_mouse.isPressedIn(thisKey)) {
                    if ((lenString_p9b < 4)) {
                        p9b_ans = (p9b_ans + p9b_keyNum[k]);
                        lenString_p9b = (lenString_p9b + 1);
                        p9b_screen_txt.text = p9b_ans;
                        p9b_opTryBox = 0;
                        p9b_opTryTxt = 0;
                        p9b_opNextBox = 1;
                        p9b_opNextTxt = 1;
                    }
                    if ((p9b_keyNum[k] === "DEL")) {
                        p9b_ans = "";
                        lenString_p9b = 0;
                        p9b_screen_txt.text = p9b_ans;
                        p9b_isCorrect = 0;
                        p9b_opTryBox = 0;
                        p9b_opTryTxt = 0;
                        p9b_opNextBox = 1;
                        p9b_opNextTxt = 1;
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p9b_mouse
    // current position of the mouse:
    p9b_mouse.x = [];
    p9b_mouse.y = [];
    p9b_mouse.leftButton = [];
    p9b_mouse.midButton = [];
    p9b_mouse.rightButton = [];
    p9b_mouse.time = [];
    p9b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p9b_mouse.mouseClock.reset();
    p9b_screen_txt.setText(p9b_ans);
    p9b_box_next.setFillColor(new util.Color(BoxNextColor));
    p9b_box_next.setOpacity(p9b_opNextBox);
    p9b_box_next.setLineColor(new util.Color(cGrey));
    p9b_txt_next.setOpacity(p9b_opNextTxt);
    p9b_box_try.setFillColor(new util.Color(BoxTryColor));
    p9b_box_try.setOpacity(p9b_opTryBox);
    p9b_box_try.setLineColor(new util.Color(cGrey));
    p9b_txt_try.setOpacity(p9b_opTryTxt);
    psychoJS.experiment.addData('p9_ST_year.started', globalClock.getTime());
    p9_ST_yearMaxDuration = null
    // keep track of which components have finished
    p9_ST_yearComponents = [];
    p9_ST_yearComponents.push(p9b_txt_q);
    p9_ST_yearComponents.push(p9b_mouse);
    p9_ST_yearComponents.push(p9b_screen_box);
    p9_ST_yearComponents.push(p9b_screen_txt);
    p9_ST_yearComponents.push(p9b_key_1);
    p9_ST_yearComponents.push(p9b_key_2);
    p9_ST_yearComponents.push(p9b_key_3);
    p9_ST_yearComponents.push(p9b_key_4);
    p9_ST_yearComponents.push(p9b_key_5);
    p9_ST_yearComponents.push(p9b_key_6);
    p9_ST_yearComponents.push(p9b_key_7);
    p9_ST_yearComponents.push(p9b_key_8);
    p9_ST_yearComponents.push(p9b_key_9);
    p9_ST_yearComponents.push(p9b_key_0);
    p9_ST_yearComponents.push(p9b_key_DEL);
    p9_ST_yearComponents.push(p9b_box_next);
    p9_ST_yearComponents.push(p9b_txt_next);
    p9_ST_yearComponents.push(p9b_box_try);
    p9_ST_yearComponents.push(p9b_txt_try);
    p9_ST_yearComponents.push(p9b_key_txt_1);
    p9_ST_yearComponents.push(p9b_key_txt_2);
    p9_ST_yearComponents.push(p9b_key_txt_3);
    p9_ST_yearComponents.push(p9b_key_txt_4);
    p9_ST_yearComponents.push(p9b_key_txt_5);
    p9_ST_yearComponents.push(p9b_key_txt_6);
    p9_ST_yearComponents.push(p9b_key_txt_7);
    p9_ST_yearComponents.push(p9b_key_txt_8);
    p9_ST_yearComponents.push(p9b_key_txt_9);
    p9_ST_yearComponents.push(p9b_key_txt_0);
    p9_ST_yearComponents.push(p9b_key_txt_DEL);
    
    p9_ST_yearComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9_ST_yearRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9_ST_year' ---
    // get current time
    t = p9_ST_yearClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p9b_txt_q* updates
    if (t >= 0.0 && p9b_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_txt_q.tStart = t;  // (not accounting for frame time here)
      p9b_txt_q.frameNStart = frameN;  // exact frame index
      
      p9b_txt_q.setAutoDraw(true);
    }
    
    
    // if p9b_txt_q is active this frame...
    if (p9b_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    // *p9b_mouse* updates
    if (t >= 0.0 && p9b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_mouse.tStart = t;  // (not accounting for frame time here)
      p9b_mouse.frameNStart = frameN;  // exact frame index
      
      p9b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p9b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p9b_mouse is active this frame...
    if (p9b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p9b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9b_mouse.clickableObjects = eval([p9b_key_1, p9b_key_2, p9b_key_3, p9b_key_4, p9b_key_5, p9b_key_6, p9b_key_7, p9b_key_8, p9b_key_9, p9b_key_0, p9b_key_DEL, p9b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9b_mouse.clickableObjects)) {
              p9b_mouse.clickableObjects = [p9b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9b_mouse.clickableObjects) {
              if (obj.contains(p9b_mouse)) {
                  gotValidClick = true;
                  p9b_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9b_mouse.clickableObjects = eval([p9b_key_1, p9b_key_2, p9b_key_3, p9b_key_4, p9b_key_5, p9b_key_6, p9b_key_7, p9b_key_8, p9b_key_9, p9b_key_0, p9b_key_DEL, p9b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9b_mouse.clickableObjects)) {
              p9b_mouse.clickableObjects = [p9b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9b_mouse.clickableObjects) {
              if (obj.contains(p9b_mouse)) {
                  gotValidClick = true;
                  p9b_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p9b_mouse.getPos();
            p9b_mouse.x.push(_mouseXYs[0]);
            p9b_mouse.y.push(_mouseXYs[1]);
            p9b_mouse.leftButton.push(_mouseButtons[0]);
            p9b_mouse.midButton.push(_mouseButtons[1]);
            p9b_mouse.rightButton.push(_mouseButtons[2]);
            p9b_mouse.time.push(p9b_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p9b_screen_box* updates
    if (t >= 0.0 && p9b_screen_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_screen_box.tStart = t;  // (not accounting for frame time here)
      p9b_screen_box.frameNStart = frameN;  // exact frame index
      
      p9b_screen_box.setAutoDraw(true);
    }
    
    
    // if p9b_screen_box is active this frame...
    if (p9b_screen_box.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_screen_txt* updates
    if (t >= 0.0 && p9b_screen_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_screen_txt.tStart = t;  // (not accounting for frame time here)
      p9b_screen_txt.frameNStart = frameN;  // exact frame index
      
      p9b_screen_txt.setAutoDraw(true);
    }
    
    
    // if p9b_screen_txt is active this frame...
    if (p9b_screen_txt.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_1* updates
    if (t >= 0.0 && p9b_key_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_1.tStart = t;  // (not accounting for frame time here)
      p9b_key_1.frameNStart = frameN;  // exact frame index
      
      p9b_key_1.setAutoDraw(true);
    }
    
    
    // if p9b_key_1 is active this frame...
    if (p9b_key_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_2* updates
    if (t >= 0.0 && p9b_key_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_2.tStart = t;  // (not accounting for frame time here)
      p9b_key_2.frameNStart = frameN;  // exact frame index
      
      p9b_key_2.setAutoDraw(true);
    }
    
    
    // if p9b_key_2 is active this frame...
    if (p9b_key_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_3* updates
    if (t >= 0.0 && p9b_key_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_3.tStart = t;  // (not accounting for frame time here)
      p9b_key_3.frameNStart = frameN;  // exact frame index
      
      p9b_key_3.setAutoDraw(true);
    }
    
    
    // if p9b_key_3 is active this frame...
    if (p9b_key_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_4* updates
    if (t >= 0.0 && p9b_key_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_4.tStart = t;  // (not accounting for frame time here)
      p9b_key_4.frameNStart = frameN;  // exact frame index
      
      p9b_key_4.setAutoDraw(true);
    }
    
    
    // if p9b_key_4 is active this frame...
    if (p9b_key_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_5* updates
    if (t >= 0.0 && p9b_key_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_5.tStart = t;  // (not accounting for frame time here)
      p9b_key_5.frameNStart = frameN;  // exact frame index
      
      p9b_key_5.setAutoDraw(true);
    }
    
    
    // if p9b_key_5 is active this frame...
    if (p9b_key_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_6* updates
    if (t >= 0.0 && p9b_key_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_6.tStart = t;  // (not accounting for frame time here)
      p9b_key_6.frameNStart = frameN;  // exact frame index
      
      p9b_key_6.setAutoDraw(true);
    }
    
    
    // if p9b_key_6 is active this frame...
    if (p9b_key_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_7* updates
    if (t >= 0.0 && p9b_key_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_7.tStart = t;  // (not accounting for frame time here)
      p9b_key_7.frameNStart = frameN;  // exact frame index
      
      p9b_key_7.setAutoDraw(true);
    }
    
    
    // if p9b_key_7 is active this frame...
    if (p9b_key_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_8* updates
    if (t >= 0.0 && p9b_key_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_8.tStart = t;  // (not accounting for frame time here)
      p9b_key_8.frameNStart = frameN;  // exact frame index
      
      p9b_key_8.setAutoDraw(true);
    }
    
    
    // if p9b_key_8 is active this frame...
    if (p9b_key_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_9* updates
    if (t >= 0.0 && p9b_key_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_9.tStart = t;  // (not accounting for frame time here)
      p9b_key_9.frameNStart = frameN;  // exact frame index
      
      p9b_key_9.setAutoDraw(true);
    }
    
    
    // if p9b_key_9 is active this frame...
    if (p9b_key_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_0* updates
    if (t >= 0.0 && p9b_key_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_0.tStart = t;  // (not accounting for frame time here)
      p9b_key_0.frameNStart = frameN;  // exact frame index
      
      p9b_key_0.setAutoDraw(true);
    }
    
    
    // if p9b_key_0 is active this frame...
    if (p9b_key_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_DEL* updates
    if (t >= 0.0 && p9b_key_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_DEL.tStart = t;  // (not accounting for frame time here)
      p9b_key_DEL.frameNStart = frameN;  // exact frame index
      
      p9b_key_DEL.setAutoDraw(true);
    }
    
    
    // if p9b_key_DEL is active this frame...
    if (p9b_key_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_box_next* updates
    if (t >= 0.0 && p9b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_box_next.tStart = t;  // (not accounting for frame time here)
      p9b_box_next.frameNStart = frameN;  // exact frame index
      
      p9b_box_next.setAutoDraw(true);
    }
    
    
    // if p9b_box_next is active this frame...
    if (p9b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_txt_next* updates
    if (t >= 0.0 && p9b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_txt_next.tStart = t;  // (not accounting for frame time here)
      p9b_txt_next.frameNStart = frameN;  // exact frame index
      
      p9b_txt_next.setAutoDraw(true);
    }
    
    
    // if p9b_txt_next is active this frame...
    if (p9b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_box_try* updates
    if (t >= 0.0 && p9b_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_box_try.tStart = t;  // (not accounting for frame time here)
      p9b_box_try.frameNStart = frameN;  // exact frame index
      
      p9b_box_try.setAutoDraw(true);
    }
    
    
    // if p9b_box_try is active this frame...
    if (p9b_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_txt_try* updates
    if (t >= 0.0 && p9b_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_txt_try.tStart = t;  // (not accounting for frame time here)
      p9b_txt_try.frameNStart = frameN;  // exact frame index
      
      p9b_txt_try.setAutoDraw(true);
    }
    
    
    // if p9b_txt_try is active this frame...
    if (p9b_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_1* updates
    if (t >= 0.0 && p9b_key_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_1.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_1.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_1.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_1 is active this frame...
    if (p9b_key_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_2* updates
    if (t >= 0.0 && p9b_key_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_2.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_2.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_2.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_2 is active this frame...
    if (p9b_key_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_3* updates
    if (t >= 0.0 && p9b_key_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_3.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_3.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_3.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_3 is active this frame...
    if (p9b_key_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_4* updates
    if (t >= 0.0 && p9b_key_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_4.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_4.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_4.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_4 is active this frame...
    if (p9b_key_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_5* updates
    if (t >= 0.0 && p9b_key_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_5.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_5.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_5.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_5 is active this frame...
    if (p9b_key_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_6* updates
    if (t >= 0.0 && p9b_key_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_6.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_6.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_6.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_6 is active this frame...
    if (p9b_key_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_7* updates
    if (t >= 0.0 && p9b_key_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_7.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_7.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_7.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_7 is active this frame...
    if (p9b_key_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_8* updates
    if (t >= 0.0 && p9b_key_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_8.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_8.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_8.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_8 is active this frame...
    if (p9b_key_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_9* updates
    if (t >= 0.0 && p9b_key_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_9.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_9.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_9.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_9 is active this frame...
    if (p9b_key_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_0* updates
    if (t >= 0.0 && p9b_key_txt_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_0.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_0.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_0.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_0 is active this frame...
    if (p9b_key_txt_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9b_key_txt_DEL* updates
    if (t >= 0.0 && p9b_key_txt_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9b_key_txt_DEL.tStart = t;  // (not accounting for frame time here)
      p9b_key_txt_DEL.frameNStart = frameN;  // exact frame index
      
      p9b_key_txt_DEL.setAutoDraw(true);
    }
    
    
    // if p9b_key_txt_DEL is active this frame...
    if (p9b_key_txt_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9_ST_yearComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9_ST_yearRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9_ST_year' ---
    p9_ST_yearComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9_ST_year.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p9b_mouse.x', p9b_mouse.x);
    psychoJS.experiment.addData('p9b_mouse.y', p9b_mouse.y);
    psychoJS.experiment.addData('p9b_mouse.leftButton', p9b_mouse.leftButton);
    psychoJS.experiment.addData('p9b_mouse.midButton', p9b_mouse.midButton);
    psychoJS.experiment.addData('p9b_mouse.rightButton', p9b_mouse.rightButton);
    psychoJS.experiment.addData('p9b_mouse.time', p9b_mouse.time);
    psychoJS.experiment.addData('p9b_mouse.clicked_name', p9b_mouse.clicked_name);
    
    // Run 'End Routine' code from p9b_code_ans
    psychoJS.experiment.addData('p9b_isCorrect',p9b_isCorrect)
    psychoJS.experiment.addData('p9b_ans', p9b_ans)
    psychoJS.experiment.addData('p9b_corrAns',p9b_corrAns)
    psychoJS.experiment.addData('p9b_countNext',p9b_countNext)
    psychoJS.experiment.addData('p9b_points',p9b_points)
    // the Routine "p9_ST_year" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9b_inTimeMaxDurationReached;
var p9b_inTimeMaxDuration;
var p9b_inTimeComponents;
function p9b_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9b_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9b_inTimeClock.reset();
    routineTimer.reset();
    p9b_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p9b_inTime.started', globalClock.getTime());
    p9b_inTimeMaxDuration = null
    // keep track of which components have finished
    p9b_inTimeComponents = [];
    
    p9b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9b_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9b_inTime' ---
    // get current time
    t = p9b_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9b_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9b_inTime' ---
    p9b_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9b_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p9b_code_inTime
    psychoJS.experiment.addData("p9b_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p9b_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9_ST_dayMaxDurationReached;
var p9c_stimID;
var p9_ST_dayMaxDuration;
var p9_ST_dayComponents;
function p9_ST_dayRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9_ST_day' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9_ST_dayClock.reset();
    routineTimer.reset();
    p9_ST_dayMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p9c_code
    p9c_stimID = [p9c_sq_1, p9c_sq_2, p9c_sq_3, p9c_sq_4, p9c_sq_5, p9c_sq_6, p9c_sq_7];
    k = 0;
    i = 0;
    if ((p9c_mouse.isPressedIn(p9c_box_next) && (util.sum(p9c_isPicked) === 1))) {
        p9c_countNext = (p9c_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p9c_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p9c_ans_Idx = (p9c_ans_Idx + [i]);
                p9c_ans = p9c_words[i];
            }
            i = (i + 1);
        }
        if ((p9c_ans === p9c_corrAns)) {
            p9c_isCorrect = 1;
            p9c_points = 1;
        } else {
            p9c_isCorrect = 0;
            p9c_points = 0;
        }
        loop_waitTillOK_p9c.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p9c_mouse.isPressedIn(p9c_box_next) && (util.sum(p9c_isPicked) !== 1))) {
            p9c_opTryBox = 1;
            p9c_opTryTxt = 1;
            p9c_opNextBox = 0;
            p9c_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p9c_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p9c_mouse.isPressedIn(thisStim) && (p9c_isPicked[k] === 0))) {
                    p9c_stimColors[k] = cAzul;
                    p9c_isPicked[k] = 1;
                    p9c_opTryBox = 0;
                    p9c_opTryTxt = 0;
                    p9c_opNextBox = 1;
                    p9c_opNextTxt = 1;
                } else {
                    p9c_stimColors[k] = cGrey;
                    p9c_isPicked[k] = 0;
                    p9c_opTryBox = 0;
                    p9c_opTryTxt = 0;
                    p9c_opNextBox = 1;
                    p9c_opNextTxt = 1;
                }
            }
        }
    }
    
    p9c_sq_1.setFillColor(new util.Color(p9c_stimColors[1]));
    p9c_sq_2.setFillColor(new util.Color(p9c_stimColors[2]));
    p9c_sq_3.setFillColor(new util.Color(p9c_stimColors[3]));
    p9c_sq_4.setFillColor(new util.Color(p9c_stimColors[4]));
    p9c_sq_5.setFillColor(new util.Color(p9c_stimColors[5]));
    p9c_sq_6.setFillColor(new util.Color(p9c_stimColors[6]));
    p9c_sq_7.setFillColor(new util.Color(p9c_stimColors[7]));
    p9c_txt_1.setText(p9c_words[1]);
    p9c_txt_2.setText(p9c_words[2]);
    p9c_txt_3.setText(p9c_words[3]);
    p9c_txt_4.setText(p9c_words[4]);
    p9c_txt_5.setText(p9c_words[5]);
    p9c_txt_6.setText(p9c_words[6]);
    p9c_txt_7.setText(p9c_words[7]);
    // setup some python lists for storing info about the p9c_mouse
    // current position of the mouse:
    p9c_mouse.x = [];
    p9c_mouse.y = [];
    p9c_mouse.leftButton = [];
    p9c_mouse.midButton = [];
    p9c_mouse.rightButton = [];
    p9c_mouse.time = [];
    p9c_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p9c_mouse.mouseClock.reset();
    p9c_box_next.setFillColor(new util.Color(BoxNextColor));
    p9c_box_next.setOpacity(p9c_opNextBox);
    p9c_box_next.setLineColor(new util.Color(cGrey));
    p9c_txt_next.setOpacity(p9c_opNextTxt);
    p9c_box_try.setFillColor(new util.Color(BoxTryColor));
    p9c_box_try.setOpacity(p9c_opTryBox);
    p9c_box_try.setLineColor(new util.Color(cGrey));
    p9c_txt_try.setOpacity(p9c_opTryTxt);
    psychoJS.experiment.addData('p9_ST_day.started', globalClock.getTime());
    p9_ST_dayMaxDuration = null
    // keep track of which components have finished
    p9_ST_dayComponents = [];
    p9_ST_dayComponents.push(p9c_sq_1);
    p9_ST_dayComponents.push(p9c_sq_2);
    p9_ST_dayComponents.push(p9c_sq_3);
    p9_ST_dayComponents.push(p9c_sq_4);
    p9_ST_dayComponents.push(p9c_sq_5);
    p9_ST_dayComponents.push(p9c_sq_6);
    p9_ST_dayComponents.push(p9c_sq_7);
    p9_ST_dayComponents.push(p9c_txt_1);
    p9_ST_dayComponents.push(p9c_txt_2);
    p9_ST_dayComponents.push(p9c_txt_3);
    p9_ST_dayComponents.push(p9c_txt_4);
    p9_ST_dayComponents.push(p9c_txt_5);
    p9_ST_dayComponents.push(p9c_txt_6);
    p9_ST_dayComponents.push(p9c_txt_7);
    p9_ST_dayComponents.push(p9c_mouse);
    p9_ST_dayComponents.push(p9c_txt_q);
    p9_ST_dayComponents.push(p9c_box_next);
    p9_ST_dayComponents.push(p9c_txt_next);
    p9_ST_dayComponents.push(p9c_box_try);
    p9_ST_dayComponents.push(p9c_txt_try);
    
    p9_ST_dayComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9_ST_dayRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9_ST_day' ---
    // get current time
    t = p9_ST_dayClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p9c_sq_1* updates
    if (t >= 0.0 && p9c_sq_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_1.tStart = t;  // (not accounting for frame time here)
      p9c_sq_1.frameNStart = frameN;  // exact frame index
      
      p9c_sq_1.setAutoDraw(true);
    }
    
    
    // if p9c_sq_1 is active this frame...
    if (p9c_sq_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_2* updates
    if (t >= 0.0 && p9c_sq_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_2.tStart = t;  // (not accounting for frame time here)
      p9c_sq_2.frameNStart = frameN;  // exact frame index
      
      p9c_sq_2.setAutoDraw(true);
    }
    
    
    // if p9c_sq_2 is active this frame...
    if (p9c_sq_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_3* updates
    if (t >= 0.0 && p9c_sq_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_3.tStart = t;  // (not accounting for frame time here)
      p9c_sq_3.frameNStart = frameN;  // exact frame index
      
      p9c_sq_3.setAutoDraw(true);
    }
    
    
    // if p9c_sq_3 is active this frame...
    if (p9c_sq_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_4* updates
    if (t >= 0.0 && p9c_sq_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_4.tStart = t;  // (not accounting for frame time here)
      p9c_sq_4.frameNStart = frameN;  // exact frame index
      
      p9c_sq_4.setAutoDraw(true);
    }
    
    
    // if p9c_sq_4 is active this frame...
    if (p9c_sq_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_5* updates
    if (t >= 0.0 && p9c_sq_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_5.tStart = t;  // (not accounting for frame time here)
      p9c_sq_5.frameNStart = frameN;  // exact frame index
      
      p9c_sq_5.setAutoDraw(true);
    }
    
    
    // if p9c_sq_5 is active this frame...
    if (p9c_sq_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_6* updates
    if (t >= 0.0 && p9c_sq_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_6.tStart = t;  // (not accounting for frame time here)
      p9c_sq_6.frameNStart = frameN;  // exact frame index
      
      p9c_sq_6.setAutoDraw(true);
    }
    
    
    // if p9c_sq_6 is active this frame...
    if (p9c_sq_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_sq_7* updates
    if (t >= 0.0 && p9c_sq_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_sq_7.tStart = t;  // (not accounting for frame time here)
      p9c_sq_7.frameNStart = frameN;  // exact frame index
      
      p9c_sq_7.setAutoDraw(true);
    }
    
    
    // if p9c_sq_7 is active this frame...
    if (p9c_sq_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_1* updates
    if (t >= 0.0 && p9c_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_1.tStart = t;  // (not accounting for frame time here)
      p9c_txt_1.frameNStart = frameN;  // exact frame index
      
      p9c_txt_1.setAutoDraw(true);
    }
    
    
    // if p9c_txt_1 is active this frame...
    if (p9c_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_2* updates
    if (t >= 0.0 && p9c_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_2.tStart = t;  // (not accounting for frame time here)
      p9c_txt_2.frameNStart = frameN;  // exact frame index
      
      p9c_txt_2.setAutoDraw(true);
    }
    
    
    // if p9c_txt_2 is active this frame...
    if (p9c_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_3* updates
    if (t >= 0.0 && p9c_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_3.tStart = t;  // (not accounting for frame time here)
      p9c_txt_3.frameNStart = frameN;  // exact frame index
      
      p9c_txt_3.setAutoDraw(true);
    }
    
    
    // if p9c_txt_3 is active this frame...
    if (p9c_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_4* updates
    if (t >= 0.0 && p9c_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_4.tStart = t;  // (not accounting for frame time here)
      p9c_txt_4.frameNStart = frameN;  // exact frame index
      
      p9c_txt_4.setAutoDraw(true);
    }
    
    
    // if p9c_txt_4 is active this frame...
    if (p9c_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_5* updates
    if (t >= 0.0 && p9c_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_5.tStart = t;  // (not accounting for frame time here)
      p9c_txt_5.frameNStart = frameN;  // exact frame index
      
      p9c_txt_5.setAutoDraw(true);
    }
    
    
    // if p9c_txt_5 is active this frame...
    if (p9c_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_6* updates
    if (t >= 0.0 && p9c_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_6.tStart = t;  // (not accounting for frame time here)
      p9c_txt_6.frameNStart = frameN;  // exact frame index
      
      p9c_txt_6.setAutoDraw(true);
    }
    
    
    // if p9c_txt_6 is active this frame...
    if (p9c_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_7* updates
    if (t >= 0.0 && p9c_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_7.tStart = t;  // (not accounting for frame time here)
      p9c_txt_7.frameNStart = frameN;  // exact frame index
      
      p9c_txt_7.setAutoDraw(true);
    }
    
    
    // if p9c_txt_7 is active this frame...
    if (p9c_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    // *p9c_mouse* updates
    if (t >= 0 && p9c_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_mouse.tStart = t;  // (not accounting for frame time here)
      p9c_mouse.frameNStart = frameN;  // exact frame index
      
      p9c_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p9c_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p9c_mouse is active this frame...
    if (p9c_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p9c_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9c_mouse.clickableObjects = eval([p9c_sq_1, p9c_sq_2, p9c_sq_3, p9c_sq_4, p9c_sq_5, p9c_sq_6, p9c_sq_7, p9c_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9c_mouse.clickableObjects)) {
              p9c_mouse.clickableObjects = [p9c_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9c_mouse.clickableObjects) {
              if (obj.contains(p9c_mouse)) {
                  gotValidClick = true;
                  p9c_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p9c_mouse.clickableObjects = eval([p9c_sq_1, p9c_sq_2, p9c_sq_3, p9c_sq_4, p9c_sq_5, p9c_sq_6, p9c_sq_7, p9c_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p9c_mouse.clickableObjects)) {
              p9c_mouse.clickableObjects = [p9c_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p9c_mouse.clickableObjects) {
              if (obj.contains(p9c_mouse)) {
                  gotValidClick = true;
                  p9c_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p9c_mouse.getPos();
            p9c_mouse.x.push(_mouseXYs[0]);
            p9c_mouse.y.push(_mouseXYs[1]);
            p9c_mouse.leftButton.push(_mouseButtons[0]);
            p9c_mouse.midButton.push(_mouseButtons[1]);
            p9c_mouse.rightButton.push(_mouseButtons[2]);
            p9c_mouse.time.push(p9c_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p9c_txt_q* updates
    if (t >= 0.0 && p9c_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_q.tStart = t;  // (not accounting for frame time here)
      p9c_txt_q.frameNStart = frameN;  // exact frame index
      
      p9c_txt_q.setAutoDraw(true);
    }
    
    
    // if p9c_txt_q is active this frame...
    if (p9c_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_box_next* updates
    if (t >= 0 && p9c_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_box_next.tStart = t;  // (not accounting for frame time here)
      p9c_box_next.frameNStart = frameN;  // exact frame index
      
      p9c_box_next.setAutoDraw(true);
    }
    
    
    // if p9c_box_next is active this frame...
    if (p9c_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_next* updates
    if (t >= 0 && p9c_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_next.tStart = t;  // (not accounting for frame time here)
      p9c_txt_next.frameNStart = frameN;  // exact frame index
      
      p9c_txt_next.setAutoDraw(true);
    }
    
    
    // if p9c_txt_next is active this frame...
    if (p9c_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_box_try* updates
    if (t >= 0 && p9c_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_box_try.tStart = t;  // (not accounting for frame time here)
      p9c_box_try.frameNStart = frameN;  // exact frame index
      
      p9c_box_try.setAutoDraw(true);
    }
    
    
    // if p9c_box_try is active this frame...
    if (p9c_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p9c_txt_try* updates
    if (t >= 0 && p9c_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p9c_txt_try.tStart = t;  // (not accounting for frame time here)
      p9c_txt_try.frameNStart = frameN;  // exact frame index
      
      p9c_txt_try.setAutoDraw(true);
    }
    
    
    // if p9c_txt_try is active this frame...
    if (p9c_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9_ST_dayComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9_ST_dayRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9_ST_day' ---
    p9_ST_dayComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9_ST_day.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p9c_mouse.x', p9c_mouse.x);
    psychoJS.experiment.addData('p9c_mouse.y', p9c_mouse.y);
    psychoJS.experiment.addData('p9c_mouse.leftButton', p9c_mouse.leftButton);
    psychoJS.experiment.addData('p9c_mouse.midButton', p9c_mouse.midButton);
    psychoJS.experiment.addData('p9c_mouse.rightButton', p9c_mouse.rightButton);
    psychoJS.experiment.addData('p9c_mouse.time', p9c_mouse.time);
    psychoJS.experiment.addData('p9c_mouse.clicked_name', p9c_mouse.clicked_name);
    
    // Run 'End Routine' code from p9c_code_ans
    psychoJS.experiment.addData('p9c_isCorrect',p9c_isCorrect)
    psychoJS.experiment.addData('p9c_ans', p9c_ans)
    psychoJS.experiment.addData('p9c_ans_Idx', p9c_ans_Idx)
    psychoJS.experiment.addData('p9c_corrAns',p9c_corrAns)
    psychoJS.experiment.addData('p9c_corrAns_Idx',p9c_corrAns_Idx)
    psychoJS.experiment.addData('p9c_countNext',p9c_countNext)
    psychoJS.experiment.addData('p9c_points',p9c_points)
    // the Routine "p9_ST_day" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p9c_inTimeMaxDurationReached;
var p9c_inTimeMaxDuration;
var p9c_inTimeComponents;
function p9c_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p9c_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p9c_inTimeClock.reset();
    routineTimer.reset();
    p9c_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p9c_inTime.started', globalClock.getTime());
    p9c_inTimeMaxDuration = null
    // keep track of which components have finished
    p9c_inTimeComponents = [];
    
    p9c_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p9c_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p9c_inTime' ---
    // get current time
    t = p9c_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p9c_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p9c_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p9c_inTime' ---
    p9c_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p9c_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p9c_code_inTime
    psychoJS.experiment.addData("p9c_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p9c_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var bufferMaxDurationReached;
var bufferMaxDuration;
var bufferComponents;
function bufferRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'buffer' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    bufferClock.reset(routineTimer.getTime());
    routineTimer.add(0.150000);
    bufferMaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the mouse
    gotValidClick = false; // until a click is received
    psychoJS.experiment.addData('buffer.started', globalClock.getTime());
    bufferMaxDuration = null
    // keep track of which components have finished
    bufferComponents = [];
    bufferComponents.push(text);
    bufferComponents.push(mouse);
    
    bufferComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function bufferRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'buffer' ---
    // get current time
    t = bufferClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text* updates
    if (t >= 0.0 && text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text.tStart = t;  // (not accounting for frame time here)
      text.frameNStart = frameN;  // exact frame index
      
      text.setAutoDraw(true);
    }
    
    
    // if text is active this frame...
    if (text.status === PsychoJS.Status.STARTED) {
    }
    
    frameRemains = 0.0 + 0.15 - psychoJS.window.monitorFramePeriod * 0.75;// most of one frame period left
    if (text.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      // keep track of stop time/frame for later
      text.tStop = t;  // not accounting for scr refresh
      text.frameNStop = frameN;  // exact frame index
      // update status
      text.status = PsychoJS.Status.FINISHED;
      text.setAutoDraw(false);
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    bufferComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function bufferRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'buffer' ---
    bufferComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('buffer.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    _mouseXYs = mouse.getPos();
    _mouseButtons = mouse.getPressed();
    psychoJS.experiment.addData('mouse.x', _mouseXYs[0]);
    psychoJS.experiment.addData('mouse.y', _mouseXYs[1]);
    psychoJS.experiment.addData('mouse.leftButton', _mouseButtons[0]);
    psychoJS.experiment.addData('mouse.midButton', _mouseButtons[1]);
    psychoJS.experiment.addData('mouse.rightButton', _mouseButtons[2]);
    if (routineForceEnded) {
        routineTimer.reset();} else if (bufferMaxDurationReached) {
        bufferClock.add(bufferMaxDuration);
    } else {
        bufferClock.add(0.150000);
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p10_MEM_wordListMaxDurationReached;
var p10_stimID;
var p10_MEM_wordListMaxDuration;
var p10_MEM_wordListComponents;
function p10_MEM_wordListRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p10_MEM_wordList' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p10_MEM_wordListClock.reset();
    routineTimer.reset();
    p10_MEM_wordListMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p10_code
    p10_stimID = [p10_sq11, p10_sq21, p10_sq31, p10_sq41, p10_sq51, p10_sq61, p10_sq71, p10_sq81, p10_sq91, p10_sq101, p10_sq111, p10_sq121, p10_sq131, p10_sq141, p10_sq151, p10_sq161, p10_sq171, p10_sq12, p10_sq22, p10_sq32, p10_sq42, p10_sq52, p10_sq62, p10_sq72, p10_sq82, p10_sq92, p10_sq102, p10_sq112, p10_sq122, p10_sq132, p10_sq142, p10_sq152, p10_sq162, p10_sq172, p10_sq13, p10_sq23, p10_sq33, p10_sq43, p10_sq53, p10_sq63, p10_sq73, p10_sq83, p10_sq93, p10_sq103, p10_sq113, p10_sq123, p10_sq133, p10_sq143, p10_sq153, p10_sq163, p10_sq173, p10_sq14, p10_sq24, p10_sq34, p10_sq44, p10_sq54, p10_sq64, p10_sq74, p10_sq84, p10_sq94, p10_sq104, p10_sq114, p10_sq124, p10_sq134, p10_sq144, p10_sq154, p10_sq164, p10_sq174, p10_sq15, p10_sq25, p10_sq35, p10_sq45, p10_sq55, p10_sq65, p10_sq75, p10_sq85, p10_sq95, p10_sq105, p10_sq115, p10_sq125, p10_sq135, p10_sq145, p10_sq155, p10_sq165, p10_sq175, p10_sq16, p10_sq26, p10_sq36, p10_sq46, p10_sq56, p10_sq66, p10_sq76, p10_sq86, p10_sq96, p10_sq106, p10_sq116, p10_sq126, p10_sq136, p10_sq146, p10_sq156];
    k = 0;
    i = 0;
    if ((p10_mouse.isPressedIn(p10_box_next) && (util.sum(p10_isPicked) === 5))) {
        p10_countNext = (p10_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p10_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p10_ans_Idx = (p10_ans_Idx + [i]);
                p10_ans = ((p10_ans + ",") + p10_words[i]);
                p10_countCorrect = (p10_countCorrect + (val * p10_corrAns_Vec[i]));
            }
            i = (i + 1);
            (p10_points === p10_countCorrect);
        }
        if (((p10_countCorrect > 0) && (p10_countCorrect <= util.sum(p10_corrAns_Vec)))) {
            p10_isCorrect = 1;
            p10_points = p10_countCorrect;
        } else {
            p10_isCorrect = 0;
            p10_points = 0;
        }
        loop_waitTillOK_p10.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p10_mouse.isPressedIn(p10_box_next) && (util.sum(p10_isPicked) > 5))) {
            p10_countNext = (p10_countNext + 1);
            p10_opTryBox = 1;
            p10_opTryManyTxt = 1;
            p10_opTryTxt = 0;
            p10_opNextBox = 0;
            p10_opNextTxt = 0;
        } else {
            if ((p10_mouse.isPressedIn(p10_box_next) && (util.sum(p10_isPicked) < 5))) {
                p10_countNext = (p10_countNext + 1);
                p10_opTryBox = 1;
                p10_opTryTxt = 1;
                p10_opTryManyTxt = 0;
                p10_opNextBox = 0;
                p10_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p10_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p10_mouse.isPressedIn(thisStim) && (p10_isPicked[k] === 0))) {
                        p10_stimColors[k] = cAzul;
                        p10_isPicked[k] = 1;
                        p10_opTryBox = 0;
                        p10_opTryTxt = 0;
                        p10_opTryManyTxt = 0;
                        p10_opNextBox = 1;
                        p10_opNextTxt = 1;
                    } else {
                        if ((p10_mouse.isPressedIn(thisStim) && (p10_isPicked[k] === 1))) {
                            p10_stimColors[k] = cGrey;
                            p10_isPicked[k] = 0;
                            p10_opTryBox = 0;
                            p10_opTryTxt = 0;
                            p10_opTryManyTxt = 0;
                            p10_opNextBox = 1;
                            p10_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p10_mouse
    // current position of the mouse:
    p10_mouse.x = [];
    p10_mouse.y = [];
    p10_mouse.leftButton = [];
    p10_mouse.midButton = [];
    p10_mouse.rightButton = [];
    p10_mouse.time = [];
    p10_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p10_mouse.mouseClock.reset();
    p10_sq11.setFillColor(new util.Color(p10_stimColors[1]));
    p10_sq21.setFillColor(new util.Color(p10_stimColors[2]));
    p10_sq31.setFillColor(new util.Color(p10_stimColors[3]));
    p10_sq41.setFillColor(new util.Color(p10_stimColors[4]));
    p10_sq51.setFillColor(new util.Color(p10_stimColors[5]));
    p10_sq61.setFillColor(new util.Color(p10_stimColors[6]));
    p10_sq71.setFillColor(new util.Color(p10_stimColors[7]));
    p10_sq81.setFillColor(new util.Color(p10_stimColors[8]));
    p10_sq91.setFillColor(new util.Color(p10_stimColors[9]));
    p10_sq101.setFillColor(new util.Color(p10_stimColors[10]));
    p10_sq111.setFillColor(new util.Color(p10_stimColors[11]));
    p10_sq121.setFillColor(new util.Color(p10_stimColors[12]));
    p10_sq131.setFillColor(new util.Color(p10_stimColors[13]));
    p10_sq141.setFillColor(new util.Color(p10_stimColors[14]));
    p10_sq151.setFillColor(new util.Color(p10_stimColors[15]));
    p10_sq161.setFillColor(new util.Color(p10_stimColors[16]));
    p10_sq171.setFillColor(new util.Color(p10_stimColors[17]));
    p10_sq12.setFillColor(new util.Color(p10_stimColors[18]));
    p10_sq22.setFillColor(new util.Color(p10_stimColors[19]));
    p10_sq32.setFillColor(new util.Color(p10_stimColors[20]));
    p10_sq42.setFillColor(new util.Color(p10_stimColors[21]));
    p10_sq52.setFillColor(new util.Color(p10_stimColors[22]));
    p10_sq62.setFillColor(new util.Color(p10_stimColors[23]));
    p10_sq72.setFillColor(new util.Color(p10_stimColors[24]));
    p10_sq82.setFillColor(new util.Color(p10_stimColors[25]));
    p10_sq92.setFillColor(new util.Color(p10_stimColors[26]));
    p10_sq102.setFillColor(new util.Color(p10_stimColors[27]));
    p10_sq112.setFillColor(new util.Color(p10_stimColors[28]));
    p10_sq122.setFillColor(new util.Color(p10_stimColors[29]));
    p10_sq132.setFillColor(new util.Color(p10_stimColors[30]));
    p10_sq142.setFillColor(new util.Color(p10_stimColors[31]));
    p10_sq152.setFillColor(new util.Color(p10_stimColors[32]));
    p10_sq162.setFillColor(new util.Color(p10_stimColors[33]));
    p10_sq172.setFillColor(new util.Color(p10_stimColors[34]));
    p10_sq13.setFillColor(new util.Color(p10_stimColors[35]));
    p10_sq23.setFillColor(new util.Color(p10_stimColors[36]));
    p10_sq33.setFillColor(new util.Color(p10_stimColors[37]));
    p10_sq43.setFillColor(new util.Color(p10_stimColors[38]));
    p10_sq53.setFillColor(new util.Color(p10_stimColors[39]));
    p10_sq63.setFillColor(new util.Color(p10_stimColors[40]));
    p10_sq73.setFillColor(new util.Color(p10_stimColors[41]));
    p10_sq83.setFillColor(new util.Color(p10_stimColors[42]));
    p10_sq93.setFillColor(new util.Color(p10_stimColors[43]));
    p10_sq103.setFillColor(new util.Color(p10_stimColors[44]));
    p10_sq113.setFillColor(new util.Color(p10_stimColors[45]));
    p10_sq123.setFillColor(new util.Color(p10_stimColors[46]));
    p10_sq133.setFillColor(new util.Color(p10_stimColors[47]));
    p10_sq143.setFillColor(new util.Color(p10_stimColors[48]));
    p10_sq153.setFillColor(new util.Color(p10_stimColors[49]));
    p10_sq163.setFillColor(new util.Color(p10_stimColors[50]));
    p10_sq173.setFillColor(new util.Color(p10_stimColors[51]));
    p10_sq14.setFillColor(new util.Color(p10_stimColors[52]));
    p10_sq24.setFillColor(new util.Color(p10_stimColors[53]));
    p10_sq34.setFillColor(new util.Color(p10_stimColors[54]));
    p10_sq44.setFillColor(new util.Color(p10_stimColors[55]));
    p10_sq54.setFillColor(new util.Color(p10_stimColors[56]));
    p10_sq64.setFillColor(new util.Color(p10_stimColors[57]));
    p10_sq74.setFillColor(new util.Color(p10_stimColors[58]));
    p10_sq84.setFillColor(new util.Color(p10_stimColors[59]));
    p10_sq94.setFillColor(new util.Color(p10_stimColors[60]));
    p10_sq104.setFillColor(new util.Color(p10_stimColors[61]));
    p10_sq114.setFillColor(new util.Color(p10_stimColors[62]));
    p10_sq124.setFillColor(new util.Color(p10_stimColors[63]));
    p10_sq134.setFillColor(new util.Color(p10_stimColors[64]));
    p10_sq144.setFillColor(new util.Color(p10_stimColors[65]));
    p10_sq154.setFillColor(new util.Color(p10_stimColors[66]));
    p10_sq164.setFillColor(new util.Color(p10_stimColors[67]));
    p10_sq174.setFillColor(new util.Color(p10_stimColors[68]));
    p10_sq15.setFillColor(new util.Color(p10_stimColors[69]));
    p10_sq25.setFillColor(new util.Color(p10_stimColors[70]));
    p10_sq35.setFillColor(new util.Color(p10_stimColors[71]));
    p10_sq45.setFillColor(new util.Color(p10_stimColors[72]));
    p10_sq55.setFillColor(new util.Color(p10_stimColors[73]));
    p10_sq65.setFillColor(new util.Color(p10_stimColors[74]));
    p10_sq75.setFillColor(new util.Color(p10_stimColors[75]));
    p10_sq85.setFillColor(new util.Color(p10_stimColors[76]));
    p10_sq95.setFillColor(new util.Color(p10_stimColors[77]));
    p10_sq105.setFillColor(new util.Color(p10_stimColors[78]));
    p10_sq115.setFillColor(new util.Color(p10_stimColors[79]));
    p10_sq125.setFillColor(new util.Color(p10_stimColors[80]));
    p10_sq135.setFillColor(new util.Color(p10_stimColors[81]));
    p10_sq145.setFillColor(new util.Color(p10_stimColors[82]));
    p10_sq155.setFillColor(new util.Color(p10_stimColors[83]));
    p10_sq165.setFillColor(new util.Color(p10_stimColors[84]));
    p10_sq175.setFillColor(new util.Color(p10_stimColors[85]));
    p10_sq16.setFillColor(new util.Color(p10_stimColors[86]));
    p10_sq26.setFillColor(new util.Color(p10_stimColors[87]));
    p10_sq36.setFillColor(new util.Color(p10_stimColors[88]));
    p10_sq46.setFillColor(new util.Color(p10_stimColors[89]));
    p10_sq56.setFillColor(new util.Color(p10_stimColors[90]));
    p10_sq66.setFillColor(new util.Color(p10_stimColors[91]));
    p10_sq76.setFillColor(new util.Color(p10_stimColors[92]));
    p10_sq86.setFillColor(new util.Color(p10_stimColors[93]));
    p10_sq96.setFillColor(new util.Color(p10_stimColors[94]));
    p10_sq106.setFillColor(new util.Color(p10_stimColors[95]));
    p10_sq116.setFillColor(new util.Color(p10_stimColors[96]));
    p10_sq126.setFillColor(new util.Color(p10_stimColors[97]));
    p10_sq136.setFillColor(new util.Color(p10_stimColors[98]));
    p10_sq146.setFillColor(new util.Color(p10_stimColors[99]));
    p10_sq156.setFillColor(new util.Color(p10_stimColors[100]));
    p10_txt1.setText(p10_words[1]);
    p10_txt2.setText(p10_words[2]);
    p10_txt3.setText(p10_words[3]);
    p10_txt4.setText(p10_words[4]);
    p10_txt5.setText(p10_words[5]);
    p10_txt6.setText(p10_words[6]);
    p10_txt7.setText(p10_words[7]);
    p10_txt8.setText(p10_words[8]);
    p10_txt9.setText(p10_words[9]);
    p10_txt10.setText(p10_words[10]);
    p10_txt11.setText(p10_words[11]);
    p10_txt12.setText(p10_words[12]);
    p10_txt13.setText(p10_words[13]);
    p10_txt14.setText(p10_words[14]);
    p10_txt15.setText(p10_words[15]);
    p10_txt16.setText(p10_words[16]);
    p10_txt17.setText(p10_words[17]);
    p10_txt18.setText(p10_words[18]);
    p10_txt19.setText(p10_words[19]);
    p10_txt20.setText(p10_words[20]);
    p10_txt21.setText(p10_words[21]);
    p10_txt22.setText(p10_words[22]);
    p10_txt23.setText(p10_words[23]);
    p10_txt24.setText(p10_words[24]);
    p10_txt25.setText(p10_words[25]);
    p10_txt26.setText(p10_words[26]);
    p10_txt27.setText(p10_words[27]);
    p10_txt28.setText(p10_words[28]);
    p10_txt29.setText(p10_words[29]);
    p10_txt30.setText(p10_words[30]);
    p10_txt31.setText(p10_words[31]);
    p10_txt32.setText(p10_words[32]);
    p10_txt33.setText(p10_words[33]);
    p10_txt34.setText(p10_words[34]);
    p10_txt35.setText(p10_words[35]);
    p10_txt36.setText(p10_words[36]);
    p10_txt37.setText(p10_words[37]);
    p10_txt38.setText(p10_words[38]);
    p10_txt39.setText(p10_words[39]);
    p10_txt40.setText(p10_words[40]);
    p10_txt41.setText(p10_words[41]);
    p10_txt42.setText(p10_words[42]);
    p10_txt43.setText(p10_words[43]);
    p10_txt44.setText(p10_words[44]);
    p10_txt45.setText(p10_words[45]);
    p10_txt46.setText(p10_words[46]);
    p10_txt47.setText(p10_words[47]);
    p10_txt48.setText(p10_words[48]);
    p10_txt49.setText(p10_words[49]);
    p10_txt50.setText(p10_words[50]);
    p10_txt51.setText(p10_words[51]);
    p10_txt52.setText(p10_words[52]);
    p10_txt53.setText(p10_words[53]);
    p10_txt54.setText(p10_words[52]);
    p10_txt55.setText(p10_words[54]);
    p10_txt56.setText(p10_words[56]);
    p10_txt57.setText(p10_words[57]);
    p10_txt58.setText(p10_words[58]);
    p10_txt59.setText(p10_words[59]);
    p10_txt60.setText(p10_words[60]);
    p10_txt61.setText(p10_words[61]);
    p10_txt62.setText(p10_words[62]);
    p10_txt63.setText(p10_words[63]);
    p10_txt64.setText(p10_words[64]);
    p10_txt65.setText(p10_words[65]);
    p10_txt66.setText(p10_words[66]);
    p10_txt67.setText(p10_words[67]);
    p10_txt68.setText(p10_words[68]);
    p10_txt69.setText(p10_words[69]);
    p10_txt70.setText(p10_words[70]);
    p10_txt71.setText(p10_words[71]);
    p10_txt72.setText(p10_words[72]);
    p10_txt73.setText(p10_words[73]);
    p10_txt74.setText(p10_words[74]);
    p10_txt75.setText(p10_words[75]);
    p10_txt76.setText(p10_words[76]);
    p10_txt77.setText(p10_words[77]);
    p10_txt78.setText(p10_words[78]);
    p10_txt79.setText(p10_words[79]);
    p10_txt80.setText(p10_words[80]);
    p10_txt81.setText(p10_words[81]);
    p10_txt82.setText(p10_words[82]);
    p10_txt83.setText(p10_words[83]);
    p10_txt84.setText(p10_words[84]);
    p10_txt85.setText(p10_words[85]);
    p10_txt86.setText(p10_words[86]);
    p10_txt87.setText(p10_words[87]);
    p10_txt88.setText(p10_words[88]);
    p10_txt89.setText(p10_words[89]);
    p10_txt90.setText(p10_words[90]);
    p10_txt91.setText(p10_words[91]);
    p10_txt92.setText(p10_words[92]);
    p10_txt93.setText(p10_words[93]);
    p10_txt94.setText(p10_words[94]);
    p10_txt95.setText(p10_words[95]);
    p10_txt96.setText(p10_words[96]);
    p10_txt97.setText(p10_words[97]);
    p10_txt98.setText(p10_words[98]);
    p10_txt99.setText(p10_words[99]);
    p10_txt100.setText(p10_words[100]);
    p10_box_next.setFillColor(new util.Color(BoxNextColor));
    p10_box_next.setOpacity(p10_opNextBox);
    p10_box_next.setLineColor(new util.Color(cGrey));
    p10_box_try.setFillColor(new util.Color(BoxTryColor));
    p10_box_try.setOpacity(p10_opTryBox);
    p10_box_try.setLineColor(new util.Color(cGrey));
    p10_txt_try.setOpacity(p10_opTryTxt);
    p10_txt_next.setOpacity(p10_opNextTxt);
    p10_txt_try_many.setOpacity(p10_opTryManyTxt);
    psychoJS.experiment.addData('p10_MEM_wordList.started', globalClock.getTime());
    p10_MEM_wordListMaxDuration = null
    // keep track of which components have finished
    p10_MEM_wordListComponents = [];
    p10_MEM_wordListComponents.push(p10_mouse);
    p10_MEM_wordListComponents.push(p10_txt_q);
    p10_MEM_wordListComponents.push(p10_sq11);
    p10_MEM_wordListComponents.push(p10_sq21);
    p10_MEM_wordListComponents.push(p10_sq31);
    p10_MEM_wordListComponents.push(p10_sq41);
    p10_MEM_wordListComponents.push(p10_sq51);
    p10_MEM_wordListComponents.push(p10_sq61);
    p10_MEM_wordListComponents.push(p10_sq71);
    p10_MEM_wordListComponents.push(p10_sq81);
    p10_MEM_wordListComponents.push(p10_sq91);
    p10_MEM_wordListComponents.push(p10_sq101);
    p10_MEM_wordListComponents.push(p10_sq111);
    p10_MEM_wordListComponents.push(p10_sq121);
    p10_MEM_wordListComponents.push(p10_sq131);
    p10_MEM_wordListComponents.push(p10_sq141);
    p10_MEM_wordListComponents.push(p10_sq151);
    p10_MEM_wordListComponents.push(p10_sq161);
    p10_MEM_wordListComponents.push(p10_sq171);
    p10_MEM_wordListComponents.push(p10_sq12);
    p10_MEM_wordListComponents.push(p10_sq22);
    p10_MEM_wordListComponents.push(p10_sq32);
    p10_MEM_wordListComponents.push(p10_sq42);
    p10_MEM_wordListComponents.push(p10_sq52);
    p10_MEM_wordListComponents.push(p10_sq62);
    p10_MEM_wordListComponents.push(p10_sq72);
    p10_MEM_wordListComponents.push(p10_sq82);
    p10_MEM_wordListComponents.push(p10_sq92);
    p10_MEM_wordListComponents.push(p10_sq102);
    p10_MEM_wordListComponents.push(p10_sq112);
    p10_MEM_wordListComponents.push(p10_sq122);
    p10_MEM_wordListComponents.push(p10_sq132);
    p10_MEM_wordListComponents.push(p10_sq142);
    p10_MEM_wordListComponents.push(p10_sq152);
    p10_MEM_wordListComponents.push(p10_sq162);
    p10_MEM_wordListComponents.push(p10_sq172);
    p10_MEM_wordListComponents.push(p10_sq13);
    p10_MEM_wordListComponents.push(p10_sq23);
    p10_MEM_wordListComponents.push(p10_sq33);
    p10_MEM_wordListComponents.push(p10_sq43);
    p10_MEM_wordListComponents.push(p10_sq53);
    p10_MEM_wordListComponents.push(p10_sq63);
    p10_MEM_wordListComponents.push(p10_sq73);
    p10_MEM_wordListComponents.push(p10_sq83);
    p10_MEM_wordListComponents.push(p10_sq93);
    p10_MEM_wordListComponents.push(p10_sq103);
    p10_MEM_wordListComponents.push(p10_sq113);
    p10_MEM_wordListComponents.push(p10_sq123);
    p10_MEM_wordListComponents.push(p10_sq133);
    p10_MEM_wordListComponents.push(p10_sq143);
    p10_MEM_wordListComponents.push(p10_sq153);
    p10_MEM_wordListComponents.push(p10_sq163);
    p10_MEM_wordListComponents.push(p10_sq173);
    p10_MEM_wordListComponents.push(p10_sq14);
    p10_MEM_wordListComponents.push(p10_sq24);
    p10_MEM_wordListComponents.push(p10_sq34);
    p10_MEM_wordListComponents.push(p10_sq44);
    p10_MEM_wordListComponents.push(p10_sq54);
    p10_MEM_wordListComponents.push(p10_sq64);
    p10_MEM_wordListComponents.push(p10_sq74);
    p10_MEM_wordListComponents.push(p10_sq84);
    p10_MEM_wordListComponents.push(p10_sq94);
    p10_MEM_wordListComponents.push(p10_sq104);
    p10_MEM_wordListComponents.push(p10_sq114);
    p10_MEM_wordListComponents.push(p10_sq124);
    p10_MEM_wordListComponents.push(p10_sq134);
    p10_MEM_wordListComponents.push(p10_sq144);
    p10_MEM_wordListComponents.push(p10_sq154);
    p10_MEM_wordListComponents.push(p10_sq164);
    p10_MEM_wordListComponents.push(p10_sq174);
    p10_MEM_wordListComponents.push(p10_sq15);
    p10_MEM_wordListComponents.push(p10_sq25);
    p10_MEM_wordListComponents.push(p10_sq35);
    p10_MEM_wordListComponents.push(p10_sq45);
    p10_MEM_wordListComponents.push(p10_sq55);
    p10_MEM_wordListComponents.push(p10_sq65);
    p10_MEM_wordListComponents.push(p10_sq75);
    p10_MEM_wordListComponents.push(p10_sq85);
    p10_MEM_wordListComponents.push(p10_sq95);
    p10_MEM_wordListComponents.push(p10_sq105);
    p10_MEM_wordListComponents.push(p10_sq115);
    p10_MEM_wordListComponents.push(p10_sq125);
    p10_MEM_wordListComponents.push(p10_sq135);
    p10_MEM_wordListComponents.push(p10_sq145);
    p10_MEM_wordListComponents.push(p10_sq155);
    p10_MEM_wordListComponents.push(p10_sq165);
    p10_MEM_wordListComponents.push(p10_sq175);
    p10_MEM_wordListComponents.push(p10_sq16);
    p10_MEM_wordListComponents.push(p10_sq26);
    p10_MEM_wordListComponents.push(p10_sq36);
    p10_MEM_wordListComponents.push(p10_sq46);
    p10_MEM_wordListComponents.push(p10_sq56);
    p10_MEM_wordListComponents.push(p10_sq66);
    p10_MEM_wordListComponents.push(p10_sq76);
    p10_MEM_wordListComponents.push(p10_sq86);
    p10_MEM_wordListComponents.push(p10_sq96);
    p10_MEM_wordListComponents.push(p10_sq106);
    p10_MEM_wordListComponents.push(p10_sq116);
    p10_MEM_wordListComponents.push(p10_sq126);
    p10_MEM_wordListComponents.push(p10_sq136);
    p10_MEM_wordListComponents.push(p10_sq146);
    p10_MEM_wordListComponents.push(p10_sq156);
    p10_MEM_wordListComponents.push(p10_txt1);
    p10_MEM_wordListComponents.push(p10_txt2);
    p10_MEM_wordListComponents.push(p10_txt3);
    p10_MEM_wordListComponents.push(p10_txt4);
    p10_MEM_wordListComponents.push(p10_txt5);
    p10_MEM_wordListComponents.push(p10_txt6);
    p10_MEM_wordListComponents.push(p10_txt7);
    p10_MEM_wordListComponents.push(p10_txt8);
    p10_MEM_wordListComponents.push(p10_txt9);
    p10_MEM_wordListComponents.push(p10_txt10);
    p10_MEM_wordListComponents.push(p10_txt11);
    p10_MEM_wordListComponents.push(p10_txt12);
    p10_MEM_wordListComponents.push(p10_txt13);
    p10_MEM_wordListComponents.push(p10_txt14);
    p10_MEM_wordListComponents.push(p10_txt15);
    p10_MEM_wordListComponents.push(p10_txt16);
    p10_MEM_wordListComponents.push(p10_txt17);
    p10_MEM_wordListComponents.push(p10_txt18);
    p10_MEM_wordListComponents.push(p10_txt19);
    p10_MEM_wordListComponents.push(p10_txt20);
    p10_MEM_wordListComponents.push(p10_txt21);
    p10_MEM_wordListComponents.push(p10_txt22);
    p10_MEM_wordListComponents.push(p10_txt23);
    p10_MEM_wordListComponents.push(p10_txt24);
    p10_MEM_wordListComponents.push(p10_txt25);
    p10_MEM_wordListComponents.push(p10_txt26);
    p10_MEM_wordListComponents.push(p10_txt27);
    p10_MEM_wordListComponents.push(p10_txt28);
    p10_MEM_wordListComponents.push(p10_txt29);
    p10_MEM_wordListComponents.push(p10_txt30);
    p10_MEM_wordListComponents.push(p10_txt31);
    p10_MEM_wordListComponents.push(p10_txt32);
    p10_MEM_wordListComponents.push(p10_txt33);
    p10_MEM_wordListComponents.push(p10_txt34);
    p10_MEM_wordListComponents.push(p10_txt35);
    p10_MEM_wordListComponents.push(p10_txt36);
    p10_MEM_wordListComponents.push(p10_txt37);
    p10_MEM_wordListComponents.push(p10_txt38);
    p10_MEM_wordListComponents.push(p10_txt39);
    p10_MEM_wordListComponents.push(p10_txt40);
    p10_MEM_wordListComponents.push(p10_txt41);
    p10_MEM_wordListComponents.push(p10_txt42);
    p10_MEM_wordListComponents.push(p10_txt43);
    p10_MEM_wordListComponents.push(p10_txt44);
    p10_MEM_wordListComponents.push(p10_txt45);
    p10_MEM_wordListComponents.push(p10_txt46);
    p10_MEM_wordListComponents.push(p10_txt47);
    p10_MEM_wordListComponents.push(p10_txt48);
    p10_MEM_wordListComponents.push(p10_txt49);
    p10_MEM_wordListComponents.push(p10_txt50);
    p10_MEM_wordListComponents.push(p10_txt51);
    p10_MEM_wordListComponents.push(p10_txt52);
    p10_MEM_wordListComponents.push(p10_txt53);
    p10_MEM_wordListComponents.push(p10_txt54);
    p10_MEM_wordListComponents.push(p10_txt55);
    p10_MEM_wordListComponents.push(p10_txt56);
    p10_MEM_wordListComponents.push(p10_txt57);
    p10_MEM_wordListComponents.push(p10_txt58);
    p10_MEM_wordListComponents.push(p10_txt59);
    p10_MEM_wordListComponents.push(p10_txt60);
    p10_MEM_wordListComponents.push(p10_txt61);
    p10_MEM_wordListComponents.push(p10_txt62);
    p10_MEM_wordListComponents.push(p10_txt63);
    p10_MEM_wordListComponents.push(p10_txt64);
    p10_MEM_wordListComponents.push(p10_txt65);
    p10_MEM_wordListComponents.push(p10_txt66);
    p10_MEM_wordListComponents.push(p10_txt67);
    p10_MEM_wordListComponents.push(p10_txt68);
    p10_MEM_wordListComponents.push(p10_txt69);
    p10_MEM_wordListComponents.push(p10_txt70);
    p10_MEM_wordListComponents.push(p10_txt71);
    p10_MEM_wordListComponents.push(p10_txt72);
    p10_MEM_wordListComponents.push(p10_txt73);
    p10_MEM_wordListComponents.push(p10_txt74);
    p10_MEM_wordListComponents.push(p10_txt75);
    p10_MEM_wordListComponents.push(p10_txt76);
    p10_MEM_wordListComponents.push(p10_txt77);
    p10_MEM_wordListComponents.push(p10_txt78);
    p10_MEM_wordListComponents.push(p10_txt79);
    p10_MEM_wordListComponents.push(p10_txt80);
    p10_MEM_wordListComponents.push(p10_txt81);
    p10_MEM_wordListComponents.push(p10_txt82);
    p10_MEM_wordListComponents.push(p10_txt83);
    p10_MEM_wordListComponents.push(p10_txt84);
    p10_MEM_wordListComponents.push(p10_txt85);
    p10_MEM_wordListComponents.push(p10_txt86);
    p10_MEM_wordListComponents.push(p10_txt87);
    p10_MEM_wordListComponents.push(p10_txt88);
    p10_MEM_wordListComponents.push(p10_txt89);
    p10_MEM_wordListComponents.push(p10_txt90);
    p10_MEM_wordListComponents.push(p10_txt91);
    p10_MEM_wordListComponents.push(p10_txt92);
    p10_MEM_wordListComponents.push(p10_txt93);
    p10_MEM_wordListComponents.push(p10_txt94);
    p10_MEM_wordListComponents.push(p10_txt95);
    p10_MEM_wordListComponents.push(p10_txt96);
    p10_MEM_wordListComponents.push(p10_txt97);
    p10_MEM_wordListComponents.push(p10_txt98);
    p10_MEM_wordListComponents.push(p10_txt99);
    p10_MEM_wordListComponents.push(p10_txt100);
    p10_MEM_wordListComponents.push(p10_box_next);
    p10_MEM_wordListComponents.push(p10_box_try);
    p10_MEM_wordListComponents.push(p10_txt_try);
    p10_MEM_wordListComponents.push(p10_txt_next);
    p10_MEM_wordListComponents.push(p10_txt_try_many);
    
    p10_MEM_wordListComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p10_MEM_wordListRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p10_MEM_wordList' ---
    // get current time
    t = p10_MEM_wordListClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // *p10_mouse* updates
    if (t >= 0 && p10_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_mouse.tStart = t;  // (not accounting for frame time here)
      p10_mouse.frameNStart = frameN;  // exact frame index
      
      p10_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p10_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p10_mouse is active this frame...
    if (p10_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p10_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p10_mouse.clickableObjects = eval([p10_box_next, p10_sq11, p10_sq21, p10_sq31, p10_sq41, p10_sq51, p10_sq61, p10_sq71, p10_sq81, p10_sq91, p10_sq101, p10_sq111, p10_sq121, p10_sq131, p10_sq141, p10_sq151, p10_sq161, p10_sq171, p10_sq12, p10_sq22, p10_sq32, p10_sq42, p10_sq52, p10_sq62, p10_sq72, p10_sq82, p10_sq92, p10_sq102, p10_sq112, p10_sq122, p10_sq132, p10_sq142, p10_sq152, p10_sq162, p10_sq172, p10_sq13, p10_sq23, p10_sq33, p10_sq43, p10_sq53, p10_sq63, p10_sq73, p10_sq83, p10_sq93, p10_sq103, p10_sq113, p10_sq123, p10_sq133, p10_sq143, p10_sq153, p10_sq163, p10_sq173, p10_sq14, p10_sq24, p10_sq34, p10_sq44, p10_sq54, p10_sq64, p10_sq74, p10_sq84, p10_sq94, p10_sq104, p10_sq114, p10_sq124, p10_sq134, p10_sq144, p10_sq154, p10_sq164, p10_sq174, p10_sq15, p10_sq25, p10_sq35, p10_sq45, p10_sq55, p10_sq65, p10_sq75, p10_sq85, p10_sq95, p10_sq105, p10_sq115, p10_sq125, p10_sq135, p10_sq145, p10_sq155, p10_sq165, p10_sq175, p10_sq16, p10_sq26, p10_sq36, p10_sq46, p10_sq56, p10_sq66, p10_sq76, p10_sq86, p10_sq96, p10_sq106, p10_sq116, p10_sq126, p10_sq136, p10_sq146, p10_sq156])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p10_mouse.clickableObjects)) {
              p10_mouse.clickableObjects = [p10_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p10_mouse.clickableObjects) {
              if (obj.contains(p10_mouse)) {
                  gotValidClick = true;
                  p10_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p10_mouse.clickableObjects = eval([p10_box_next, p10_sq11, p10_sq21, p10_sq31, p10_sq41, p10_sq51, p10_sq61, p10_sq71, p10_sq81, p10_sq91, p10_sq101, p10_sq111, p10_sq121, p10_sq131, p10_sq141, p10_sq151, p10_sq161, p10_sq171, p10_sq12, p10_sq22, p10_sq32, p10_sq42, p10_sq52, p10_sq62, p10_sq72, p10_sq82, p10_sq92, p10_sq102, p10_sq112, p10_sq122, p10_sq132, p10_sq142, p10_sq152, p10_sq162, p10_sq172, p10_sq13, p10_sq23, p10_sq33, p10_sq43, p10_sq53, p10_sq63, p10_sq73, p10_sq83, p10_sq93, p10_sq103, p10_sq113, p10_sq123, p10_sq133, p10_sq143, p10_sq153, p10_sq163, p10_sq173, p10_sq14, p10_sq24, p10_sq34, p10_sq44, p10_sq54, p10_sq64, p10_sq74, p10_sq84, p10_sq94, p10_sq104, p10_sq114, p10_sq124, p10_sq134, p10_sq144, p10_sq154, p10_sq164, p10_sq174, p10_sq15, p10_sq25, p10_sq35, p10_sq45, p10_sq55, p10_sq65, p10_sq75, p10_sq85, p10_sq95, p10_sq105, p10_sq115, p10_sq125, p10_sq135, p10_sq145, p10_sq155, p10_sq165, p10_sq175, p10_sq16, p10_sq26, p10_sq36, p10_sq46, p10_sq56, p10_sq66, p10_sq76, p10_sq86, p10_sq96, p10_sq106, p10_sq116, p10_sq126, p10_sq136, p10_sq146, p10_sq156])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p10_mouse.clickableObjects)) {
              p10_mouse.clickableObjects = [p10_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p10_mouse.clickableObjects) {
              if (obj.contains(p10_mouse)) {
                  gotValidClick = true;
                  p10_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p10_mouse.getPos();
            p10_mouse.x.push(_mouseXYs[0]);
            p10_mouse.y.push(_mouseXYs[1]);
            p10_mouse.leftButton.push(_mouseButtons[0]);
            p10_mouse.midButton.push(_mouseButtons[1]);
            p10_mouse.rightButton.push(_mouseButtons[2]);
            p10_mouse.time.push(p10_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p10_txt_q* updates
    if (t >= 0.0 && p10_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt_q.tStart = t;  // (not accounting for frame time here)
      p10_txt_q.frameNStart = frameN;  // exact frame index
      
      p10_txt_q.setAutoDraw(true);
    }
    
    
    // if p10_txt_q is active this frame...
    if (p10_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq11* updates
    if (t >= 0.0 && p10_sq11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq11.tStart = t;  // (not accounting for frame time here)
      p10_sq11.frameNStart = frameN;  // exact frame index
      
      p10_sq11.setAutoDraw(true);
    }
    
    
    // if p10_sq11 is active this frame...
    if (p10_sq11.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq21* updates
    if (t >= 0.0 && p10_sq21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq21.tStart = t;  // (not accounting for frame time here)
      p10_sq21.frameNStart = frameN;  // exact frame index
      
      p10_sq21.setAutoDraw(true);
    }
    
    
    // if p10_sq21 is active this frame...
    if (p10_sq21.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq31* updates
    if (t >= 0.0 && p10_sq31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq31.tStart = t;  // (not accounting for frame time here)
      p10_sq31.frameNStart = frameN;  // exact frame index
      
      p10_sq31.setAutoDraw(true);
    }
    
    
    // if p10_sq31 is active this frame...
    if (p10_sq31.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq41* updates
    if (t >= 0.0 && p10_sq41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq41.tStart = t;  // (not accounting for frame time here)
      p10_sq41.frameNStart = frameN;  // exact frame index
      
      p10_sq41.setAutoDraw(true);
    }
    
    
    // if p10_sq41 is active this frame...
    if (p10_sq41.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq51* updates
    if (t >= 0.0 && p10_sq51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq51.tStart = t;  // (not accounting for frame time here)
      p10_sq51.frameNStart = frameN;  // exact frame index
      
      p10_sq51.setAutoDraw(true);
    }
    
    
    // if p10_sq51 is active this frame...
    if (p10_sq51.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq61* updates
    if (t >= 0.0 && p10_sq61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq61.tStart = t;  // (not accounting for frame time here)
      p10_sq61.frameNStart = frameN;  // exact frame index
      
      p10_sq61.setAutoDraw(true);
    }
    
    
    // if p10_sq61 is active this frame...
    if (p10_sq61.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq71* updates
    if (t >= 0.0 && p10_sq71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq71.tStart = t;  // (not accounting for frame time here)
      p10_sq71.frameNStart = frameN;  // exact frame index
      
      p10_sq71.setAutoDraw(true);
    }
    
    
    // if p10_sq71 is active this frame...
    if (p10_sq71.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq81* updates
    if (t >= 0.0 && p10_sq81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq81.tStart = t;  // (not accounting for frame time here)
      p10_sq81.frameNStart = frameN;  // exact frame index
      
      p10_sq81.setAutoDraw(true);
    }
    
    
    // if p10_sq81 is active this frame...
    if (p10_sq81.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq91* updates
    if (t >= 0.0 && p10_sq91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq91.tStart = t;  // (not accounting for frame time here)
      p10_sq91.frameNStart = frameN;  // exact frame index
      
      p10_sq91.setAutoDraw(true);
    }
    
    
    // if p10_sq91 is active this frame...
    if (p10_sq91.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq101* updates
    if (t >= 0.0 && p10_sq101.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq101.tStart = t;  // (not accounting for frame time here)
      p10_sq101.frameNStart = frameN;  // exact frame index
      
      p10_sq101.setAutoDraw(true);
    }
    
    
    // if p10_sq101 is active this frame...
    if (p10_sq101.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq111* updates
    if (t >= 0.0 && p10_sq111.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq111.tStart = t;  // (not accounting for frame time here)
      p10_sq111.frameNStart = frameN;  // exact frame index
      
      p10_sq111.setAutoDraw(true);
    }
    
    
    // if p10_sq111 is active this frame...
    if (p10_sq111.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq121* updates
    if (t >= 0.0 && p10_sq121.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq121.tStart = t;  // (not accounting for frame time here)
      p10_sq121.frameNStart = frameN;  // exact frame index
      
      p10_sq121.setAutoDraw(true);
    }
    
    
    // if p10_sq121 is active this frame...
    if (p10_sq121.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq131* updates
    if (t >= 0.0 && p10_sq131.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq131.tStart = t;  // (not accounting for frame time here)
      p10_sq131.frameNStart = frameN;  // exact frame index
      
      p10_sq131.setAutoDraw(true);
    }
    
    
    // if p10_sq131 is active this frame...
    if (p10_sq131.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq141* updates
    if (t >= 0.0 && p10_sq141.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq141.tStart = t;  // (not accounting for frame time here)
      p10_sq141.frameNStart = frameN;  // exact frame index
      
      p10_sq141.setAutoDraw(true);
    }
    
    
    // if p10_sq141 is active this frame...
    if (p10_sq141.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq151* updates
    if (t >= 0.0 && p10_sq151.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq151.tStart = t;  // (not accounting for frame time here)
      p10_sq151.frameNStart = frameN;  // exact frame index
      
      p10_sq151.setAutoDraw(true);
    }
    
    
    // if p10_sq151 is active this frame...
    if (p10_sq151.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq161* updates
    if (t >= 0.0 && p10_sq161.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq161.tStart = t;  // (not accounting for frame time here)
      p10_sq161.frameNStart = frameN;  // exact frame index
      
      p10_sq161.setAutoDraw(true);
    }
    
    
    // if p10_sq161 is active this frame...
    if (p10_sq161.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq171* updates
    if (t >= 0.0 && p10_sq171.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq171.tStart = t;  // (not accounting for frame time here)
      p10_sq171.frameNStart = frameN;  // exact frame index
      
      p10_sq171.setAutoDraw(true);
    }
    
    
    // if p10_sq171 is active this frame...
    if (p10_sq171.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq12* updates
    if (t >= 0.0 && p10_sq12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq12.tStart = t;  // (not accounting for frame time here)
      p10_sq12.frameNStart = frameN;  // exact frame index
      
      p10_sq12.setAutoDraw(true);
    }
    
    
    // if p10_sq12 is active this frame...
    if (p10_sq12.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq22* updates
    if (t >= 0.0 && p10_sq22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq22.tStart = t;  // (not accounting for frame time here)
      p10_sq22.frameNStart = frameN;  // exact frame index
      
      p10_sq22.setAutoDraw(true);
    }
    
    
    // if p10_sq22 is active this frame...
    if (p10_sq22.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq32* updates
    if (t >= 0.0 && p10_sq32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq32.tStart = t;  // (not accounting for frame time here)
      p10_sq32.frameNStart = frameN;  // exact frame index
      
      p10_sq32.setAutoDraw(true);
    }
    
    
    // if p10_sq32 is active this frame...
    if (p10_sq32.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq42* updates
    if (t >= 0.0 && p10_sq42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq42.tStart = t;  // (not accounting for frame time here)
      p10_sq42.frameNStart = frameN;  // exact frame index
      
      p10_sq42.setAutoDraw(true);
    }
    
    
    // if p10_sq42 is active this frame...
    if (p10_sq42.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq52* updates
    if (t >= 0.0 && p10_sq52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq52.tStart = t;  // (not accounting for frame time here)
      p10_sq52.frameNStart = frameN;  // exact frame index
      
      p10_sq52.setAutoDraw(true);
    }
    
    
    // if p10_sq52 is active this frame...
    if (p10_sq52.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq62* updates
    if (t >= 0.0 && p10_sq62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq62.tStart = t;  // (not accounting for frame time here)
      p10_sq62.frameNStart = frameN;  // exact frame index
      
      p10_sq62.setAutoDraw(true);
    }
    
    
    // if p10_sq62 is active this frame...
    if (p10_sq62.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq72* updates
    if (t >= 0.0 && p10_sq72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq72.tStart = t;  // (not accounting for frame time here)
      p10_sq72.frameNStart = frameN;  // exact frame index
      
      p10_sq72.setAutoDraw(true);
    }
    
    
    // if p10_sq72 is active this frame...
    if (p10_sq72.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq82* updates
    if (t >= 0.0 && p10_sq82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq82.tStart = t;  // (not accounting for frame time here)
      p10_sq82.frameNStart = frameN;  // exact frame index
      
      p10_sq82.setAutoDraw(true);
    }
    
    
    // if p10_sq82 is active this frame...
    if (p10_sq82.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq92* updates
    if (t >= 0.0 && p10_sq92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq92.tStart = t;  // (not accounting for frame time here)
      p10_sq92.frameNStart = frameN;  // exact frame index
      
      p10_sq92.setAutoDraw(true);
    }
    
    
    // if p10_sq92 is active this frame...
    if (p10_sq92.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq102* updates
    if (t >= 0.0 && p10_sq102.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq102.tStart = t;  // (not accounting for frame time here)
      p10_sq102.frameNStart = frameN;  // exact frame index
      
      p10_sq102.setAutoDraw(true);
    }
    
    
    // if p10_sq102 is active this frame...
    if (p10_sq102.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq112* updates
    if (t >= 0.0 && p10_sq112.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq112.tStart = t;  // (not accounting for frame time here)
      p10_sq112.frameNStart = frameN;  // exact frame index
      
      p10_sq112.setAutoDraw(true);
    }
    
    
    // if p10_sq112 is active this frame...
    if (p10_sq112.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq122* updates
    if (t >= 0.0 && p10_sq122.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq122.tStart = t;  // (not accounting for frame time here)
      p10_sq122.frameNStart = frameN;  // exact frame index
      
      p10_sq122.setAutoDraw(true);
    }
    
    
    // if p10_sq122 is active this frame...
    if (p10_sq122.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq132* updates
    if (t >= 0.0 && p10_sq132.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq132.tStart = t;  // (not accounting for frame time here)
      p10_sq132.frameNStart = frameN;  // exact frame index
      
      p10_sq132.setAutoDraw(true);
    }
    
    
    // if p10_sq132 is active this frame...
    if (p10_sq132.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq142* updates
    if (t >= 0.0 && p10_sq142.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq142.tStart = t;  // (not accounting for frame time here)
      p10_sq142.frameNStart = frameN;  // exact frame index
      
      p10_sq142.setAutoDraw(true);
    }
    
    
    // if p10_sq142 is active this frame...
    if (p10_sq142.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq152* updates
    if (t >= 0.0 && p10_sq152.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq152.tStart = t;  // (not accounting for frame time here)
      p10_sq152.frameNStart = frameN;  // exact frame index
      
      p10_sq152.setAutoDraw(true);
    }
    
    
    // if p10_sq152 is active this frame...
    if (p10_sq152.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq162* updates
    if (t >= 0.0 && p10_sq162.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq162.tStart = t;  // (not accounting for frame time here)
      p10_sq162.frameNStart = frameN;  // exact frame index
      
      p10_sq162.setAutoDraw(true);
    }
    
    
    // if p10_sq162 is active this frame...
    if (p10_sq162.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq172* updates
    if (t >= 0.0 && p10_sq172.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq172.tStart = t;  // (not accounting for frame time here)
      p10_sq172.frameNStart = frameN;  // exact frame index
      
      p10_sq172.setAutoDraw(true);
    }
    
    
    // if p10_sq172 is active this frame...
    if (p10_sq172.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq13* updates
    if (t >= 0.0 && p10_sq13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq13.tStart = t;  // (not accounting for frame time here)
      p10_sq13.frameNStart = frameN;  // exact frame index
      
      p10_sq13.setAutoDraw(true);
    }
    
    
    // if p10_sq13 is active this frame...
    if (p10_sq13.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq23* updates
    if (t >= 0.0 && p10_sq23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq23.tStart = t;  // (not accounting for frame time here)
      p10_sq23.frameNStart = frameN;  // exact frame index
      
      p10_sq23.setAutoDraw(true);
    }
    
    
    // if p10_sq23 is active this frame...
    if (p10_sq23.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq33* updates
    if (t >= 0.0 && p10_sq33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq33.tStart = t;  // (not accounting for frame time here)
      p10_sq33.frameNStart = frameN;  // exact frame index
      
      p10_sq33.setAutoDraw(true);
    }
    
    
    // if p10_sq33 is active this frame...
    if (p10_sq33.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq43* updates
    if (t >= 0.0 && p10_sq43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq43.tStart = t;  // (not accounting for frame time here)
      p10_sq43.frameNStart = frameN;  // exact frame index
      
      p10_sq43.setAutoDraw(true);
    }
    
    
    // if p10_sq43 is active this frame...
    if (p10_sq43.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq53* updates
    if (t >= 0.0 && p10_sq53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq53.tStart = t;  // (not accounting for frame time here)
      p10_sq53.frameNStart = frameN;  // exact frame index
      
      p10_sq53.setAutoDraw(true);
    }
    
    
    // if p10_sq53 is active this frame...
    if (p10_sq53.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq63* updates
    if (t >= 0.0 && p10_sq63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq63.tStart = t;  // (not accounting for frame time here)
      p10_sq63.frameNStart = frameN;  // exact frame index
      
      p10_sq63.setAutoDraw(true);
    }
    
    
    // if p10_sq63 is active this frame...
    if (p10_sq63.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq73* updates
    if (t >= 0.0 && p10_sq73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq73.tStart = t;  // (not accounting for frame time here)
      p10_sq73.frameNStart = frameN;  // exact frame index
      
      p10_sq73.setAutoDraw(true);
    }
    
    
    // if p10_sq73 is active this frame...
    if (p10_sq73.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq83* updates
    if (t >= 0.0 && p10_sq83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq83.tStart = t;  // (not accounting for frame time here)
      p10_sq83.frameNStart = frameN;  // exact frame index
      
      p10_sq83.setAutoDraw(true);
    }
    
    
    // if p10_sq83 is active this frame...
    if (p10_sq83.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq93* updates
    if (t >= 0.0 && p10_sq93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq93.tStart = t;  // (not accounting for frame time here)
      p10_sq93.frameNStart = frameN;  // exact frame index
      
      p10_sq93.setAutoDraw(true);
    }
    
    
    // if p10_sq93 is active this frame...
    if (p10_sq93.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq103* updates
    if (t >= 0.0 && p10_sq103.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq103.tStart = t;  // (not accounting for frame time here)
      p10_sq103.frameNStart = frameN;  // exact frame index
      
      p10_sq103.setAutoDraw(true);
    }
    
    
    // if p10_sq103 is active this frame...
    if (p10_sq103.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq113* updates
    if (t >= 0.0 && p10_sq113.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq113.tStart = t;  // (not accounting for frame time here)
      p10_sq113.frameNStart = frameN;  // exact frame index
      
      p10_sq113.setAutoDraw(true);
    }
    
    
    // if p10_sq113 is active this frame...
    if (p10_sq113.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq123* updates
    if (t >= 0.0 && p10_sq123.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq123.tStart = t;  // (not accounting for frame time here)
      p10_sq123.frameNStart = frameN;  // exact frame index
      
      p10_sq123.setAutoDraw(true);
    }
    
    
    // if p10_sq123 is active this frame...
    if (p10_sq123.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq133* updates
    if (t >= 0.0 && p10_sq133.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq133.tStart = t;  // (not accounting for frame time here)
      p10_sq133.frameNStart = frameN;  // exact frame index
      
      p10_sq133.setAutoDraw(true);
    }
    
    
    // if p10_sq133 is active this frame...
    if (p10_sq133.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq143* updates
    if (t >= 0.0 && p10_sq143.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq143.tStart = t;  // (not accounting for frame time here)
      p10_sq143.frameNStart = frameN;  // exact frame index
      
      p10_sq143.setAutoDraw(true);
    }
    
    
    // if p10_sq143 is active this frame...
    if (p10_sq143.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq153* updates
    if (t >= 0.0 && p10_sq153.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq153.tStart = t;  // (not accounting for frame time here)
      p10_sq153.frameNStart = frameN;  // exact frame index
      
      p10_sq153.setAutoDraw(true);
    }
    
    
    // if p10_sq153 is active this frame...
    if (p10_sq153.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq163* updates
    if (t >= 0.0 && p10_sq163.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq163.tStart = t;  // (not accounting for frame time here)
      p10_sq163.frameNStart = frameN;  // exact frame index
      
      p10_sq163.setAutoDraw(true);
    }
    
    
    // if p10_sq163 is active this frame...
    if (p10_sq163.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq173* updates
    if (t >= 0.0 && p10_sq173.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq173.tStart = t;  // (not accounting for frame time here)
      p10_sq173.frameNStart = frameN;  // exact frame index
      
      p10_sq173.setAutoDraw(true);
    }
    
    
    // if p10_sq173 is active this frame...
    if (p10_sq173.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq14* updates
    if (t >= 0.0 && p10_sq14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq14.tStart = t;  // (not accounting for frame time here)
      p10_sq14.frameNStart = frameN;  // exact frame index
      
      p10_sq14.setAutoDraw(true);
    }
    
    
    // if p10_sq14 is active this frame...
    if (p10_sq14.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq24* updates
    if (t >= 0.0 && p10_sq24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq24.tStart = t;  // (not accounting for frame time here)
      p10_sq24.frameNStart = frameN;  // exact frame index
      
      p10_sq24.setAutoDraw(true);
    }
    
    
    // if p10_sq24 is active this frame...
    if (p10_sq24.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq34* updates
    if (t >= 0.0 && p10_sq34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq34.tStart = t;  // (not accounting for frame time here)
      p10_sq34.frameNStart = frameN;  // exact frame index
      
      p10_sq34.setAutoDraw(true);
    }
    
    
    // if p10_sq34 is active this frame...
    if (p10_sq34.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq44* updates
    if (t >= 0.0 && p10_sq44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq44.tStart = t;  // (not accounting for frame time here)
      p10_sq44.frameNStart = frameN;  // exact frame index
      
      p10_sq44.setAutoDraw(true);
    }
    
    
    // if p10_sq44 is active this frame...
    if (p10_sq44.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq54* updates
    if (t >= 0.0 && p10_sq54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq54.tStart = t;  // (not accounting for frame time here)
      p10_sq54.frameNStart = frameN;  // exact frame index
      
      p10_sq54.setAutoDraw(true);
    }
    
    
    // if p10_sq54 is active this frame...
    if (p10_sq54.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq64* updates
    if (t >= 0.0 && p10_sq64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq64.tStart = t;  // (not accounting for frame time here)
      p10_sq64.frameNStart = frameN;  // exact frame index
      
      p10_sq64.setAutoDraw(true);
    }
    
    
    // if p10_sq64 is active this frame...
    if (p10_sq64.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq74* updates
    if (t >= 0.0 && p10_sq74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq74.tStart = t;  // (not accounting for frame time here)
      p10_sq74.frameNStart = frameN;  // exact frame index
      
      p10_sq74.setAutoDraw(true);
    }
    
    
    // if p10_sq74 is active this frame...
    if (p10_sq74.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq84* updates
    if (t >= 0.0 && p10_sq84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq84.tStart = t;  // (not accounting for frame time here)
      p10_sq84.frameNStart = frameN;  // exact frame index
      
      p10_sq84.setAutoDraw(true);
    }
    
    
    // if p10_sq84 is active this frame...
    if (p10_sq84.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq94* updates
    if (t >= 0.0 && p10_sq94.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq94.tStart = t;  // (not accounting for frame time here)
      p10_sq94.frameNStart = frameN;  // exact frame index
      
      p10_sq94.setAutoDraw(true);
    }
    
    
    // if p10_sq94 is active this frame...
    if (p10_sq94.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq104* updates
    if (t >= 0.0 && p10_sq104.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq104.tStart = t;  // (not accounting for frame time here)
      p10_sq104.frameNStart = frameN;  // exact frame index
      
      p10_sq104.setAutoDraw(true);
    }
    
    
    // if p10_sq104 is active this frame...
    if (p10_sq104.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq114* updates
    if (t >= 0.0 && p10_sq114.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq114.tStart = t;  // (not accounting for frame time here)
      p10_sq114.frameNStart = frameN;  // exact frame index
      
      p10_sq114.setAutoDraw(true);
    }
    
    
    // if p10_sq114 is active this frame...
    if (p10_sq114.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq124* updates
    if (t >= 0.0 && p10_sq124.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq124.tStart = t;  // (not accounting for frame time here)
      p10_sq124.frameNStart = frameN;  // exact frame index
      
      p10_sq124.setAutoDraw(true);
    }
    
    
    // if p10_sq124 is active this frame...
    if (p10_sq124.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq134* updates
    if (t >= 0.0 && p10_sq134.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq134.tStart = t;  // (not accounting for frame time here)
      p10_sq134.frameNStart = frameN;  // exact frame index
      
      p10_sq134.setAutoDraw(true);
    }
    
    
    // if p10_sq134 is active this frame...
    if (p10_sq134.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq144* updates
    if (t >= 0.0 && p10_sq144.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq144.tStart = t;  // (not accounting for frame time here)
      p10_sq144.frameNStart = frameN;  // exact frame index
      
      p10_sq144.setAutoDraw(true);
    }
    
    
    // if p10_sq144 is active this frame...
    if (p10_sq144.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq154* updates
    if (t >= 0.0 && p10_sq154.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq154.tStart = t;  // (not accounting for frame time here)
      p10_sq154.frameNStart = frameN;  // exact frame index
      
      p10_sq154.setAutoDraw(true);
    }
    
    
    // if p10_sq154 is active this frame...
    if (p10_sq154.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq164* updates
    if (t >= 0.0 && p10_sq164.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq164.tStart = t;  // (not accounting for frame time here)
      p10_sq164.frameNStart = frameN;  // exact frame index
      
      p10_sq164.setAutoDraw(true);
    }
    
    
    // if p10_sq164 is active this frame...
    if (p10_sq164.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq174* updates
    if (t >= 0.0 && p10_sq174.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq174.tStart = t;  // (not accounting for frame time here)
      p10_sq174.frameNStart = frameN;  // exact frame index
      
      p10_sq174.setAutoDraw(true);
    }
    
    
    // if p10_sq174 is active this frame...
    if (p10_sq174.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq15* updates
    if (t >= 0.0 && p10_sq15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq15.tStart = t;  // (not accounting for frame time here)
      p10_sq15.frameNStart = frameN;  // exact frame index
      
      p10_sq15.setAutoDraw(true);
    }
    
    
    // if p10_sq15 is active this frame...
    if (p10_sq15.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq25* updates
    if (t >= 0.0 && p10_sq25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq25.tStart = t;  // (not accounting for frame time here)
      p10_sq25.frameNStart = frameN;  // exact frame index
      
      p10_sq25.setAutoDraw(true);
    }
    
    
    // if p10_sq25 is active this frame...
    if (p10_sq25.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq35* updates
    if (t >= 0.0 && p10_sq35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq35.tStart = t;  // (not accounting for frame time here)
      p10_sq35.frameNStart = frameN;  // exact frame index
      
      p10_sq35.setAutoDraw(true);
    }
    
    
    // if p10_sq35 is active this frame...
    if (p10_sq35.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq45* updates
    if (t >= 0.0 && p10_sq45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq45.tStart = t;  // (not accounting for frame time here)
      p10_sq45.frameNStart = frameN;  // exact frame index
      
      p10_sq45.setAutoDraw(true);
    }
    
    
    // if p10_sq45 is active this frame...
    if (p10_sq45.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq55* updates
    if (t >= 0.0 && p10_sq55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq55.tStart = t;  // (not accounting for frame time here)
      p10_sq55.frameNStart = frameN;  // exact frame index
      
      p10_sq55.setAutoDraw(true);
    }
    
    
    // if p10_sq55 is active this frame...
    if (p10_sq55.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq65* updates
    if (t >= 0.0 && p10_sq65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq65.tStart = t;  // (not accounting for frame time here)
      p10_sq65.frameNStart = frameN;  // exact frame index
      
      p10_sq65.setAutoDraw(true);
    }
    
    
    // if p10_sq65 is active this frame...
    if (p10_sq65.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq75* updates
    if (t >= 0.0 && p10_sq75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq75.tStart = t;  // (not accounting for frame time here)
      p10_sq75.frameNStart = frameN;  // exact frame index
      
      p10_sq75.setAutoDraw(true);
    }
    
    
    // if p10_sq75 is active this frame...
    if (p10_sq75.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq85* updates
    if (t >= 0.0 && p10_sq85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq85.tStart = t;  // (not accounting for frame time here)
      p10_sq85.frameNStart = frameN;  // exact frame index
      
      p10_sq85.setAutoDraw(true);
    }
    
    
    // if p10_sq85 is active this frame...
    if (p10_sq85.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq95* updates
    if (t >= 0.0 && p10_sq95.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq95.tStart = t;  // (not accounting for frame time here)
      p10_sq95.frameNStart = frameN;  // exact frame index
      
      p10_sq95.setAutoDraw(true);
    }
    
    
    // if p10_sq95 is active this frame...
    if (p10_sq95.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq105* updates
    if (t >= 0.0 && p10_sq105.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq105.tStart = t;  // (not accounting for frame time here)
      p10_sq105.frameNStart = frameN;  // exact frame index
      
      p10_sq105.setAutoDraw(true);
    }
    
    
    // if p10_sq105 is active this frame...
    if (p10_sq105.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq115* updates
    if (t >= 0.0 && p10_sq115.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq115.tStart = t;  // (not accounting for frame time here)
      p10_sq115.frameNStart = frameN;  // exact frame index
      
      p10_sq115.setAutoDraw(true);
    }
    
    
    // if p10_sq115 is active this frame...
    if (p10_sq115.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq125* updates
    if (t >= 0.0 && p10_sq125.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq125.tStart = t;  // (not accounting for frame time here)
      p10_sq125.frameNStart = frameN;  // exact frame index
      
      p10_sq125.setAutoDraw(true);
    }
    
    
    // if p10_sq125 is active this frame...
    if (p10_sq125.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq135* updates
    if (t >= 0.0 && p10_sq135.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq135.tStart = t;  // (not accounting for frame time here)
      p10_sq135.frameNStart = frameN;  // exact frame index
      
      p10_sq135.setAutoDraw(true);
    }
    
    
    // if p10_sq135 is active this frame...
    if (p10_sq135.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq145* updates
    if (t >= 0.0 && p10_sq145.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq145.tStart = t;  // (not accounting for frame time here)
      p10_sq145.frameNStart = frameN;  // exact frame index
      
      p10_sq145.setAutoDraw(true);
    }
    
    
    // if p10_sq145 is active this frame...
    if (p10_sq145.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq155* updates
    if (t >= 0.0 && p10_sq155.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq155.tStart = t;  // (not accounting for frame time here)
      p10_sq155.frameNStart = frameN;  // exact frame index
      
      p10_sq155.setAutoDraw(true);
    }
    
    
    // if p10_sq155 is active this frame...
    if (p10_sq155.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq165* updates
    if (t >= 0.0 && p10_sq165.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq165.tStart = t;  // (not accounting for frame time here)
      p10_sq165.frameNStart = frameN;  // exact frame index
      
      p10_sq165.setAutoDraw(true);
    }
    
    
    // if p10_sq165 is active this frame...
    if (p10_sq165.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq175* updates
    if (t >= 0.0 && p10_sq175.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq175.tStart = t;  // (not accounting for frame time here)
      p10_sq175.frameNStart = frameN;  // exact frame index
      
      p10_sq175.setAutoDraw(true);
    }
    
    
    // if p10_sq175 is active this frame...
    if (p10_sq175.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq16* updates
    if (t >= 0.0 && p10_sq16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq16.tStart = t;  // (not accounting for frame time here)
      p10_sq16.frameNStart = frameN;  // exact frame index
      
      p10_sq16.setAutoDraw(true);
    }
    
    
    // if p10_sq16 is active this frame...
    if (p10_sq16.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq26* updates
    if (t >= 0.0 && p10_sq26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq26.tStart = t;  // (not accounting for frame time here)
      p10_sq26.frameNStart = frameN;  // exact frame index
      
      p10_sq26.setAutoDraw(true);
    }
    
    
    // if p10_sq26 is active this frame...
    if (p10_sq26.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq36* updates
    if (t >= 0.0 && p10_sq36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq36.tStart = t;  // (not accounting for frame time here)
      p10_sq36.frameNStart = frameN;  // exact frame index
      
      p10_sq36.setAutoDraw(true);
    }
    
    
    // if p10_sq36 is active this frame...
    if (p10_sq36.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq46* updates
    if (t >= 0.0 && p10_sq46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq46.tStart = t;  // (not accounting for frame time here)
      p10_sq46.frameNStart = frameN;  // exact frame index
      
      p10_sq46.setAutoDraw(true);
    }
    
    
    // if p10_sq46 is active this frame...
    if (p10_sq46.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq56* updates
    if (t >= 0.0 && p10_sq56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq56.tStart = t;  // (not accounting for frame time here)
      p10_sq56.frameNStart = frameN;  // exact frame index
      
      p10_sq56.setAutoDraw(true);
    }
    
    
    // if p10_sq56 is active this frame...
    if (p10_sq56.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq66* updates
    if (t >= 0.0 && p10_sq66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq66.tStart = t;  // (not accounting for frame time here)
      p10_sq66.frameNStart = frameN;  // exact frame index
      
      p10_sq66.setAutoDraw(true);
    }
    
    
    // if p10_sq66 is active this frame...
    if (p10_sq66.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq76* updates
    if (t >= 0.0 && p10_sq76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq76.tStart = t;  // (not accounting for frame time here)
      p10_sq76.frameNStart = frameN;  // exact frame index
      
      p10_sq76.setAutoDraw(true);
    }
    
    
    // if p10_sq76 is active this frame...
    if (p10_sq76.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq86* updates
    if (t >= 0.0 && p10_sq86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq86.tStart = t;  // (not accounting for frame time here)
      p10_sq86.frameNStart = frameN;  // exact frame index
      
      p10_sq86.setAutoDraw(true);
    }
    
    
    // if p10_sq86 is active this frame...
    if (p10_sq86.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq96* updates
    if (t >= 0.0 && p10_sq96.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq96.tStart = t;  // (not accounting for frame time here)
      p10_sq96.frameNStart = frameN;  // exact frame index
      
      p10_sq96.setAutoDraw(true);
    }
    
    
    // if p10_sq96 is active this frame...
    if (p10_sq96.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq106* updates
    if (t >= 0.0 && p10_sq106.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq106.tStart = t;  // (not accounting for frame time here)
      p10_sq106.frameNStart = frameN;  // exact frame index
      
      p10_sq106.setAutoDraw(true);
    }
    
    
    // if p10_sq106 is active this frame...
    if (p10_sq106.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq116* updates
    if (t >= 0.0 && p10_sq116.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq116.tStart = t;  // (not accounting for frame time here)
      p10_sq116.frameNStart = frameN;  // exact frame index
      
      p10_sq116.setAutoDraw(true);
    }
    
    
    // if p10_sq116 is active this frame...
    if (p10_sq116.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq126* updates
    if (t >= 0.0 && p10_sq126.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq126.tStart = t;  // (not accounting for frame time here)
      p10_sq126.frameNStart = frameN;  // exact frame index
      
      p10_sq126.setAutoDraw(true);
    }
    
    
    // if p10_sq126 is active this frame...
    if (p10_sq126.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq136* updates
    if (t >= 0.0 && p10_sq136.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq136.tStart = t;  // (not accounting for frame time here)
      p10_sq136.frameNStart = frameN;  // exact frame index
      
      p10_sq136.setAutoDraw(true);
    }
    
    
    // if p10_sq136 is active this frame...
    if (p10_sq136.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq146* updates
    if (t >= 0.0 && p10_sq146.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq146.tStart = t;  // (not accounting for frame time here)
      p10_sq146.frameNStart = frameN;  // exact frame index
      
      p10_sq146.setAutoDraw(true);
    }
    
    
    // if p10_sq146 is active this frame...
    if (p10_sq146.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_sq156* updates
    if (t >= 0.0 && p10_sq156.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_sq156.tStart = t;  // (not accounting for frame time here)
      p10_sq156.frameNStart = frameN;  // exact frame index
      
      p10_sq156.setAutoDraw(true);
    }
    
    
    // if p10_sq156 is active this frame...
    if (p10_sq156.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt1* updates
    if (t >= 0.0 && p10_txt1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt1.tStart = t;  // (not accounting for frame time here)
      p10_txt1.frameNStart = frameN;  // exact frame index
      
      p10_txt1.setAutoDraw(true);
    }
    
    
    // if p10_txt1 is active this frame...
    if (p10_txt1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt2* updates
    if (t >= 0.0 && p10_txt2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt2.tStart = t;  // (not accounting for frame time here)
      p10_txt2.frameNStart = frameN;  // exact frame index
      
      p10_txt2.setAutoDraw(true);
    }
    
    
    // if p10_txt2 is active this frame...
    if (p10_txt2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt3* updates
    if (t >= 0.0 && p10_txt3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt3.tStart = t;  // (not accounting for frame time here)
      p10_txt3.frameNStart = frameN;  // exact frame index
      
      p10_txt3.setAutoDraw(true);
    }
    
    
    // if p10_txt3 is active this frame...
    if (p10_txt3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt4* updates
    if (t >= 0.0 && p10_txt4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt4.tStart = t;  // (not accounting for frame time here)
      p10_txt4.frameNStart = frameN;  // exact frame index
      
      p10_txt4.setAutoDraw(true);
    }
    
    
    // if p10_txt4 is active this frame...
    if (p10_txt4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt5* updates
    if (t >= 0.0 && p10_txt5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt5.tStart = t;  // (not accounting for frame time here)
      p10_txt5.frameNStart = frameN;  // exact frame index
      
      p10_txt5.setAutoDraw(true);
    }
    
    
    // if p10_txt5 is active this frame...
    if (p10_txt5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt6* updates
    if (t >= 0.0 && p10_txt6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt6.tStart = t;  // (not accounting for frame time here)
      p10_txt6.frameNStart = frameN;  // exact frame index
      
      p10_txt6.setAutoDraw(true);
    }
    
    
    // if p10_txt6 is active this frame...
    if (p10_txt6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt7* updates
    if (t >= 0.0 && p10_txt7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt7.tStart = t;  // (not accounting for frame time here)
      p10_txt7.frameNStart = frameN;  // exact frame index
      
      p10_txt7.setAutoDraw(true);
    }
    
    
    // if p10_txt7 is active this frame...
    if (p10_txt7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt8* updates
    if (t >= 0.0 && p10_txt8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt8.tStart = t;  // (not accounting for frame time here)
      p10_txt8.frameNStart = frameN;  // exact frame index
      
      p10_txt8.setAutoDraw(true);
    }
    
    
    // if p10_txt8 is active this frame...
    if (p10_txt8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt9* updates
    if (t >= 0.0 && p10_txt9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt9.tStart = t;  // (not accounting for frame time here)
      p10_txt9.frameNStart = frameN;  // exact frame index
      
      p10_txt9.setAutoDraw(true);
    }
    
    
    // if p10_txt9 is active this frame...
    if (p10_txt9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt10* updates
    if (t >= 0.0 && p10_txt10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt10.tStart = t;  // (not accounting for frame time here)
      p10_txt10.frameNStart = frameN;  // exact frame index
      
      p10_txt10.setAutoDraw(true);
    }
    
    
    // if p10_txt10 is active this frame...
    if (p10_txt10.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt11* updates
    if (t >= 0.0 && p10_txt11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt11.tStart = t;  // (not accounting for frame time here)
      p10_txt11.frameNStart = frameN;  // exact frame index
      
      p10_txt11.setAutoDraw(true);
    }
    
    
    // if p10_txt11 is active this frame...
    if (p10_txt11.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt12* updates
    if (t >= 0.0 && p10_txt12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt12.tStart = t;  // (not accounting for frame time here)
      p10_txt12.frameNStart = frameN;  // exact frame index
      
      p10_txt12.setAutoDraw(true);
    }
    
    
    // if p10_txt12 is active this frame...
    if (p10_txt12.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt13* updates
    if (t >= 0.0 && p10_txt13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt13.tStart = t;  // (not accounting for frame time here)
      p10_txt13.frameNStart = frameN;  // exact frame index
      
      p10_txt13.setAutoDraw(true);
    }
    
    
    // if p10_txt13 is active this frame...
    if (p10_txt13.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt14* updates
    if (t >= 0.0 && p10_txt14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt14.tStart = t;  // (not accounting for frame time here)
      p10_txt14.frameNStart = frameN;  // exact frame index
      
      p10_txt14.setAutoDraw(true);
    }
    
    
    // if p10_txt14 is active this frame...
    if (p10_txt14.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt15* updates
    if (t >= 0.0 && p10_txt15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt15.tStart = t;  // (not accounting for frame time here)
      p10_txt15.frameNStart = frameN;  // exact frame index
      
      p10_txt15.setAutoDraw(true);
    }
    
    
    // if p10_txt15 is active this frame...
    if (p10_txt15.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt16* updates
    if (t >= 0.0 && p10_txt16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt16.tStart = t;  // (not accounting for frame time here)
      p10_txt16.frameNStart = frameN;  // exact frame index
      
      p10_txt16.setAutoDraw(true);
    }
    
    
    // if p10_txt16 is active this frame...
    if (p10_txt16.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt17* updates
    if (t >= 0.0 && p10_txt17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt17.tStart = t;  // (not accounting for frame time here)
      p10_txt17.frameNStart = frameN;  // exact frame index
      
      p10_txt17.setAutoDraw(true);
    }
    
    
    // if p10_txt17 is active this frame...
    if (p10_txt17.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt18* updates
    if (t >= 0.0 && p10_txt18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt18.tStart = t;  // (not accounting for frame time here)
      p10_txt18.frameNStart = frameN;  // exact frame index
      
      p10_txt18.setAutoDraw(true);
    }
    
    
    // if p10_txt18 is active this frame...
    if (p10_txt18.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt19* updates
    if (t >= 0.0 && p10_txt19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt19.tStart = t;  // (not accounting for frame time here)
      p10_txt19.frameNStart = frameN;  // exact frame index
      
      p10_txt19.setAutoDraw(true);
    }
    
    
    // if p10_txt19 is active this frame...
    if (p10_txt19.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt20* updates
    if (t >= 0.0 && p10_txt20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt20.tStart = t;  // (not accounting for frame time here)
      p10_txt20.frameNStart = frameN;  // exact frame index
      
      p10_txt20.setAutoDraw(true);
    }
    
    
    // if p10_txt20 is active this frame...
    if (p10_txt20.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt21* updates
    if (t >= 0.0 && p10_txt21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt21.tStart = t;  // (not accounting for frame time here)
      p10_txt21.frameNStart = frameN;  // exact frame index
      
      p10_txt21.setAutoDraw(true);
    }
    
    
    // if p10_txt21 is active this frame...
    if (p10_txt21.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt22* updates
    if (t >= 0.0 && p10_txt22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt22.tStart = t;  // (not accounting for frame time here)
      p10_txt22.frameNStart = frameN;  // exact frame index
      
      p10_txt22.setAutoDraw(true);
    }
    
    
    // if p10_txt22 is active this frame...
    if (p10_txt22.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt23* updates
    if (t >= 0.0 && p10_txt23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt23.tStart = t;  // (not accounting for frame time here)
      p10_txt23.frameNStart = frameN;  // exact frame index
      
      p10_txt23.setAutoDraw(true);
    }
    
    
    // if p10_txt23 is active this frame...
    if (p10_txt23.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt24* updates
    if (t >= 0.0 && p10_txt24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt24.tStart = t;  // (not accounting for frame time here)
      p10_txt24.frameNStart = frameN;  // exact frame index
      
      p10_txt24.setAutoDraw(true);
    }
    
    
    // if p10_txt24 is active this frame...
    if (p10_txt24.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt25* updates
    if (t >= 0.0 && p10_txt25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt25.tStart = t;  // (not accounting for frame time here)
      p10_txt25.frameNStart = frameN;  // exact frame index
      
      p10_txt25.setAutoDraw(true);
    }
    
    
    // if p10_txt25 is active this frame...
    if (p10_txt25.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt26* updates
    if (t >= 0.0 && p10_txt26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt26.tStart = t;  // (not accounting for frame time here)
      p10_txt26.frameNStart = frameN;  // exact frame index
      
      p10_txt26.setAutoDraw(true);
    }
    
    
    // if p10_txt26 is active this frame...
    if (p10_txt26.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt27* updates
    if (t >= 0.0 && p10_txt27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt27.tStart = t;  // (not accounting for frame time here)
      p10_txt27.frameNStart = frameN;  // exact frame index
      
      p10_txt27.setAutoDraw(true);
    }
    
    
    // if p10_txt27 is active this frame...
    if (p10_txt27.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt28* updates
    if (t >= 0.0 && p10_txt28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt28.tStart = t;  // (not accounting for frame time here)
      p10_txt28.frameNStart = frameN;  // exact frame index
      
      p10_txt28.setAutoDraw(true);
    }
    
    
    // if p10_txt28 is active this frame...
    if (p10_txt28.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt29* updates
    if (t >= 0.0 && p10_txt29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt29.tStart = t;  // (not accounting for frame time here)
      p10_txt29.frameNStart = frameN;  // exact frame index
      
      p10_txt29.setAutoDraw(true);
    }
    
    
    // if p10_txt29 is active this frame...
    if (p10_txt29.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt30* updates
    if (t >= 0.0 && p10_txt30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt30.tStart = t;  // (not accounting for frame time here)
      p10_txt30.frameNStart = frameN;  // exact frame index
      
      p10_txt30.setAutoDraw(true);
    }
    
    
    // if p10_txt30 is active this frame...
    if (p10_txt30.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt31* updates
    if (t >= 0.0 && p10_txt31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt31.tStart = t;  // (not accounting for frame time here)
      p10_txt31.frameNStart = frameN;  // exact frame index
      
      p10_txt31.setAutoDraw(true);
    }
    
    
    // if p10_txt31 is active this frame...
    if (p10_txt31.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt32* updates
    if (t >= 0.0 && p10_txt32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt32.tStart = t;  // (not accounting for frame time here)
      p10_txt32.frameNStart = frameN;  // exact frame index
      
      p10_txt32.setAutoDraw(true);
    }
    
    
    // if p10_txt32 is active this frame...
    if (p10_txt32.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt33* updates
    if (t >= 0.0 && p10_txt33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt33.tStart = t;  // (not accounting for frame time here)
      p10_txt33.frameNStart = frameN;  // exact frame index
      
      p10_txt33.setAutoDraw(true);
    }
    
    
    // if p10_txt33 is active this frame...
    if (p10_txt33.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt34* updates
    if (t >= 0.0 && p10_txt34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt34.tStart = t;  // (not accounting for frame time here)
      p10_txt34.frameNStart = frameN;  // exact frame index
      
      p10_txt34.setAutoDraw(true);
    }
    
    
    // if p10_txt34 is active this frame...
    if (p10_txt34.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt35* updates
    if (t >= 0.0 && p10_txt35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt35.tStart = t;  // (not accounting for frame time here)
      p10_txt35.frameNStart = frameN;  // exact frame index
      
      p10_txt35.setAutoDraw(true);
    }
    
    
    // if p10_txt35 is active this frame...
    if (p10_txt35.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt36* updates
    if (t >= 0.0 && p10_txt36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt36.tStart = t;  // (not accounting for frame time here)
      p10_txt36.frameNStart = frameN;  // exact frame index
      
      p10_txt36.setAutoDraw(true);
    }
    
    
    // if p10_txt36 is active this frame...
    if (p10_txt36.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt37* updates
    if (t >= 0.0 && p10_txt37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt37.tStart = t;  // (not accounting for frame time here)
      p10_txt37.frameNStart = frameN;  // exact frame index
      
      p10_txt37.setAutoDraw(true);
    }
    
    
    // if p10_txt37 is active this frame...
    if (p10_txt37.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt38* updates
    if (t >= 0.0 && p10_txt38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt38.tStart = t;  // (not accounting for frame time here)
      p10_txt38.frameNStart = frameN;  // exact frame index
      
      p10_txt38.setAutoDraw(true);
    }
    
    
    // if p10_txt38 is active this frame...
    if (p10_txt38.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt39* updates
    if (t >= 0.0 && p10_txt39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt39.tStart = t;  // (not accounting for frame time here)
      p10_txt39.frameNStart = frameN;  // exact frame index
      
      p10_txt39.setAutoDraw(true);
    }
    
    
    // if p10_txt39 is active this frame...
    if (p10_txt39.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt40* updates
    if (t >= 0.0 && p10_txt40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt40.tStart = t;  // (not accounting for frame time here)
      p10_txt40.frameNStart = frameN;  // exact frame index
      
      p10_txt40.setAutoDraw(true);
    }
    
    
    // if p10_txt40 is active this frame...
    if (p10_txt40.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt41* updates
    if (t >= 0.0 && p10_txt41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt41.tStart = t;  // (not accounting for frame time here)
      p10_txt41.frameNStart = frameN;  // exact frame index
      
      p10_txt41.setAutoDraw(true);
    }
    
    
    // if p10_txt41 is active this frame...
    if (p10_txt41.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt42* updates
    if (t >= 0.0 && p10_txt42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt42.tStart = t;  // (not accounting for frame time here)
      p10_txt42.frameNStart = frameN;  // exact frame index
      
      p10_txt42.setAutoDraw(true);
    }
    
    
    // if p10_txt42 is active this frame...
    if (p10_txt42.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt43* updates
    if (t >= 0.0 && p10_txt43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt43.tStart = t;  // (not accounting for frame time here)
      p10_txt43.frameNStart = frameN;  // exact frame index
      
      p10_txt43.setAutoDraw(true);
    }
    
    
    // if p10_txt43 is active this frame...
    if (p10_txt43.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt44* updates
    if (t >= 0.0 && p10_txt44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt44.tStart = t;  // (not accounting for frame time here)
      p10_txt44.frameNStart = frameN;  // exact frame index
      
      p10_txt44.setAutoDraw(true);
    }
    
    
    // if p10_txt44 is active this frame...
    if (p10_txt44.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt45* updates
    if (t >= 0.0 && p10_txt45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt45.tStart = t;  // (not accounting for frame time here)
      p10_txt45.frameNStart = frameN;  // exact frame index
      
      p10_txt45.setAutoDraw(true);
    }
    
    
    // if p10_txt45 is active this frame...
    if (p10_txt45.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt46* updates
    if (t >= 0.0 && p10_txt46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt46.tStart = t;  // (not accounting for frame time here)
      p10_txt46.frameNStart = frameN;  // exact frame index
      
      p10_txt46.setAutoDraw(true);
    }
    
    
    // if p10_txt46 is active this frame...
    if (p10_txt46.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt47* updates
    if (t >= 0.0 && p10_txt47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt47.tStart = t;  // (not accounting for frame time here)
      p10_txt47.frameNStart = frameN;  // exact frame index
      
      p10_txt47.setAutoDraw(true);
    }
    
    
    // if p10_txt47 is active this frame...
    if (p10_txt47.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt48* updates
    if (t >= 0.0 && p10_txt48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt48.tStart = t;  // (not accounting for frame time here)
      p10_txt48.frameNStart = frameN;  // exact frame index
      
      p10_txt48.setAutoDraw(true);
    }
    
    
    // if p10_txt48 is active this frame...
    if (p10_txt48.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt49* updates
    if (t >= 0.0 && p10_txt49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt49.tStart = t;  // (not accounting for frame time here)
      p10_txt49.frameNStart = frameN;  // exact frame index
      
      p10_txt49.setAutoDraw(true);
    }
    
    
    // if p10_txt49 is active this frame...
    if (p10_txt49.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt50* updates
    if (t >= 0.0 && p10_txt50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt50.tStart = t;  // (not accounting for frame time here)
      p10_txt50.frameNStart = frameN;  // exact frame index
      
      p10_txt50.setAutoDraw(true);
    }
    
    
    // if p10_txt50 is active this frame...
    if (p10_txt50.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt51* updates
    if (t >= 0.0 && p10_txt51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt51.tStart = t;  // (not accounting for frame time here)
      p10_txt51.frameNStart = frameN;  // exact frame index
      
      p10_txt51.setAutoDraw(true);
    }
    
    
    // if p10_txt51 is active this frame...
    if (p10_txt51.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt52* updates
    if (t >= 0.0 && p10_txt52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt52.tStart = t;  // (not accounting for frame time here)
      p10_txt52.frameNStart = frameN;  // exact frame index
      
      p10_txt52.setAutoDraw(true);
    }
    
    
    // if p10_txt52 is active this frame...
    if (p10_txt52.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt53* updates
    if (t >= 0.0 && p10_txt53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt53.tStart = t;  // (not accounting for frame time here)
      p10_txt53.frameNStart = frameN;  // exact frame index
      
      p10_txt53.setAutoDraw(true);
    }
    
    
    // if p10_txt53 is active this frame...
    if (p10_txt53.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt54* updates
    if (t >= 0.0 && p10_txt54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt54.tStart = t;  // (not accounting for frame time here)
      p10_txt54.frameNStart = frameN;  // exact frame index
      
      p10_txt54.setAutoDraw(true);
    }
    
    
    // if p10_txt54 is active this frame...
    if (p10_txt54.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt55* updates
    if (t >= 0.0 && p10_txt55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt55.tStart = t;  // (not accounting for frame time here)
      p10_txt55.frameNStart = frameN;  // exact frame index
      
      p10_txt55.setAutoDraw(true);
    }
    
    
    // if p10_txt55 is active this frame...
    if (p10_txt55.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt56* updates
    if (t >= 0.0 && p10_txt56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt56.tStart = t;  // (not accounting for frame time here)
      p10_txt56.frameNStart = frameN;  // exact frame index
      
      p10_txt56.setAutoDraw(true);
    }
    
    
    // if p10_txt56 is active this frame...
    if (p10_txt56.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt57* updates
    if (t >= 0.0 && p10_txt57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt57.tStart = t;  // (not accounting for frame time here)
      p10_txt57.frameNStart = frameN;  // exact frame index
      
      p10_txt57.setAutoDraw(true);
    }
    
    
    // if p10_txt57 is active this frame...
    if (p10_txt57.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt58* updates
    if (t >= 0.0 && p10_txt58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt58.tStart = t;  // (not accounting for frame time here)
      p10_txt58.frameNStart = frameN;  // exact frame index
      
      p10_txt58.setAutoDraw(true);
    }
    
    
    // if p10_txt58 is active this frame...
    if (p10_txt58.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt59* updates
    if (t >= 0.0 && p10_txt59.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt59.tStart = t;  // (not accounting for frame time here)
      p10_txt59.frameNStart = frameN;  // exact frame index
      
      p10_txt59.setAutoDraw(true);
    }
    
    
    // if p10_txt59 is active this frame...
    if (p10_txt59.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt60* updates
    if (t >= 0.0 && p10_txt60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt60.tStart = t;  // (not accounting for frame time here)
      p10_txt60.frameNStart = frameN;  // exact frame index
      
      p10_txt60.setAutoDraw(true);
    }
    
    
    // if p10_txt60 is active this frame...
    if (p10_txt60.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt61* updates
    if (t >= 0.0 && p10_txt61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt61.tStart = t;  // (not accounting for frame time here)
      p10_txt61.frameNStart = frameN;  // exact frame index
      
      p10_txt61.setAutoDraw(true);
    }
    
    
    // if p10_txt61 is active this frame...
    if (p10_txt61.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt62* updates
    if (t >= 0.0 && p10_txt62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt62.tStart = t;  // (not accounting for frame time here)
      p10_txt62.frameNStart = frameN;  // exact frame index
      
      p10_txt62.setAutoDraw(true);
    }
    
    
    // if p10_txt62 is active this frame...
    if (p10_txt62.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt63* updates
    if (t >= 0.0 && p10_txt63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt63.tStart = t;  // (not accounting for frame time here)
      p10_txt63.frameNStart = frameN;  // exact frame index
      
      p10_txt63.setAutoDraw(true);
    }
    
    
    // if p10_txt63 is active this frame...
    if (p10_txt63.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt64* updates
    if (t >= 0.0 && p10_txt64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt64.tStart = t;  // (not accounting for frame time here)
      p10_txt64.frameNStart = frameN;  // exact frame index
      
      p10_txt64.setAutoDraw(true);
    }
    
    
    // if p10_txt64 is active this frame...
    if (p10_txt64.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt65* updates
    if (t >= 0.0 && p10_txt65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt65.tStart = t;  // (not accounting for frame time here)
      p10_txt65.frameNStart = frameN;  // exact frame index
      
      p10_txt65.setAutoDraw(true);
    }
    
    
    // if p10_txt65 is active this frame...
    if (p10_txt65.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt66* updates
    if (t >= 0.0 && p10_txt66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt66.tStart = t;  // (not accounting for frame time here)
      p10_txt66.frameNStart = frameN;  // exact frame index
      
      p10_txt66.setAutoDraw(true);
    }
    
    
    // if p10_txt66 is active this frame...
    if (p10_txt66.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt67* updates
    if (t >= 0.0 && p10_txt67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt67.tStart = t;  // (not accounting for frame time here)
      p10_txt67.frameNStart = frameN;  // exact frame index
      
      p10_txt67.setAutoDraw(true);
    }
    
    
    // if p10_txt67 is active this frame...
    if (p10_txt67.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt68* updates
    if (t >= 0.0 && p10_txt68.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt68.tStart = t;  // (not accounting for frame time here)
      p10_txt68.frameNStart = frameN;  // exact frame index
      
      p10_txt68.setAutoDraw(true);
    }
    
    
    // if p10_txt68 is active this frame...
    if (p10_txt68.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt69* updates
    if (t >= 0.0 && p10_txt69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt69.tStart = t;  // (not accounting for frame time here)
      p10_txt69.frameNStart = frameN;  // exact frame index
      
      p10_txt69.setAutoDraw(true);
    }
    
    
    // if p10_txt69 is active this frame...
    if (p10_txt69.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt70* updates
    if (t >= 0.0 && p10_txt70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt70.tStart = t;  // (not accounting for frame time here)
      p10_txt70.frameNStart = frameN;  // exact frame index
      
      p10_txt70.setAutoDraw(true);
    }
    
    
    // if p10_txt70 is active this frame...
    if (p10_txt70.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt71* updates
    if (t >= 0.0 && p10_txt71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt71.tStart = t;  // (not accounting for frame time here)
      p10_txt71.frameNStart = frameN;  // exact frame index
      
      p10_txt71.setAutoDraw(true);
    }
    
    
    // if p10_txt71 is active this frame...
    if (p10_txt71.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt72* updates
    if (t >= 0.0 && p10_txt72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt72.tStart = t;  // (not accounting for frame time here)
      p10_txt72.frameNStart = frameN;  // exact frame index
      
      p10_txt72.setAutoDraw(true);
    }
    
    
    // if p10_txt72 is active this frame...
    if (p10_txt72.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt73* updates
    if (t >= 0.0 && p10_txt73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt73.tStart = t;  // (not accounting for frame time here)
      p10_txt73.frameNStart = frameN;  // exact frame index
      
      p10_txt73.setAutoDraw(true);
    }
    
    
    // if p10_txt73 is active this frame...
    if (p10_txt73.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt74* updates
    if (t >= 0.0 && p10_txt74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt74.tStart = t;  // (not accounting for frame time here)
      p10_txt74.frameNStart = frameN;  // exact frame index
      
      p10_txt74.setAutoDraw(true);
    }
    
    
    // if p10_txt74 is active this frame...
    if (p10_txt74.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt75* updates
    if (t >= 0.0 && p10_txt75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt75.tStart = t;  // (not accounting for frame time here)
      p10_txt75.frameNStart = frameN;  // exact frame index
      
      p10_txt75.setAutoDraw(true);
    }
    
    
    // if p10_txt75 is active this frame...
    if (p10_txt75.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt76* updates
    if (t >= 0.0 && p10_txt76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt76.tStart = t;  // (not accounting for frame time here)
      p10_txt76.frameNStart = frameN;  // exact frame index
      
      p10_txt76.setAutoDraw(true);
    }
    
    
    // if p10_txt76 is active this frame...
    if (p10_txt76.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt77* updates
    if (t >= 0.0 && p10_txt77.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt77.tStart = t;  // (not accounting for frame time here)
      p10_txt77.frameNStart = frameN;  // exact frame index
      
      p10_txt77.setAutoDraw(true);
    }
    
    
    // if p10_txt77 is active this frame...
    if (p10_txt77.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt78* updates
    if (t >= 0.0 && p10_txt78.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt78.tStart = t;  // (not accounting for frame time here)
      p10_txt78.frameNStart = frameN;  // exact frame index
      
      p10_txt78.setAutoDraw(true);
    }
    
    
    // if p10_txt78 is active this frame...
    if (p10_txt78.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt79* updates
    if (t >= 0.0 && p10_txt79.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt79.tStart = t;  // (not accounting for frame time here)
      p10_txt79.frameNStart = frameN;  // exact frame index
      
      p10_txt79.setAutoDraw(true);
    }
    
    
    // if p10_txt79 is active this frame...
    if (p10_txt79.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt80* updates
    if (t >= 0.0 && p10_txt80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt80.tStart = t;  // (not accounting for frame time here)
      p10_txt80.frameNStart = frameN;  // exact frame index
      
      p10_txt80.setAutoDraw(true);
    }
    
    
    // if p10_txt80 is active this frame...
    if (p10_txt80.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt81* updates
    if (t >= 0.0 && p10_txt81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt81.tStart = t;  // (not accounting for frame time here)
      p10_txt81.frameNStart = frameN;  // exact frame index
      
      p10_txt81.setAutoDraw(true);
    }
    
    
    // if p10_txt81 is active this frame...
    if (p10_txt81.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt82* updates
    if (t >= 0.0 && p10_txt82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt82.tStart = t;  // (not accounting for frame time here)
      p10_txt82.frameNStart = frameN;  // exact frame index
      
      p10_txt82.setAutoDraw(true);
    }
    
    
    // if p10_txt82 is active this frame...
    if (p10_txt82.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt83* updates
    if (t >= 0.0 && p10_txt83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt83.tStart = t;  // (not accounting for frame time here)
      p10_txt83.frameNStart = frameN;  // exact frame index
      
      p10_txt83.setAutoDraw(true);
    }
    
    
    // if p10_txt83 is active this frame...
    if (p10_txt83.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt84* updates
    if (t >= 0.0 && p10_txt84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt84.tStart = t;  // (not accounting for frame time here)
      p10_txt84.frameNStart = frameN;  // exact frame index
      
      p10_txt84.setAutoDraw(true);
    }
    
    
    // if p10_txt84 is active this frame...
    if (p10_txt84.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt85* updates
    if (t >= 0.0 && p10_txt85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt85.tStart = t;  // (not accounting for frame time here)
      p10_txt85.frameNStart = frameN;  // exact frame index
      
      p10_txt85.setAutoDraw(true);
    }
    
    
    // if p10_txt85 is active this frame...
    if (p10_txt85.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt86* updates
    if (t >= 0.0 && p10_txt86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt86.tStart = t;  // (not accounting for frame time here)
      p10_txt86.frameNStart = frameN;  // exact frame index
      
      p10_txt86.setAutoDraw(true);
    }
    
    
    // if p10_txt86 is active this frame...
    if (p10_txt86.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt87* updates
    if (t >= 0.0 && p10_txt87.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt87.tStart = t;  // (not accounting for frame time here)
      p10_txt87.frameNStart = frameN;  // exact frame index
      
      p10_txt87.setAutoDraw(true);
    }
    
    
    // if p10_txt87 is active this frame...
    if (p10_txt87.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt88* updates
    if (t >= 0.0 && p10_txt88.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt88.tStart = t;  // (not accounting for frame time here)
      p10_txt88.frameNStart = frameN;  // exact frame index
      
      p10_txt88.setAutoDraw(true);
    }
    
    
    // if p10_txt88 is active this frame...
    if (p10_txt88.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt89* updates
    if (t >= 0.0 && p10_txt89.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt89.tStart = t;  // (not accounting for frame time here)
      p10_txt89.frameNStart = frameN;  // exact frame index
      
      p10_txt89.setAutoDraw(true);
    }
    
    
    // if p10_txt89 is active this frame...
    if (p10_txt89.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt90* updates
    if (t >= 0.0 && p10_txt90.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt90.tStart = t;  // (not accounting for frame time here)
      p10_txt90.frameNStart = frameN;  // exact frame index
      
      p10_txt90.setAutoDraw(true);
    }
    
    
    // if p10_txt90 is active this frame...
    if (p10_txt90.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt91* updates
    if (t >= 0.0 && p10_txt91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt91.tStart = t;  // (not accounting for frame time here)
      p10_txt91.frameNStart = frameN;  // exact frame index
      
      p10_txt91.setAutoDraw(true);
    }
    
    
    // if p10_txt91 is active this frame...
    if (p10_txt91.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt92* updates
    if (t >= 0.0 && p10_txt92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt92.tStart = t;  // (not accounting for frame time here)
      p10_txt92.frameNStart = frameN;  // exact frame index
      
      p10_txt92.setAutoDraw(true);
    }
    
    
    // if p10_txt92 is active this frame...
    if (p10_txt92.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt93* updates
    if (t >= 0.0 && p10_txt93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt93.tStart = t;  // (not accounting for frame time here)
      p10_txt93.frameNStart = frameN;  // exact frame index
      
      p10_txt93.setAutoDraw(true);
    }
    
    
    // if p10_txt93 is active this frame...
    if (p10_txt93.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt94* updates
    if (t >= 0.0 && p10_txt94.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt94.tStart = t;  // (not accounting for frame time here)
      p10_txt94.frameNStart = frameN;  // exact frame index
      
      p10_txt94.setAutoDraw(true);
    }
    
    
    // if p10_txt94 is active this frame...
    if (p10_txt94.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt95* updates
    if (t >= 0.0 && p10_txt95.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt95.tStart = t;  // (not accounting for frame time here)
      p10_txt95.frameNStart = frameN;  // exact frame index
      
      p10_txt95.setAutoDraw(true);
    }
    
    
    // if p10_txt95 is active this frame...
    if (p10_txt95.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt96* updates
    if (t >= 0.0 && p10_txt96.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt96.tStart = t;  // (not accounting for frame time here)
      p10_txt96.frameNStart = frameN;  // exact frame index
      
      p10_txt96.setAutoDraw(true);
    }
    
    
    // if p10_txt96 is active this frame...
    if (p10_txt96.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt97* updates
    if (t >= 0.0 && p10_txt97.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt97.tStart = t;  // (not accounting for frame time here)
      p10_txt97.frameNStart = frameN;  // exact frame index
      
      p10_txt97.setAutoDraw(true);
    }
    
    
    // if p10_txt97 is active this frame...
    if (p10_txt97.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt98* updates
    if (t >= 0.0 && p10_txt98.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt98.tStart = t;  // (not accounting for frame time here)
      p10_txt98.frameNStart = frameN;  // exact frame index
      
      p10_txt98.setAutoDraw(true);
    }
    
    
    // if p10_txt98 is active this frame...
    if (p10_txt98.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt99* updates
    if (t >= 0.0 && p10_txt99.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt99.tStart = t;  // (not accounting for frame time here)
      p10_txt99.frameNStart = frameN;  // exact frame index
      
      p10_txt99.setAutoDraw(true);
    }
    
    
    // if p10_txt99 is active this frame...
    if (p10_txt99.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt100* updates
    if (t >= 0.0 && p10_txt100.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt100.tStart = t;  // (not accounting for frame time here)
      p10_txt100.frameNStart = frameN;  // exact frame index
      
      p10_txt100.setAutoDraw(true);
    }
    
    
    // if p10_txt100 is active this frame...
    if (p10_txt100.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_box_next* updates
    if (t >= 0 && p10_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_box_next.tStart = t;  // (not accounting for frame time here)
      p10_box_next.frameNStart = frameN;  // exact frame index
      
      p10_box_next.setAutoDraw(true);
    }
    
    
    // if p10_box_next is active this frame...
    if (p10_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_box_try* updates
    if (t >= 0 && p10_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_box_try.tStart = t;  // (not accounting for frame time here)
      p10_box_try.frameNStart = frameN;  // exact frame index
      
      p10_box_try.setAutoDraw(true);
    }
    
    
    // if p10_box_try is active this frame...
    if (p10_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt_try* updates
    if (t >= 0 && p10_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt_try.tStart = t;  // (not accounting for frame time here)
      p10_txt_try.frameNStart = frameN;  // exact frame index
      
      p10_txt_try.setAutoDraw(true);
    }
    
    
    // if p10_txt_try is active this frame...
    if (p10_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt_next* updates
    if (t >= 0 && p10_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt_next.tStart = t;  // (not accounting for frame time here)
      p10_txt_next.frameNStart = frameN;  // exact frame index
      
      p10_txt_next.setAutoDraw(true);
    }
    
    
    // if p10_txt_next is active this frame...
    if (p10_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p10_txt_try_many* updates
    if (t >= 0 && p10_txt_try_many.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p10_txt_try_many.tStart = t;  // (not accounting for frame time here)
      p10_txt_try_many.frameNStart = frameN;  // exact frame index
      
      p10_txt_try_many.setAutoDraw(true);
    }
    
    
    // if p10_txt_try_many is active this frame...
    if (p10_txt_try_many.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p10_MEM_wordListComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p10_MEM_wordListRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p10_MEM_wordList' ---
    p10_MEM_wordListComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p10_MEM_wordList.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p10_mouse.x', p10_mouse.x);
    psychoJS.experiment.addData('p10_mouse.y', p10_mouse.y);
    psychoJS.experiment.addData('p10_mouse.leftButton', p10_mouse.leftButton);
    psychoJS.experiment.addData('p10_mouse.midButton', p10_mouse.midButton);
    psychoJS.experiment.addData('p10_mouse.rightButton', p10_mouse.rightButton);
    psychoJS.experiment.addData('p10_mouse.time', p10_mouse.time);
    psychoJS.experiment.addData('p10_mouse.clicked_name', p10_mouse.clicked_name);
    
    // Run 'End Routine' code from p10_code_ans
    psychoJS.experiment.addData('p10_isCorrect',p10_isCorrect)
    psychoJS.experiment.addData('p10_ans', p10_ans)
    psychoJS.experiment.addData('p10_ans_Idx', p10_ans_Idx)
    psychoJS.experiment.addData('p10_corrAns',p10_corrAns)
    psychoJS.experiment.addData('p10_corrAns_Idx',p10_corrAns_Idx)
    psychoJS.experiment.addData('p10_countNext',p10_countNext)
    psychoJS.experiment.addData('p10_points',p10_points)
    // the Routine "p10_MEM_wordList" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p10_inTimeMaxDurationReached;
var p10_inTimeMaxDuration;
var p10_inTimeComponents;
function p10_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p10_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p10_inTimeClock.reset();
    routineTimer.reset();
    p10_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p10_inTime.started', globalClock.getTime());
    p10_inTimeMaxDuration = null
    // keep track of which components have finished
    p10_inTimeComponents = [];
    
    p10_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p10_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p10_inTime' ---
    // get current time
    t = p10_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p10_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p10_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p10_inTime' ---
    p10_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p10_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p10_code_inTime
    psychoJS.experiment.addData("p10_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p10_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p11a_CALC_sumMaxDurationReached;
var p11a_keyID;
var p11a_CALC_sumMaxDuration;
var p11a_CALC_sumComponents;
function p11a_CALC_sumRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p11a_CALC_sum' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p11a_CALC_sumClock.reset();
    routineTimer.reset();
    p11a_CALC_sumMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p11a_code
    p11a_keyID = [p11a_key_1, p11a_key_2, p11a_key_3, p11a_key_4, p11a_key_5, p11a_key_6, p11a_key_7, p11a_key_8, p11a_key_9, p11a_key_0, p11a_key_DEL];
    k = 0;
    if (((p11a_mouse.isPressedIn(p11a_box_next) && (lenString_p11a > 1)) && (lenString_p11a <= 3))) {
        p11a_countNext = (p11a_countNext + 1);
        if ((p11a_ans === p11a_corrAns)) {
            p11a_isCorrect = 1;
            p11a_points = 1;
        } else {
            p11a_isCorrect = 0;
            p11a_points = 0;
        }
        loop_waitTillOK_p11a.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p11a_mouse.isPressedIn(p11a_box_next) && (lenString_p11a === 1))) {
            p11a_countNext = (p11a_countNext + 1);
            p11a_opTryBox = 1;
            p11a_opTryTxt = 1;
            p11a_opNextBox = 0;
            p11a_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p11a_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p11a_mouse.isPressedIn(thisKey)) {
                    if ((lenString_p11a < 3)) {
                        p11a_ans = (p11a_ans + p11a_keyNum[k]);
                        lenString_p11a = (lenString_p11a + 1);
                        p11a_screen_txt.text = p11a_ans;
                        p11a_opTryBox = 0;
                        p11a_opTryTxt = 0;
                        p11a_opNextBox = 1;
                        p11a_opNextTxt = 1;
                    }
                    if ((p11a_keyNum[k] === "DEL")) {
                        p11a_ans = "\u20ac";
                        lenString_p11a = 1;
                        p11a_screen_txt.text = p11a_ans;
                        p11a_opTryBox = 0;
                        p11a_opTryTxt = 0;
                        p11a_opNextBox = 1;
                        p11a_opNextTxt = 1;
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p11a_mouse
    // current position of the mouse:
    p11a_mouse.x = [];
    p11a_mouse.y = [];
    p11a_mouse.leftButton = [];
    p11a_mouse.midButton = [];
    p11a_mouse.rightButton = [];
    p11a_mouse.time = [];
    p11a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p11a_mouse.mouseClock.reset();
    p11a_screen_txt.setText(p11a_ans);
    p11a_box_next.setFillColor(new util.Color(BoxNextColor));
    p11a_box_next.setOpacity(p11a_opNextBox);
    p11a_box_next.setLineColor(new util.Color(cGrey));
    p11a_txt_next.setOpacity(p11a_opNextTxt);
    p11a_box_try.setFillColor(new util.Color(BoxTryColor));
    p11a_box_try.setOpacity(p11a_opTryBox);
    p11a_box_try.setLineColor(new util.Color(cGrey));
    p11a_txt_try.setOpacity(p11a_opTryTxt);
    psychoJS.experiment.addData('p11a_CALC_sum.started', globalClock.getTime());
    p11a_CALC_sumMaxDuration = null
    // keep track of which components have finished
    p11a_CALC_sumComponents = [];
    p11a_CALC_sumComponents.push(p11a_txt_q);
    p11a_CALC_sumComponents.push(p11a_mouse);
    p11a_CALC_sumComponents.push(p11a_screen_box);
    p11a_CALC_sumComponents.push(p11a_screen_txt);
    p11a_CALC_sumComponents.push(p11a_key_1);
    p11a_CALC_sumComponents.push(p11a_key_2);
    p11a_CALC_sumComponents.push(p11a_key_3);
    p11a_CALC_sumComponents.push(p11a_key_4);
    p11a_CALC_sumComponents.push(p11a_key_5);
    p11a_CALC_sumComponents.push(p11a_key_6);
    p11a_CALC_sumComponents.push(p11a_key_7);
    p11a_CALC_sumComponents.push(p11a_key_8);
    p11a_CALC_sumComponents.push(p11a_key_9);
    p11a_CALC_sumComponents.push(p11a_key_0);
    p11a_CALC_sumComponents.push(p11a_key_DEL);
    p11a_CALC_sumComponents.push(p11a_box_next);
    p11a_CALC_sumComponents.push(p11a_txt_next);
    p11a_CALC_sumComponents.push(p11a_box_try);
    p11a_CALC_sumComponents.push(p11a_txt_try);
    p11a_CALC_sumComponents.push(p11a_key_txt_1);
    p11a_CALC_sumComponents.push(p11a_key_txt_2);
    p11a_CALC_sumComponents.push(p11a_key_txt_3);
    p11a_CALC_sumComponents.push(p11a_key_txt_4);
    p11a_CALC_sumComponents.push(p11a_key_txt_5);
    p11a_CALC_sumComponents.push(p11a_key_txt_6);
    p11a_CALC_sumComponents.push(p11a_key_txt_7);
    p11a_CALC_sumComponents.push(p11a_key_txt_8);
    p11a_CALC_sumComponents.push(p11a_key_txt_9);
    p11a_CALC_sumComponents.push(p11a_key_txt_0);
    p11a_CALC_sumComponents.push(p11a_key_txt_DEL);
    
    p11a_CALC_sumComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p11a_CALC_sumRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p11a_CALC_sum' ---
    // get current time
    t = p11a_CALC_sumClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p11a_txt_q* updates
    if (t >= 0.0 && p11a_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_txt_q.tStart = t;  // (not accounting for frame time here)
      p11a_txt_q.frameNStart = frameN;  // exact frame index
      
      p11a_txt_q.setAutoDraw(true);
    }
    
    
    // if p11a_txt_q is active this frame...
    if (p11a_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    // *p11a_mouse* updates
    if (t >= 0.0 && p11a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_mouse.tStart = t;  // (not accounting for frame time here)
      p11a_mouse.frameNStart = frameN;  // exact frame index
      
      p11a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p11a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p11a_mouse is active this frame...
    if (p11a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p11a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p11a_mouse.clickableObjects = eval([p11a_key_1, p11a_key_2, p11a_key_3, p11a_key_4, p11a_key_5, p11a_key_6, p11a_key_7, p11a_key_8, p11a_key_9, p11a_key_0, p11a_key_DEL, p11a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p11a_mouse.clickableObjects)) {
              p11a_mouse.clickableObjects = [p11a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p11a_mouse.clickableObjects) {
              if (obj.contains(p11a_mouse)) {
                  gotValidClick = true;
                  p11a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p11a_mouse.clickableObjects = eval([p11a_key_1, p11a_key_2, p11a_key_3, p11a_key_4, p11a_key_5, p11a_key_6, p11a_key_7, p11a_key_8, p11a_key_9, p11a_key_0, p11a_key_DEL, p11a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p11a_mouse.clickableObjects)) {
              p11a_mouse.clickableObjects = [p11a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p11a_mouse.clickableObjects) {
              if (obj.contains(p11a_mouse)) {
                  gotValidClick = true;
                  p11a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p11a_mouse.getPos();
            p11a_mouse.x.push(_mouseXYs[0]);
            p11a_mouse.y.push(_mouseXYs[1]);
            p11a_mouse.leftButton.push(_mouseButtons[0]);
            p11a_mouse.midButton.push(_mouseButtons[1]);
            p11a_mouse.rightButton.push(_mouseButtons[2]);
            p11a_mouse.time.push(p11a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p11a_screen_box* updates
    if (t >= 0.0 && p11a_screen_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_screen_box.tStart = t;  // (not accounting for frame time here)
      p11a_screen_box.frameNStart = frameN;  // exact frame index
      
      p11a_screen_box.setAutoDraw(true);
    }
    
    
    // if p11a_screen_box is active this frame...
    if (p11a_screen_box.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_screen_txt* updates
    if (t >= 0.0 && p11a_screen_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_screen_txt.tStart = t;  // (not accounting for frame time here)
      p11a_screen_txt.frameNStart = frameN;  // exact frame index
      
      p11a_screen_txt.setAutoDraw(true);
    }
    
    
    // if p11a_screen_txt is active this frame...
    if (p11a_screen_txt.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_1* updates
    if (t >= 0.0 && p11a_key_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_1.tStart = t;  // (not accounting for frame time here)
      p11a_key_1.frameNStart = frameN;  // exact frame index
      
      p11a_key_1.setAutoDraw(true);
    }
    
    
    // if p11a_key_1 is active this frame...
    if (p11a_key_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_2* updates
    if (t >= 0.0 && p11a_key_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_2.tStart = t;  // (not accounting for frame time here)
      p11a_key_2.frameNStart = frameN;  // exact frame index
      
      p11a_key_2.setAutoDraw(true);
    }
    
    
    // if p11a_key_2 is active this frame...
    if (p11a_key_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_3* updates
    if (t >= 0.0 && p11a_key_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_3.tStart = t;  // (not accounting for frame time here)
      p11a_key_3.frameNStart = frameN;  // exact frame index
      
      p11a_key_3.setAutoDraw(true);
    }
    
    
    // if p11a_key_3 is active this frame...
    if (p11a_key_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_4* updates
    if (t >= 0.0 && p11a_key_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_4.tStart = t;  // (not accounting for frame time here)
      p11a_key_4.frameNStart = frameN;  // exact frame index
      
      p11a_key_4.setAutoDraw(true);
    }
    
    
    // if p11a_key_4 is active this frame...
    if (p11a_key_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_5* updates
    if (t >= 0.0 && p11a_key_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_5.tStart = t;  // (not accounting for frame time here)
      p11a_key_5.frameNStart = frameN;  // exact frame index
      
      p11a_key_5.setAutoDraw(true);
    }
    
    
    // if p11a_key_5 is active this frame...
    if (p11a_key_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_6* updates
    if (t >= 0.0 && p11a_key_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_6.tStart = t;  // (not accounting for frame time here)
      p11a_key_6.frameNStart = frameN;  // exact frame index
      
      p11a_key_6.setAutoDraw(true);
    }
    
    
    // if p11a_key_6 is active this frame...
    if (p11a_key_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_7* updates
    if (t >= 0.0 && p11a_key_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_7.tStart = t;  // (not accounting for frame time here)
      p11a_key_7.frameNStart = frameN;  // exact frame index
      
      p11a_key_7.setAutoDraw(true);
    }
    
    
    // if p11a_key_7 is active this frame...
    if (p11a_key_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_8* updates
    if (t >= 0.0 && p11a_key_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_8.tStart = t;  // (not accounting for frame time here)
      p11a_key_8.frameNStart = frameN;  // exact frame index
      
      p11a_key_8.setAutoDraw(true);
    }
    
    
    // if p11a_key_8 is active this frame...
    if (p11a_key_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_9* updates
    if (t >= 0.0 && p11a_key_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_9.tStart = t;  // (not accounting for frame time here)
      p11a_key_9.frameNStart = frameN;  // exact frame index
      
      p11a_key_9.setAutoDraw(true);
    }
    
    
    // if p11a_key_9 is active this frame...
    if (p11a_key_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_0* updates
    if (t >= 0.0 && p11a_key_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_0.tStart = t;  // (not accounting for frame time here)
      p11a_key_0.frameNStart = frameN;  // exact frame index
      
      p11a_key_0.setAutoDraw(true);
    }
    
    
    // if p11a_key_0 is active this frame...
    if (p11a_key_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_DEL* updates
    if (t >= 0.0 && p11a_key_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_DEL.tStart = t;  // (not accounting for frame time here)
      p11a_key_DEL.frameNStart = frameN;  // exact frame index
      
      p11a_key_DEL.setAutoDraw(true);
    }
    
    
    // if p11a_key_DEL is active this frame...
    if (p11a_key_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_box_next* updates
    if (t >= 0.0 && p11a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_box_next.tStart = t;  // (not accounting for frame time here)
      p11a_box_next.frameNStart = frameN;  // exact frame index
      
      p11a_box_next.setAutoDraw(true);
    }
    
    
    // if p11a_box_next is active this frame...
    if (p11a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_txt_next* updates
    if (t >= 0.0 && p11a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_txt_next.tStart = t;  // (not accounting for frame time here)
      p11a_txt_next.frameNStart = frameN;  // exact frame index
      
      p11a_txt_next.setAutoDraw(true);
    }
    
    
    // if p11a_txt_next is active this frame...
    if (p11a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_box_try* updates
    if (t >= 0.0 && p11a_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_box_try.tStart = t;  // (not accounting for frame time here)
      p11a_box_try.frameNStart = frameN;  // exact frame index
      
      p11a_box_try.setAutoDraw(true);
    }
    
    
    // if p11a_box_try is active this frame...
    if (p11a_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_txt_try* updates
    if (t >= 0.0 && p11a_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_txt_try.tStart = t;  // (not accounting for frame time here)
      p11a_txt_try.frameNStart = frameN;  // exact frame index
      
      p11a_txt_try.setAutoDraw(true);
    }
    
    
    // if p11a_txt_try is active this frame...
    if (p11a_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_1* updates
    if (t >= 0.0 && p11a_key_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_1.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_1.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_1.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_1 is active this frame...
    if (p11a_key_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_2* updates
    if (t >= 0.0 && p11a_key_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_2.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_2.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_2.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_2 is active this frame...
    if (p11a_key_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_3* updates
    if (t >= 0.0 && p11a_key_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_3.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_3.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_3.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_3 is active this frame...
    if (p11a_key_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_4* updates
    if (t >= 0.0 && p11a_key_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_4.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_4.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_4.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_4 is active this frame...
    if (p11a_key_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_5* updates
    if (t >= 0.0 && p11a_key_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_5.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_5.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_5.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_5 is active this frame...
    if (p11a_key_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_6* updates
    if (t >= 0.0 && p11a_key_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_6.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_6.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_6.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_6 is active this frame...
    if (p11a_key_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_7* updates
    if (t >= 0.0 && p11a_key_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_7.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_7.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_7.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_7 is active this frame...
    if (p11a_key_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_8* updates
    if (t >= 0.0 && p11a_key_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_8.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_8.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_8.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_8 is active this frame...
    if (p11a_key_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_9* updates
    if (t >= 0.0 && p11a_key_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_9.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_9.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_9.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_9 is active this frame...
    if (p11a_key_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_0* updates
    if (t >= 0.0 && p11a_key_txt_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_0.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_0.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_0.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_0 is active this frame...
    if (p11a_key_txt_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11a_key_txt_DEL* updates
    if (t >= 0.0 && p11a_key_txt_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11a_key_txt_DEL.tStart = t;  // (not accounting for frame time here)
      p11a_key_txt_DEL.frameNStart = frameN;  // exact frame index
      
      p11a_key_txt_DEL.setAutoDraw(true);
    }
    
    
    // if p11a_key_txt_DEL is active this frame...
    if (p11a_key_txt_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p11a_CALC_sumComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p11a_CALC_sumRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p11a_CALC_sum' ---
    p11a_CALC_sumComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p11a_CALC_sum.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p11a_mouse.x', p11a_mouse.x);
    psychoJS.experiment.addData('p11a_mouse.y', p11a_mouse.y);
    psychoJS.experiment.addData('p11a_mouse.leftButton', p11a_mouse.leftButton);
    psychoJS.experiment.addData('p11a_mouse.midButton', p11a_mouse.midButton);
    psychoJS.experiment.addData('p11a_mouse.rightButton', p11a_mouse.rightButton);
    psychoJS.experiment.addData('p11a_mouse.time', p11a_mouse.time);
    psychoJS.experiment.addData('p11a_mouse.clicked_name', p11a_mouse.clicked_name);
    
    // Run 'End Routine' code from p11a_code_ans
    psychoJS.experiment.addData('p11a_isCorrect',p11a_isCorrect)
    psychoJS.experiment.addData('p11a_ans', p11a_ans)
    psychoJS.experiment.addData('p11a_corrAns',p11a_corrAns)
    psychoJS.experiment.addData('p11a_countNext',p11a_countNext)
    psychoJS.experiment.addData('p11a_points',p11a_points)
    // the Routine "p11a_CALC_sum" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p11a_inTimeMaxDurationReached;
var p11a_inTimeMaxDuration;
var p11a_inTimeComponents;
function p11a_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p11a_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p11a_inTimeClock.reset();
    routineTimer.reset();
    p11a_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p11a_inTime.started', globalClock.getTime());
    p11a_inTimeMaxDuration = null
    // keep track of which components have finished
    p11a_inTimeComponents = [];
    
    p11a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p11a_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p11a_inTime' ---
    // get current time
    t = p11a_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p11a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p11a_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p11a_inTime' ---
    p11a_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p11a_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p11a_code_inTime
    psychoJS.experiment.addData("p11a_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p11a_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p11b_CALC_diffMaxDurationReached;
var p11b_keyID;
var p11b_CALC_diffMaxDuration;
var p11b_CALC_diffComponents;
function p11b_CALC_diffRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p11b_CALC_diff' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p11b_CALC_diffClock.reset();
    routineTimer.reset();
    p11b_CALC_diffMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p11b_code
    p11b_keyID = [p11b_key_1, p11b_key_2, p11b_key_3, p11b_key_4, p11b_key_5, p11b_key_6, p11b_key_7, p11b_key_8, p11b_key_9, p11b_key_0, p11b_key_DEL];
    k = 0;
    if (((p11b_mouse.isPressedIn(p11b_box_next) && (lenString_p11b > 1)) && (lenString_p11b <= 3))) {
        p11b_countNext = (p11b_countNext + 1);
        if ((p11b_ans === p11b_corrAns)) {
            p11b_isCorrect = 1;
            p11b_points = 2;
        } else {
            p11b_isCorrect = 0;
            p11b_points = 0;
        }
        loop_waitTillOK_p11b.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p11b_mouse.isPressedIn(p11b_box_next) && (lenString_p11b === 1))) {
            p11b_countNext = (p11b_countNext + 1);
            p11b_opTryBox = 1;
            p11b_opTryTxt = 1;
            p11b_opNextBox = 0;
            p11b_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p11b_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p11b_mouse.isPressedIn(thisKey)) {
                    if ((lenString_p11b < 3)) {
                        p11b_ans = (p11b_ans + p11b_keyNum[k]);
                        lenString_p11b = (lenString_p11b + 1);
                        p11b_screen_txt.text = p11b_ans;
                        p11b_opTryBox = 0;
                        p11b_opTryTxt = 0;
                        p11b_opNextBox = 1;
                        p11b_opNextTxt = 1;
                    }
                    if ((p11b_keyNum[k] === "DEL")) {
                        p11b_ans = "\u20ac";
                        lenString_p11b = 1;
                        p11b_screen_txt.text = p11b_ans;
                        p11b_opTryBox = 0;
                        p11b_opTryTxt = 0;
                        p11b_opNextBox = 1;
                        p11b_opNextTxt = 1;
                    }
                }
            }
        }
    }
    
    // setup some python lists for storing info about the p11b_mouse
    // current position of the mouse:
    p11b_mouse.x = [];
    p11b_mouse.y = [];
    p11b_mouse.leftButton = [];
    p11b_mouse.midButton = [];
    p11b_mouse.rightButton = [];
    p11b_mouse.time = [];
    p11b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p11b_mouse.mouseClock.reset();
    p11b_screen_txt.setText(p11b_ans);
    p11b_box_next.setFillColor(new util.Color(BoxNextColor));
    p11b_box_next.setOpacity(p11b_opNextBox);
    p11b_box_next.setLineColor(new util.Color(cGrey));
    p11b_txt_next.setOpacity(p11b_opNextTxt);
    p11b_box_try.setFillColor(new util.Color(BoxTryColor));
    p11b_box_try.setOpacity(p11b_opTryBox);
    p11b_box_try.setLineColor(new util.Color(cGrey));
    p11b_txt_try.setOpacity(p11b_opTryTxt);
    psychoJS.experiment.addData('p11b_CALC_diff.started', globalClock.getTime());
    p11b_CALC_diffMaxDuration = null
    // keep track of which components have finished
    p11b_CALC_diffComponents = [];
    p11b_CALC_diffComponents.push(p11b_txt_q);
    p11b_CALC_diffComponents.push(p11b_mouse);
    p11b_CALC_diffComponents.push(p11b_screen_box);
    p11b_CALC_diffComponents.push(p11b_screen_txt);
    p11b_CALC_diffComponents.push(p11b_key_1);
    p11b_CALC_diffComponents.push(p11b_key_2);
    p11b_CALC_diffComponents.push(p11b_key_3);
    p11b_CALC_diffComponents.push(p11b_key_4);
    p11b_CALC_diffComponents.push(p11b_key_5);
    p11b_CALC_diffComponents.push(p11b_key_6);
    p11b_CALC_diffComponents.push(p11b_key_7);
    p11b_CALC_diffComponents.push(p11b_key_8);
    p11b_CALC_diffComponents.push(p11b_key_9);
    p11b_CALC_diffComponents.push(p11b_key_0);
    p11b_CALC_diffComponents.push(p11b_key_DEL);
    p11b_CALC_diffComponents.push(p11b_box_next);
    p11b_CALC_diffComponents.push(p11b_txt_next);
    p11b_CALC_diffComponents.push(p11b_box_try);
    p11b_CALC_diffComponents.push(p11b_txt_try);
    p11b_CALC_diffComponents.push(p11b_key_txt_1);
    p11b_CALC_diffComponents.push(p11b_key_txt_2);
    p11b_CALC_diffComponents.push(p11b_key_txt_3);
    p11b_CALC_diffComponents.push(p11b_key_txt_4);
    p11b_CALC_diffComponents.push(p11b_key_txt_5);
    p11b_CALC_diffComponents.push(p11b_key_txt_6);
    p11b_CALC_diffComponents.push(p11b_key_txt_7);
    p11b_CALC_diffComponents.push(p11b_key_txt_8);
    p11b_CALC_diffComponents.push(p11b_key_txt_9);
    p11b_CALC_diffComponents.push(p11b_key_txt_0);
    p11b_CALC_diffComponents.push(p11b_key_txt_DEL);
    
    p11b_CALC_diffComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p11b_CALC_diffRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p11b_CALC_diff' ---
    // get current time
    t = p11b_CALC_diffClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p11b_txt_q* updates
    if (t >= 0.0 && p11b_txt_q.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_txt_q.tStart = t;  // (not accounting for frame time here)
      p11b_txt_q.frameNStart = frameN;  // exact frame index
      
      p11b_txt_q.setAutoDraw(true);
    }
    
    
    // if p11b_txt_q is active this frame...
    if (p11b_txt_q.status === PsychoJS.Status.STARTED) {
    }
    
    // *p11b_mouse* updates
    if (t >= 0.0 && p11b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_mouse.tStart = t;  // (not accounting for frame time here)
      p11b_mouse.frameNStart = frameN;  // exact frame index
      
      p11b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p11b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p11b_mouse is active this frame...
    if (p11b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p11b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p11b_mouse.clickableObjects = eval([p11b_key_1, p11b_key_2, p11b_key_3, p11b_key_4, p11b_key_5, p11b_key_6, p11b_key_7, p11b_key_8, p11b_key_9, p11b_key_0, p11b_key_DEL, p11b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p11b_mouse.clickableObjects)) {
              p11b_mouse.clickableObjects = [p11b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p11b_mouse.clickableObjects) {
              if (obj.contains(p11b_mouse)) {
                  gotValidClick = true;
                  p11b_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p11b_mouse.clickableObjects = eval([p11b_key_1, p11b_key_2, p11b_key_3, p11b_key_4, p11b_key_5, p11b_key_6, p11b_key_7, p11b_key_8, p11b_key_9, p11b_key_0, p11b_key_DEL, p11b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p11b_mouse.clickableObjects)) {
              p11b_mouse.clickableObjects = [p11b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p11b_mouse.clickableObjects) {
              if (obj.contains(p11b_mouse)) {
                  gotValidClick = true;
                  p11b_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p11b_mouse.getPos();
            p11b_mouse.x.push(_mouseXYs[0]);
            p11b_mouse.y.push(_mouseXYs[1]);
            p11b_mouse.leftButton.push(_mouseButtons[0]);
            p11b_mouse.midButton.push(_mouseButtons[1]);
            p11b_mouse.rightButton.push(_mouseButtons[2]);
            p11b_mouse.time.push(p11b_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p11b_screen_box* updates
    if (t >= 0.0 && p11b_screen_box.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_screen_box.tStart = t;  // (not accounting for frame time here)
      p11b_screen_box.frameNStart = frameN;  // exact frame index
      
      p11b_screen_box.setAutoDraw(true);
    }
    
    
    // if p11b_screen_box is active this frame...
    if (p11b_screen_box.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_screen_txt* updates
    if (t >= 0.0 && p11b_screen_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_screen_txt.tStart = t;  // (not accounting for frame time here)
      p11b_screen_txt.frameNStart = frameN;  // exact frame index
      
      p11b_screen_txt.setAutoDraw(true);
    }
    
    
    // if p11b_screen_txt is active this frame...
    if (p11b_screen_txt.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_1* updates
    if (t >= 0.0 && p11b_key_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_1.tStart = t;  // (not accounting for frame time here)
      p11b_key_1.frameNStart = frameN;  // exact frame index
      
      p11b_key_1.setAutoDraw(true);
    }
    
    
    // if p11b_key_1 is active this frame...
    if (p11b_key_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_2* updates
    if (t >= 0.0 && p11b_key_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_2.tStart = t;  // (not accounting for frame time here)
      p11b_key_2.frameNStart = frameN;  // exact frame index
      
      p11b_key_2.setAutoDraw(true);
    }
    
    
    // if p11b_key_2 is active this frame...
    if (p11b_key_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_3* updates
    if (t >= 0.0 && p11b_key_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_3.tStart = t;  // (not accounting for frame time here)
      p11b_key_3.frameNStart = frameN;  // exact frame index
      
      p11b_key_3.setAutoDraw(true);
    }
    
    
    // if p11b_key_3 is active this frame...
    if (p11b_key_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_4* updates
    if (t >= 0.0 && p11b_key_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_4.tStart = t;  // (not accounting for frame time here)
      p11b_key_4.frameNStart = frameN;  // exact frame index
      
      p11b_key_4.setAutoDraw(true);
    }
    
    
    // if p11b_key_4 is active this frame...
    if (p11b_key_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_5* updates
    if (t >= 0.0 && p11b_key_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_5.tStart = t;  // (not accounting for frame time here)
      p11b_key_5.frameNStart = frameN;  // exact frame index
      
      p11b_key_5.setAutoDraw(true);
    }
    
    
    // if p11b_key_5 is active this frame...
    if (p11b_key_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_6* updates
    if (t >= 0.0 && p11b_key_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_6.tStart = t;  // (not accounting for frame time here)
      p11b_key_6.frameNStart = frameN;  // exact frame index
      
      p11b_key_6.setAutoDraw(true);
    }
    
    
    // if p11b_key_6 is active this frame...
    if (p11b_key_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_7* updates
    if (t >= 0.0 && p11b_key_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_7.tStart = t;  // (not accounting for frame time here)
      p11b_key_7.frameNStart = frameN;  // exact frame index
      
      p11b_key_7.setAutoDraw(true);
    }
    
    
    // if p11b_key_7 is active this frame...
    if (p11b_key_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_8* updates
    if (t >= 0.0 && p11b_key_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_8.tStart = t;  // (not accounting for frame time here)
      p11b_key_8.frameNStart = frameN;  // exact frame index
      
      p11b_key_8.setAutoDraw(true);
    }
    
    
    // if p11b_key_8 is active this frame...
    if (p11b_key_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_9* updates
    if (t >= 0.0 && p11b_key_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_9.tStart = t;  // (not accounting for frame time here)
      p11b_key_9.frameNStart = frameN;  // exact frame index
      
      p11b_key_9.setAutoDraw(true);
    }
    
    
    // if p11b_key_9 is active this frame...
    if (p11b_key_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_0* updates
    if (t >= 0.0 && p11b_key_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_0.tStart = t;  // (not accounting for frame time here)
      p11b_key_0.frameNStart = frameN;  // exact frame index
      
      p11b_key_0.setAutoDraw(true);
    }
    
    
    // if p11b_key_0 is active this frame...
    if (p11b_key_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_DEL* updates
    if (t >= 0.0 && p11b_key_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_DEL.tStart = t;  // (not accounting for frame time here)
      p11b_key_DEL.frameNStart = frameN;  // exact frame index
      
      p11b_key_DEL.setAutoDraw(true);
    }
    
    
    // if p11b_key_DEL is active this frame...
    if (p11b_key_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_box_next* updates
    if (t >= 0.0 && p11b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_box_next.tStart = t;  // (not accounting for frame time here)
      p11b_box_next.frameNStart = frameN;  // exact frame index
      
      p11b_box_next.setAutoDraw(true);
    }
    
    
    // if p11b_box_next is active this frame...
    if (p11b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_txt_next* updates
    if (t >= 0.0 && p11b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_txt_next.tStart = t;  // (not accounting for frame time here)
      p11b_txt_next.frameNStart = frameN;  // exact frame index
      
      p11b_txt_next.setAutoDraw(true);
    }
    
    
    // if p11b_txt_next is active this frame...
    if (p11b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_box_try* updates
    if (t >= 0.0 && p11b_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_box_try.tStart = t;  // (not accounting for frame time here)
      p11b_box_try.frameNStart = frameN;  // exact frame index
      
      p11b_box_try.setAutoDraw(true);
    }
    
    
    // if p11b_box_try is active this frame...
    if (p11b_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_txt_try* updates
    if (t >= 0.0 && p11b_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_txt_try.tStart = t;  // (not accounting for frame time here)
      p11b_txt_try.frameNStart = frameN;  // exact frame index
      
      p11b_txt_try.setAutoDraw(true);
    }
    
    
    // if p11b_txt_try is active this frame...
    if (p11b_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_1* updates
    if (t >= 0.0 && p11b_key_txt_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_1.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_1.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_1.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_1 is active this frame...
    if (p11b_key_txt_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_2* updates
    if (t >= 0.0 && p11b_key_txt_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_2.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_2.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_2.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_2 is active this frame...
    if (p11b_key_txt_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_3* updates
    if (t >= 0.0 && p11b_key_txt_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_3.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_3.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_3.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_3 is active this frame...
    if (p11b_key_txt_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_4* updates
    if (t >= 0.0 && p11b_key_txt_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_4.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_4.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_4.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_4 is active this frame...
    if (p11b_key_txt_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_5* updates
    if (t >= 0.0 && p11b_key_txt_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_5.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_5.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_5.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_5 is active this frame...
    if (p11b_key_txt_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_6* updates
    if (t >= 0.0 && p11b_key_txt_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_6.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_6.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_6.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_6 is active this frame...
    if (p11b_key_txt_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_7* updates
    if (t >= 0.0 && p11b_key_txt_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_7.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_7.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_7.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_7 is active this frame...
    if (p11b_key_txt_7.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_8* updates
    if (t >= 0.0 && p11b_key_txt_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_8.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_8.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_8.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_8 is active this frame...
    if (p11b_key_txt_8.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_9* updates
    if (t >= 0.0 && p11b_key_txt_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_9.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_9.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_9.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_9 is active this frame...
    if (p11b_key_txt_9.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_0* updates
    if (t >= 0.0 && p11b_key_txt_0.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_0.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_0.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_0.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_0 is active this frame...
    if (p11b_key_txt_0.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p11b_key_txt_DEL* updates
    if (t >= 0.0 && p11b_key_txt_DEL.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p11b_key_txt_DEL.tStart = t;  // (not accounting for frame time here)
      p11b_key_txt_DEL.frameNStart = frameN;  // exact frame index
      
      p11b_key_txt_DEL.setAutoDraw(true);
    }
    
    
    // if p11b_key_txt_DEL is active this frame...
    if (p11b_key_txt_DEL.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p11b_CALC_diffComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p11b_CALC_diffRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p11b_CALC_diff' ---
    p11b_CALC_diffComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p11b_CALC_diff.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p11b_mouse.x', p11b_mouse.x);
    psychoJS.experiment.addData('p11b_mouse.y', p11b_mouse.y);
    psychoJS.experiment.addData('p11b_mouse.leftButton', p11b_mouse.leftButton);
    psychoJS.experiment.addData('p11b_mouse.midButton', p11b_mouse.midButton);
    psychoJS.experiment.addData('p11b_mouse.rightButton', p11b_mouse.rightButton);
    psychoJS.experiment.addData('p11b_mouse.time', p11b_mouse.time);
    psychoJS.experiment.addData('p11b_mouse.clicked_name', p11b_mouse.clicked_name);
    
    // Run 'End Routine' code from p11b_code_ans
    psychoJS.experiment.addData('p11b_isCorrect',p11b_isCorrect)
    psychoJS.experiment.addData('p11b_ans', p11b_ans)
    psychoJS.experiment.addData('p11b_corrAns',p11b_corrAns)
    psychoJS.experiment.addData('p11b_countNext',p11b_countNext)
    psychoJS.experiment.addData('p11b_points',p11b_points)
    // the Routine "p11b_CALC_diff" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p11b_inTimeMaxDurationReached;
var p11b_inTimeMaxDuration;
var p11b_inTimeComponents;
function p11b_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p11b_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p11b_inTimeClock.reset();
    routineTimer.reset();
    p11b_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p11b_inTime.started', globalClock.getTime());
    p11b_inTimeMaxDuration = null
    // keep track of which components have finished
    p11b_inTimeComponents = [];
    
    p11b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p11b_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p11b_inTime' ---
    // get current time
    t = p11b_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p11b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p11b_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p11b_inTime' ---
    p11b_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p11b_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p11b_code_inTime
    psychoJS.experiment.addData("p11b_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p11b_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12MaxDurationReached;
var p12MaxDuration;
var p12Components;
function p12RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12Clock.reset();
    routineTimer.reset();
    p12MaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p12_mouse
    // current position of the mouse:
    p12_mouse.x = [];
    p12_mouse.y = [];
    p12_mouse.leftButton = [];
    p12_mouse.midButton = [];
    p12_mouse.rightButton = [];
    p12_mouse.time = [];
    p12_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p12_mouse.mouseClock.reset();
    p12_box_next.setFillColor(new util.Color(BoxNextColor));
    p12_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p12.started', globalClock.getTime());
    p12MaxDuration = null
    // keep track of which components have finished
    p12Components = [];
    p12Components.push(p12_img_instr);
    p12Components.push(p12_mouse);
    p12Components.push(p12_box_next);
    p12Components.push(p12_txt_next);
    
    p12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12' ---
    // get current time
    t = p12Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p12_img_instr* updates
    if (t >= 0.0 && p12_img_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12_img_instr.tStart = t;  // (not accounting for frame time here)
      p12_img_instr.frameNStart = frameN;  // exact frame index
      
      p12_img_instr.setAutoDraw(true);
    }
    
    
    // if p12_img_instr is active this frame...
    if (p12_img_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p12_mouse* updates
    if (t >= 0.0 && p12_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12_mouse.tStart = t;  // (not accounting for frame time here)
      p12_mouse.frameNStart = frameN;  // exact frame index
      
      p12_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p12_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p12_mouse is active this frame...
    if (p12_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p12_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12_mouse.clickableObjects = eval(p12_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12_mouse.clickableObjects)) {
              p12_mouse.clickableObjects = [p12_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12_mouse.clickableObjects) {
              if (obj.contains(p12_mouse)) {
                  gotValidClick = true;
                  p12_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12_mouse.clickableObjects = eval(p12_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12_mouse.clickableObjects)) {
              p12_mouse.clickableObjects = [p12_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12_mouse.clickableObjects) {
              if (obj.contains(p12_mouse)) {
                  gotValidClick = true;
                  p12_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p12_mouse.getPos();
            p12_mouse.x.push(_mouseXYs[0]);
            p12_mouse.y.push(_mouseXYs[1]);
            p12_mouse.leftButton.push(_mouseButtons[0]);
            p12_mouse.midButton.push(_mouseButtons[1]);
            p12_mouse.rightButton.push(_mouseButtons[2]);
            p12_mouse.time.push(p12_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p12_box_next* updates
    if (t >= 0.0 && p12_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12_box_next.tStart = t;  // (not accounting for frame time here)
      p12_box_next.frameNStart = frameN;  // exact frame index
      
      p12_box_next.setAutoDraw(true);
    }
    
    
    // if p12_box_next is active this frame...
    if (p12_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12_txt_next* updates
    if (t >= 0.0 && p12_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12_txt_next.tStart = t;  // (not accounting for frame time here)
      p12_txt_next.frameNStart = frameN;  // exact frame index
      
      p12_txt_next.setAutoDraw(true);
    }
    
    
    // if p12_txt_next is active this frame...
    if (p12_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12' ---
    p12Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p12_mouse.x', p12_mouse.x);
    psychoJS.experiment.addData('p12_mouse.y', p12_mouse.y);
    psychoJS.experiment.addData('p12_mouse.leftButton', p12_mouse.leftButton);
    psychoJS.experiment.addData('p12_mouse.midButton', p12_mouse.midButton);
    psychoJS.experiment.addData('p12_mouse.rightButton', p12_mouse.rightButton);
    psychoJS.experiment.addData('p12_mouse.time', p12_mouse.time);
    psychoJS.experiment.addData('p12_mouse.clicked_name', p12_mouse.clicked_name);
    
    // the Routine "p12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12a_VS_shapesMaxDurationReached;
var p12a_stimID;
var p12a_VS_shapesMaxDuration;
var p12a_VS_shapesComponents;
function p12a_VS_shapesRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12a_VS_shapes' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12a_VS_shapesClock.reset();
    routineTimer.reset();
    p12a_VS_shapesMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p12a_code
    p12a_stimID = [p12a_img_1, p12a_img_2, p12a_img_3, p12a_img_4, p12a_img_5, p12a_img_6];
    k = 0;
    i = 0;
    if ((p12a_mouse.isPressedIn(p12a_box_next) && (util.sum(p12a_isPicked) === 2))) {
        p12a_countNext = (p12a_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p12a_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p12a_ans_Idx = (p12a_ans_Idx + [i]);
                p12a_ans = ((p12a_ans + ",") + p12a_words[i]);
                p12a_countCorrect = (p12a_countCorrect + (val * p12a_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p12a_countCorrect === util.sum(p12a_corrAns_Vec))) {
            p12a_isCorrect = 1;
            p12a_points = 1;
        } else {
            p12a_isCorrect = 0;
            p12a_points = 0;
        }
        loop_waitTillOK_p12a.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p12a_mouse.isPressedIn(p12a_box_next) && (util.sum(p12a_isPicked) > 2))) {
            p12a_countNext = (p12a_countNext + 1);
            p12a_opTryBox = 1;
            p12a_opTryTxt = 0;
            p12a_opTryManyTxt = 1;
            p12a_opNextBox = 0;
            p12a_opNextTxt = 0;
        } else {
            if ((p12a_mouse.isPressedIn(p12a_box_next) && (util.sum(p12a_isPicked) < 2))) {
                p12a_countNext = (p12a_countNext + 1);
                p12a_opTryBox = 1;
                p12a_opTryTxt = 1;
                p12a_opTryManyTxt = 0;
                p12a_opNextBox = 0;
                p12a_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p12a_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p12a_mouse.isPressedIn(thisStim) && (p12a_isPicked[k] === 0))) {
                        p12a_stimColors[k] = cAzul;
                        p12a_isPicked[k] = 1;
                        p12a_opTryBox = 0;
                        p12a_opTryTxt = 0;
                        p12a_opTryManyTxt = 0;
                        p12a_opNextBox = 1;
                        p12a_opNextTxt = 1;
                    } else {
                        if ((p12a_mouse.isPressedIn(thisStim) && (p12a_isPicked[k] === 1))) {
                            p12a_stimColors[k] = cWhite;
                            p12a_isPicked[k] = 0;
                            p12a_opTryBox = 0;
                            p12a_opTryTxt = 0;
                            p12a_opTryManyTxt = 0;
                            p12a_opNextBox = 1;
                            p12a_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    p12a_sq6.setFillColor(new util.Color(p12a_stimColors[6]));
    p12a_sq6.setLineColor(new util.Color(p12a_stimColors[6]));
    p12a_sq5.setFillColor(new util.Color(p12a_stimColors[5]));
    p12a_sq5.setLineColor(new util.Color(p12a_stimColors[5]));
    p12a_sq4.setFillColor(new util.Color(p12a_stimColors[4]));
    p12a_sq4.setLineColor(new util.Color(p12a_stimColors[4]));
    p12a_sq3.setFillColor(new util.Color(p12a_stimColors[3]));
    p12a_sq3.setLineColor(new util.Color(p12a_stimColors[3]));
    p12a_sq2.setFillColor(new util.Color(p12a_stimColors[2]));
    p12a_sq2.setLineColor(new util.Color(p12a_stimColors[2]));
    p12a_sq1.setFillColor(new util.Color(p12a_stimColors[1]));
    p12a_sq1.setLineColor(new util.Color(p12a_stimColors[1]));
    p12a_box_next.setFillColor(new util.Color(BoxNextColor));
    p12a_box_next.setOpacity(p12a_opNextBox);
    p12a_box_next.setLineColor(new util.Color(cGrey));
    p12a_txt_next.setOpacity(p12a_opNextTxt);
    p12a_box_try.setFillColor(new util.Color(BoxTryColor));
    p12a_box_try.setOpacity(p12a_opTryBox);
    p12a_box_try.setLineColor(new util.Color(cGrey));
    p12a_txt_try.setOpacity(p12a_opTryTxt);
    p12a_txt_try_many.setOpacity(p12a_opTryManyTxt);
    // setup some python lists for storing info about the p12a_mouse
    // current position of the mouse:
    p12a_mouse.x = [];
    p12a_mouse.y = [];
    p12a_mouse.leftButton = [];
    p12a_mouse.midButton = [];
    p12a_mouse.rightButton = [];
    p12a_mouse.time = [];
    p12a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p12a_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p12a_VS_shapes.started', globalClock.getTime());
    p12a_VS_shapesMaxDuration = null
    // keep track of which components have finished
    p12a_VS_shapesComponents = [];
    p12a_VS_shapesComponents.push(p12a_sq6);
    p12a_VS_shapesComponents.push(p12a_sq5);
    p12a_VS_shapesComponents.push(p12a_sq4);
    p12a_VS_shapesComponents.push(p12a_sq3);
    p12a_VS_shapesComponents.push(p12a_sq2);
    p12a_VS_shapesComponents.push(p12a_sq1);
    p12a_VS_shapesComponents.push(p12a_txb_q1);
    p12a_VS_shapesComponents.push(p12a_txt_q1);
    p12a_VS_shapesComponents.push(p12a_img_1);
    p12a_VS_shapesComponents.push(p12a_img_2);
    p12a_VS_shapesComponents.push(p12a_img_3);
    p12a_VS_shapesComponents.push(p12a_img_4);
    p12a_VS_shapesComponents.push(p12a_img_5);
    p12a_VS_shapesComponents.push(p12a_img_6);
    p12a_VS_shapesComponents.push(p12a_img_whole);
    p12a_VS_shapesComponents.push(p12a_box_next);
    p12a_VS_shapesComponents.push(p12a_txt_next);
    p12a_VS_shapesComponents.push(p12a_box_try);
    p12a_VS_shapesComponents.push(p12a_txt_try);
    p12a_VS_shapesComponents.push(p12a_txt_try_many);
    p12a_VS_shapesComponents.push(p12a_mouse);
    
    p12a_VS_shapesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12a_VS_shapesRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12a_VS_shapes' ---
    // get current time
    t = p12a_VS_shapesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p12a_sq6* updates
    if (t >= 0.0 && p12a_sq6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq6.tStart = t;  // (not accounting for frame time here)
      p12a_sq6.frameNStart = frameN;  // exact frame index
      
      p12a_sq6.setAutoDraw(true);
    }
    
    
    // if p12a_sq6 is active this frame...
    if (p12a_sq6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_sq5* updates
    if (t >= 0.0 && p12a_sq5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq5.tStart = t;  // (not accounting for frame time here)
      p12a_sq5.frameNStart = frameN;  // exact frame index
      
      p12a_sq5.setAutoDraw(true);
    }
    
    
    // if p12a_sq5 is active this frame...
    if (p12a_sq5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_sq4* updates
    if (t >= 0.0 && p12a_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq4.tStart = t;  // (not accounting for frame time here)
      p12a_sq4.frameNStart = frameN;  // exact frame index
      
      p12a_sq4.setAutoDraw(true);
    }
    
    
    // if p12a_sq4 is active this frame...
    if (p12a_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_sq3* updates
    if (t >= 0.0 && p12a_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq3.tStart = t;  // (not accounting for frame time here)
      p12a_sq3.frameNStart = frameN;  // exact frame index
      
      p12a_sq3.setAutoDraw(true);
    }
    
    
    // if p12a_sq3 is active this frame...
    if (p12a_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_sq2* updates
    if (t >= 0.0 && p12a_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq2.tStart = t;  // (not accounting for frame time here)
      p12a_sq2.frameNStart = frameN;  // exact frame index
      
      p12a_sq2.setAutoDraw(true);
    }
    
    
    // if p12a_sq2 is active this frame...
    if (p12a_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_sq1* updates
    if (t >= 0.0 && p12a_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_sq1.tStart = t;  // (not accounting for frame time here)
      p12a_sq1.frameNStart = frameN;  // exact frame index
      
      p12a_sq1.setAutoDraw(true);
    }
    
    
    // if p12a_sq1 is active this frame...
    if (p12a_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_txb_q1* updates
    if (t >= 0.0 && p12a_txb_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_txb_q1.tStart = t;  // (not accounting for frame time here)
      p12a_txb_q1.frameNStart = frameN;  // exact frame index
      
      p12a_txb_q1.setAutoDraw(true);
    }
    
    
    // if p12a_txb_q1 is active this frame...
    if (p12a_txb_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_txt_q1* updates
    if (t >= 0.0 && p12a_txt_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_txt_q1.tStart = t;  // (not accounting for frame time here)
      p12a_txt_q1.frameNStart = frameN;  // exact frame index
      
      p12a_txt_q1.setAutoDraw(true);
    }
    
    
    // if p12a_txt_q1 is active this frame...
    if (p12a_txt_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_1* updates
    if (t >= 0.0 && p12a_img_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_1.tStart = t;  // (not accounting for frame time here)
      p12a_img_1.frameNStart = frameN;  // exact frame index
      
      p12a_img_1.setAutoDraw(true);
    }
    
    
    // if p12a_img_1 is active this frame...
    if (p12a_img_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_2* updates
    if (t >= 0.0 && p12a_img_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_2.tStart = t;  // (not accounting for frame time here)
      p12a_img_2.frameNStart = frameN;  // exact frame index
      
      p12a_img_2.setAutoDraw(true);
    }
    
    
    // if p12a_img_2 is active this frame...
    if (p12a_img_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_3* updates
    if (t >= 0.0 && p12a_img_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_3.tStart = t;  // (not accounting for frame time here)
      p12a_img_3.frameNStart = frameN;  // exact frame index
      
      p12a_img_3.setAutoDraw(true);
    }
    
    
    // if p12a_img_3 is active this frame...
    if (p12a_img_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_4* updates
    if (t >= 0.0 && p12a_img_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_4.tStart = t;  // (not accounting for frame time here)
      p12a_img_4.frameNStart = frameN;  // exact frame index
      
      p12a_img_4.setAutoDraw(true);
    }
    
    
    // if p12a_img_4 is active this frame...
    if (p12a_img_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_5* updates
    if (t >= 0.0 && p12a_img_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_5.tStart = t;  // (not accounting for frame time here)
      p12a_img_5.frameNStart = frameN;  // exact frame index
      
      p12a_img_5.setAutoDraw(true);
    }
    
    
    // if p12a_img_5 is active this frame...
    if (p12a_img_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_6* updates
    if (t >= 0.0 && p12a_img_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_6.tStart = t;  // (not accounting for frame time here)
      p12a_img_6.frameNStart = frameN;  // exact frame index
      
      p12a_img_6.setAutoDraw(true);
    }
    
    
    // if p12a_img_6 is active this frame...
    if (p12a_img_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_img_whole* updates
    if (t >= 0.0 && p12a_img_whole.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_img_whole.tStart = t;  // (not accounting for frame time here)
      p12a_img_whole.frameNStart = frameN;  // exact frame index
      
      p12a_img_whole.setAutoDraw(true);
    }
    
    
    // if p12a_img_whole is active this frame...
    if (p12a_img_whole.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_box_next* updates
    if (t >= 0.0 && p12a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_box_next.tStart = t;  // (not accounting for frame time here)
      p12a_box_next.frameNStart = frameN;  // exact frame index
      
      p12a_box_next.setAutoDraw(true);
    }
    
    
    // if p12a_box_next is active this frame...
    if (p12a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_txt_next* updates
    if (t >= 0.0 && p12a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_txt_next.tStart = t;  // (not accounting for frame time here)
      p12a_txt_next.frameNStart = frameN;  // exact frame index
      
      p12a_txt_next.setAutoDraw(true);
    }
    
    
    // if p12a_txt_next is active this frame...
    if (p12a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_box_try* updates
    if (t >= 0.0 && p12a_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_box_try.tStart = t;  // (not accounting for frame time here)
      p12a_box_try.frameNStart = frameN;  // exact frame index
      
      p12a_box_try.setAutoDraw(true);
    }
    
    
    // if p12a_box_try is active this frame...
    if (p12a_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_txt_try* updates
    if (t >= 0.0 && p12a_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_txt_try.tStart = t;  // (not accounting for frame time here)
      p12a_txt_try.frameNStart = frameN;  // exact frame index
      
      p12a_txt_try.setAutoDraw(true);
    }
    
    
    // if p12a_txt_try is active this frame...
    if (p12a_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12a_txt_try_many* updates
    if (t >= 0.0 && p12a_txt_try_many.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_txt_try_many.tStart = t;  // (not accounting for frame time here)
      p12a_txt_try_many.frameNStart = frameN;  // exact frame index
      
      p12a_txt_try_many.setAutoDraw(true);
    }
    
    
    // if p12a_txt_try_many is active this frame...
    if (p12a_txt_try_many.status === PsychoJS.Status.STARTED) {
    }
    
    // *p12a_mouse* updates
    if (t >= 0.0 && p12a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12a_mouse.tStart = t;  // (not accounting for frame time here)
      p12a_mouse.frameNStart = frameN;  // exact frame index
      
      p12a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p12a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p12a_mouse is active this frame...
    if (p12a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p12a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12a_mouse.clickableObjects = eval([p12a_img_1, p12a_img_2, p12a_img_3, p12a_img_4, p12a_img_5, p12a_img_6, p12a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12a_mouse.clickableObjects)) {
              p12a_mouse.clickableObjects = [p12a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12a_mouse.clickableObjects) {
              if (obj.contains(p12a_mouse)) {
                  gotValidClick = true;
                  p12a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12a_mouse.clickableObjects = eval([p12a_img_1, p12a_img_2, p12a_img_3, p12a_img_4, p12a_img_5, p12a_img_6, p12a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12a_mouse.clickableObjects)) {
              p12a_mouse.clickableObjects = [p12a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12a_mouse.clickableObjects) {
              if (obj.contains(p12a_mouse)) {
                  gotValidClick = true;
                  p12a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p12a_mouse.getPos();
            p12a_mouse.x.push(_mouseXYs[0]);
            p12a_mouse.y.push(_mouseXYs[1]);
            p12a_mouse.leftButton.push(_mouseButtons[0]);
            p12a_mouse.midButton.push(_mouseButtons[1]);
            p12a_mouse.rightButton.push(_mouseButtons[2]);
            p12a_mouse.time.push(p12a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12a_VS_shapesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12a_VS_shapesRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12a_VS_shapes' ---
    p12a_VS_shapesComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12a_VS_shapes.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p12a_mouse.x', p12a_mouse.x);
    psychoJS.experiment.addData('p12a_mouse.y', p12a_mouse.y);
    psychoJS.experiment.addData('p12a_mouse.leftButton', p12a_mouse.leftButton);
    psychoJS.experiment.addData('p12a_mouse.midButton', p12a_mouse.midButton);
    psychoJS.experiment.addData('p12a_mouse.rightButton', p12a_mouse.rightButton);
    psychoJS.experiment.addData('p12a_mouse.time', p12a_mouse.time);
    psychoJS.experiment.addData('p12a_mouse.clicked_name', p12a_mouse.clicked_name);
    
    // Run 'End Routine' code from p112a_code_ans
    psychoJS.experiment.addData('p12a_isCorrect',p12a_isCorrect)
    psychoJS.experiment.addData('p12a_ans', p12a_ans)
    psychoJS.experiment.addData('p12a_ans_Idx', p12a_ans_Idx)
    psychoJS.experiment.addData('p12a_corrAns',p12a_corrAns)
    psychoJS.experiment.addData('p12a_corrAns_Idx',p12a_corrAns_Idx)
    psychoJS.experiment.addData('p12a_countNext',p12a_countNext)
    psychoJS.experiment.addData('p12a_points',p12a_points)
    // the Routine "p12a_VS_shapes" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12a_inTimeMaxDurationReached;
var p12a_inTimeMaxDuration;
var p12a_inTimeComponents;
function p12a_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12a_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12a_inTimeClock.reset();
    routineTimer.reset();
    p12a_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p12a_inTime.started', globalClock.getTime());
    p12a_inTimeMaxDuration = null
    // keep track of which components have finished
    p12a_inTimeComponents = [];
    
    p12a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12a_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12a_inTime' ---
    // get current time
    t = p12a_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12a_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12a_inTime' ---
    p12a_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12a_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p12a_code_inTime_2
    psychoJS.experiment.addData("p12a_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p12a_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12b_VS_facesMaxDurationReached;
var p12b_stimID;
var p12b_VS_facesMaxDuration;
var p12b_VS_facesComponents;
function p12b_VS_facesRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12b_VS_faces' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12b_VS_facesClock.reset();
    routineTimer.reset();
    p12b_VS_facesMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p12b_code
    p12b_stimID = [p12b_img_1, p12b_img_2, p12b_img_3, p12b_img_4, p12b_img_5, p12b_img_6];
    k = 0;
    i = 0;
    if ((p12b_mouse.isPressedIn(p12b_box_next) && (util.sum(p12b_isPicked) === 2))) {
        p12b_countNext = (p12b_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p12b_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p12b_ans_Idx = (p12b_ans_Idx + [i]);
                p12b_ans = ((p12b_ans + ",") + p12b_words[i]);
                p12b_countCorrect = (p12b_countCorrect + (val * p12b_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p12b_countCorrect === util.sum(p12b_corrAns_Vec))) {
            p12b_isCorrect = 1;
            p12b_points = 1;
        } else {
            p12b_isCorrect = 0;
            p12b_points = 0;
        }
        loop_waitTillOK_p12b.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p12b_mouse.isPressedIn(p12b_box_next) && (util.sum(p12b_isPicked) > 2))) {
            p12b_countNext = (p12b_countNext + 1);
            p12b_opTryBox = 1;
            p12b_opTryTxt = 0;
            p12b_opTryManyTxt = 1;
            p12b_opNextBox = 0;
            p12b_opNextTxt = 0;
        } else {
            if ((p12b_mouse.isPressedIn(p12b_box_next) && (util.sum(p12b_isPicked) < 2))) {
                p12b_countNext = (p12b_countNext + 1);
                p12b_opTryBox = 1;
                p12b_opTryTxt = 1;
                p12b_opTryManyTxt = 0;
                p12b_opNextBox = 0;
                p12b_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p12b_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p12b_mouse.isPressedIn(thisStim) && (p12b_isPicked[k] === 0))) {
                        p12b_stimColors[k] = cAzul;
                        p12b_isPicked[k] = 1;
                        p12b_opTryBox = 0;
                        p12b_opTryTxt = 0;
                        p12b_opTryManyTxt = 0;
                        p12b_opNextBox = 1;
                        p12b_opNextTxt = 1;
                    } else {
                        if ((p12b_mouse.isPressedIn(thisStim) && (p12b_isPicked[k] === 1))) {
                            p12b_stimColors[k] = cWhite;
                            p12b_isPicked[k] = 0;
                            p12b_opTryBox = 0;
                            p12b_opTryTxt = 0;
                            p12b_opTryManyTxt = 0;
                            p12b_opNextBox = 1;
                            p12b_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    p12b_sq6.setFillColor(new util.Color(p12b_stimColors[6]));
    p12b_sq6.setLineColor(new util.Color(p12b_stimColors[6]));
    p12b_sq5.setFillColor(new util.Color(p12b_stimColors[5]));
    p12b_sq5.setLineColor(new util.Color(p12b_stimColors[5]));
    p12b_sq4.setFillColor(new util.Color(p12b_stimColors[4]));
    p12b_sq4.setLineColor(new util.Color(p12b_stimColors[4]));
    p12b_sq3.setFillColor(new util.Color(p12b_stimColors[3]));
    p12b_sq3.setLineColor(new util.Color(p12b_stimColors[3]));
    p12b_sq2.setFillColor(new util.Color(p12b_stimColors[2]));
    p12b_sq2.setLineColor(new util.Color(p12b_stimColors[2]));
    p12b_sq1.setFillColor(new util.Color(p12b_stimColors[1]));
    p12b_sq1.setLineColor(new util.Color(p12b_stimColors[1]));
    p12b_box_next.setFillColor(new util.Color(BoxNextColor));
    p12b_box_next.setOpacity(p12b_opNextBox);
    p12b_box_next.setLineColor(new util.Color(cGrey));
    p12b_txt_next.setOpacity(p12b_opNextTxt);
    p12b_box_try.setFillColor(new util.Color(BoxTryColor));
    p12b_box_try.setOpacity(p12b_opTryBox);
    p12b_box_try.setLineColor(new util.Color(cGrey));
    p12b_txt_try.setOpacity(p12b_opTryTxt);
    p12b_txt_try_many.setOpacity(p12b_opTryManyTxt);
    // setup some python lists for storing info about the p12b_mouse
    // current position of the mouse:
    p12b_mouse.x = [];
    p12b_mouse.y = [];
    p12b_mouse.leftButton = [];
    p12b_mouse.midButton = [];
    p12b_mouse.rightButton = [];
    p12b_mouse.time = [];
    p12b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p12b_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p12b_VS_faces.started', globalClock.getTime());
    p12b_VS_facesMaxDuration = null
    // keep track of which components have finished
    p12b_VS_facesComponents = [];
    p12b_VS_facesComponents.push(p12b_sq6);
    p12b_VS_facesComponents.push(p12b_sq5);
    p12b_VS_facesComponents.push(p12b_sq4);
    p12b_VS_facesComponents.push(p12b_sq3);
    p12b_VS_facesComponents.push(p12b_sq2);
    p12b_VS_facesComponents.push(p12b_sq1);
    p12b_VS_facesComponents.push(p12b_txb_q1);
    p12b_VS_facesComponents.push(p12b_txt_q1);
    p12b_VS_facesComponents.push(p12b_img_1);
    p12b_VS_facesComponents.push(p12b_img_2);
    p12b_VS_facesComponents.push(p12b_img_3);
    p12b_VS_facesComponents.push(p12b_img_4);
    p12b_VS_facesComponents.push(p12b_img_5);
    p12b_VS_facesComponents.push(p12b_img_6);
    p12b_VS_facesComponents.push(p12b_img_whole);
    p12b_VS_facesComponents.push(p12b_box_next);
    p12b_VS_facesComponents.push(p12b_txt_next);
    p12b_VS_facesComponents.push(p12b_box_try);
    p12b_VS_facesComponents.push(p12b_txt_try);
    p12b_VS_facesComponents.push(p12b_txt_try_many);
    p12b_VS_facesComponents.push(p12b_mouse);
    
    p12b_VS_facesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12b_VS_facesRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12b_VS_faces' ---
    // get current time
    t = p12b_VS_facesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p12b_sq6* updates
    if (t >= 0.0 && p12b_sq6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq6.tStart = t;  // (not accounting for frame time here)
      p12b_sq6.frameNStart = frameN;  // exact frame index
      
      p12b_sq6.setAutoDraw(true);
    }
    
    
    // if p12b_sq6 is active this frame...
    if (p12b_sq6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_sq5* updates
    if (t >= 0.0 && p12b_sq5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq5.tStart = t;  // (not accounting for frame time here)
      p12b_sq5.frameNStart = frameN;  // exact frame index
      
      p12b_sq5.setAutoDraw(true);
    }
    
    
    // if p12b_sq5 is active this frame...
    if (p12b_sq5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_sq4* updates
    if (t >= 0.0 && p12b_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq4.tStart = t;  // (not accounting for frame time here)
      p12b_sq4.frameNStart = frameN;  // exact frame index
      
      p12b_sq4.setAutoDraw(true);
    }
    
    
    // if p12b_sq4 is active this frame...
    if (p12b_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_sq3* updates
    if (t >= 0.0 && p12b_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq3.tStart = t;  // (not accounting for frame time here)
      p12b_sq3.frameNStart = frameN;  // exact frame index
      
      p12b_sq3.setAutoDraw(true);
    }
    
    
    // if p12b_sq3 is active this frame...
    if (p12b_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_sq2* updates
    if (t >= 0.0 && p12b_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq2.tStart = t;  // (not accounting for frame time here)
      p12b_sq2.frameNStart = frameN;  // exact frame index
      
      p12b_sq2.setAutoDraw(true);
    }
    
    
    // if p12b_sq2 is active this frame...
    if (p12b_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_sq1* updates
    if (t >= 0.0 && p12b_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_sq1.tStart = t;  // (not accounting for frame time here)
      p12b_sq1.frameNStart = frameN;  // exact frame index
      
      p12b_sq1.setAutoDraw(true);
    }
    
    
    // if p12b_sq1 is active this frame...
    if (p12b_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_txb_q1* updates
    if (t >= 0.0 && p12b_txb_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_txb_q1.tStart = t;  // (not accounting for frame time here)
      p12b_txb_q1.frameNStart = frameN;  // exact frame index
      
      p12b_txb_q1.setAutoDraw(true);
    }
    
    
    // if p12b_txb_q1 is active this frame...
    if (p12b_txb_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_txt_q1* updates
    if (t >= 0.0 && p12b_txt_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_txt_q1.tStart = t;  // (not accounting for frame time here)
      p12b_txt_q1.frameNStart = frameN;  // exact frame index
      
      p12b_txt_q1.setAutoDraw(true);
    }
    
    
    // if p12b_txt_q1 is active this frame...
    if (p12b_txt_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_1* updates
    if (t >= 0.0 && p12b_img_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_1.tStart = t;  // (not accounting for frame time here)
      p12b_img_1.frameNStart = frameN;  // exact frame index
      
      p12b_img_1.setAutoDraw(true);
    }
    
    
    // if p12b_img_1 is active this frame...
    if (p12b_img_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_2* updates
    if (t >= 0.0 && p12b_img_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_2.tStart = t;  // (not accounting for frame time here)
      p12b_img_2.frameNStart = frameN;  // exact frame index
      
      p12b_img_2.setAutoDraw(true);
    }
    
    
    // if p12b_img_2 is active this frame...
    if (p12b_img_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_3* updates
    if (t >= 0.0 && p12b_img_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_3.tStart = t;  // (not accounting for frame time here)
      p12b_img_3.frameNStart = frameN;  // exact frame index
      
      p12b_img_3.setAutoDraw(true);
    }
    
    
    // if p12b_img_3 is active this frame...
    if (p12b_img_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_4* updates
    if (t >= 0.0 && p12b_img_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_4.tStart = t;  // (not accounting for frame time here)
      p12b_img_4.frameNStart = frameN;  // exact frame index
      
      p12b_img_4.setAutoDraw(true);
    }
    
    
    // if p12b_img_4 is active this frame...
    if (p12b_img_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_5* updates
    if (t >= 0.0 && p12b_img_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_5.tStart = t;  // (not accounting for frame time here)
      p12b_img_5.frameNStart = frameN;  // exact frame index
      
      p12b_img_5.setAutoDraw(true);
    }
    
    
    // if p12b_img_5 is active this frame...
    if (p12b_img_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_6* updates
    if (t >= 0.0 && p12b_img_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_6.tStart = t;  // (not accounting for frame time here)
      p12b_img_6.frameNStart = frameN;  // exact frame index
      
      p12b_img_6.setAutoDraw(true);
    }
    
    
    // if p12b_img_6 is active this frame...
    if (p12b_img_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_img_whole* updates
    if (t >= 0.0 && p12b_img_whole.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_img_whole.tStart = t;  // (not accounting for frame time here)
      p12b_img_whole.frameNStart = frameN;  // exact frame index
      
      p12b_img_whole.setAutoDraw(true);
    }
    
    
    // if p12b_img_whole is active this frame...
    if (p12b_img_whole.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_box_next* updates
    if (t >= 0.0 && p12b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_box_next.tStart = t;  // (not accounting for frame time here)
      p12b_box_next.frameNStart = frameN;  // exact frame index
      
      p12b_box_next.setAutoDraw(true);
    }
    
    
    // if p12b_box_next is active this frame...
    if (p12b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_txt_next* updates
    if (t >= 0.0 && p12b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_txt_next.tStart = t;  // (not accounting for frame time here)
      p12b_txt_next.frameNStart = frameN;  // exact frame index
      
      p12b_txt_next.setAutoDraw(true);
    }
    
    
    // if p12b_txt_next is active this frame...
    if (p12b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_box_try* updates
    if (t >= 0.0 && p12b_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_box_try.tStart = t;  // (not accounting for frame time here)
      p12b_box_try.frameNStart = frameN;  // exact frame index
      
      p12b_box_try.setAutoDraw(true);
    }
    
    
    // if p12b_box_try is active this frame...
    if (p12b_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_txt_try* updates
    if (t >= 0.0 && p12b_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_txt_try.tStart = t;  // (not accounting for frame time here)
      p12b_txt_try.frameNStart = frameN;  // exact frame index
      
      p12b_txt_try.setAutoDraw(true);
    }
    
    
    // if p12b_txt_try is active this frame...
    if (p12b_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12b_txt_try_many* updates
    if (t >= 0.0 && p12b_txt_try_many.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_txt_try_many.tStart = t;  // (not accounting for frame time here)
      p12b_txt_try_many.frameNStart = frameN;  // exact frame index
      
      p12b_txt_try_many.setAutoDraw(true);
    }
    
    
    // if p12b_txt_try_many is active this frame...
    if (p12b_txt_try_many.status === PsychoJS.Status.STARTED) {
    }
    
    // *p12b_mouse* updates
    if (t >= 0.0 && p12b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12b_mouse.tStart = t;  // (not accounting for frame time here)
      p12b_mouse.frameNStart = frameN;  // exact frame index
      
      p12b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p12b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p12b_mouse is active this frame...
    if (p12b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p12b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12b_mouse.clickableObjects = eval([p12b_img_1, p12b_img_2, p12b_img_3, p12b_img_4, p12b_img_5, p12b_img_6, p12b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12b_mouse.clickableObjects)) {
              p12b_mouse.clickableObjects = [p12b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12b_mouse.clickableObjects) {
              if (obj.contains(p12b_mouse)) {
                  gotValidClick = true;
                  p12b_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12b_mouse.clickableObjects = eval([p12b_img_1, p12b_img_2, p12b_img_3, p12b_img_4, p12b_img_5, p12b_img_6, p12b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12b_mouse.clickableObjects)) {
              p12b_mouse.clickableObjects = [p12b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12b_mouse.clickableObjects) {
              if (obj.contains(p12b_mouse)) {
                  gotValidClick = true;
                  p12b_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p12b_mouse.getPos();
            p12b_mouse.x.push(_mouseXYs[0]);
            p12b_mouse.y.push(_mouseXYs[1]);
            p12b_mouse.leftButton.push(_mouseButtons[0]);
            p12b_mouse.midButton.push(_mouseButtons[1]);
            p12b_mouse.rightButton.push(_mouseButtons[2]);
            p12b_mouse.time.push(p12b_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12b_VS_facesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12b_VS_facesRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12b_VS_faces' ---
    p12b_VS_facesComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12b_VS_faces.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p12b_mouse.x', p12b_mouse.x);
    psychoJS.experiment.addData('p12b_mouse.y', p12b_mouse.y);
    psychoJS.experiment.addData('p12b_mouse.leftButton', p12b_mouse.leftButton);
    psychoJS.experiment.addData('p12b_mouse.midButton', p12b_mouse.midButton);
    psychoJS.experiment.addData('p12b_mouse.rightButton', p12b_mouse.rightButton);
    psychoJS.experiment.addData('p12b_mouse.time', p12b_mouse.time);
    psychoJS.experiment.addData('p12b_mouse.clicked_name', p12b_mouse.clicked_name);
    
    // Run 'End Routine' code from p12b_code_ans
    psychoJS.experiment.addData('p12b_isCorrect',p12b_isCorrect)
    psychoJS.experiment.addData('p12b_ans', p12b_ans)
    psychoJS.experiment.addData('p12b_ans_Idx', p12b_ans_Idx)
    psychoJS.experiment.addData('p12b_corrAns',p12b_corrAns)
    psychoJS.experiment.addData('p12b_corrAns_Idx',p12b_corrAns_Idx)
    psychoJS.experiment.addData('p12b_countNext',p12b_countNext)
    psychoJS.experiment.addData('p12b_points',p12b_points)
    // the Routine "p12b_VS_faces" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12b_inTimeMaxDurationReached;
var p12b_inTimeMaxDuration;
var p12b_inTimeComponents;
function p12b_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12b_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12b_inTimeClock.reset();
    routineTimer.reset();
    p12b_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p12b_inTime.started', globalClock.getTime());
    p12b_inTimeMaxDuration = null
    // keep track of which components have finished
    p12b_inTimeComponents = [];
    
    p12b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12b_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12b_inTime' ---
    // get current time
    t = p12b_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12b_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12b_inTime' ---
    p12b_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12b_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p12b_code_inTime
    psychoJS.experiment.addData("p12b_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p12b_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12c_VS_linesMaxDurationReached;
var p12c_stimID;
var p12c_VS_linesMaxDuration;
var p12c_VS_linesComponents;
function p12c_VS_linesRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12c_VS_lines' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12c_VS_linesClock.reset();
    routineTimer.reset();
    p12c_VS_linesMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p12c_code
    p12c_stimID = [p12c_img_1, p12c_img_2, p12c_img_3, p12c_img_4, p12c_img_5, p12c_img_6];
    k = 0;
    i = 0;
    if ((p12c_mouse.isPressedIn(p12c_box_next) && (util.sum(p12c_isPicked) === 2))) {
        p12c_countNext = (p12c_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p12c_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p12c_ans_Idx = (p12c_ans_Idx + [i]);
                p12c_ans = ((p12c_ans + ",") + p12c_words[i]);
                p12c_countCorrect = (p12c_countCorrect + (val * p12c_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p12c_countCorrect === util.sum(p12c_corrAns_Vec))) {
            p12c_isCorrect = 1;
            p12c_points = 1;
        } else {
            p12c_isCorrect = 0;
            p12c_points = 0;
        }
        loop_waitTillOK_p12c.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p12c_mouse.isPressedIn(p12c_box_next) && (util.sum(p12c_isPicked) > 2))) {
            p12c_countNext = (p12c_countNext + 1);
            p12c_opTryBox = 1;
            p12c_opTryTxt = 0;
            p12c_opTryManyTxt = 1;
            p12c_opNextBox = 0;
            p12c_opNextTxt = 0;
        } else {
            if ((p12c_mouse.isPressedIn(p12c_box_next) && (util.sum(p12c_isPicked) < 2))) {
                p12c_countNext = (p12c_countNext + 1);
                p12c_opTryBox = 1;
                p12c_opTryTxt = 1;
                p12c_opTryManyTxt = 0;
                p12c_opNextBox = 0;
                p12c_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p12c_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p12c_mouse.isPressedIn(thisStim) && (p12c_isPicked[k] === 0))) {
                        p12c_stimColors[k] = cAzul;
                        p12c_isPicked[k] = 1;
                        p12c_opTryBox = 0;
                        p12c_opTryTxt = 0;
                        p12c_opTryManyTxt = 0;
                        p12c_opNextBox = 1;
                        p12c_opNextTxt = 1;
                    } else {
                        if ((p12c_mouse.isPressedIn(thisStim) && (p12c_isPicked[k] === 1))) {
                            p12c_stimColors[k] = cWhite;
                            p12c_isPicked[k] = 0;
                            p12c_opTryBox = 0;
                            p12c_opTryTxt = 0;
                            p12c_opTryManyTxt = 0;
                            p12c_opNextBox = 1;
                            p12c_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    p12c_sq6.setFillColor(new util.Color(p12c_stimColors[6]));
    p12c_sq6.setLineColor(new util.Color(p12c_stimColors[6]));
    p12c_sq5.setFillColor(new util.Color(p12c_stimColors[5]));
    p12c_sq5.setLineColor(new util.Color(p12c_stimColors[5]));
    p12c_sq4.setFillColor(new util.Color(p12c_stimColors[4]));
    p12c_sq4.setLineColor(new util.Color(p12c_stimColors[4]));
    p12c_sq3.setFillColor(new util.Color(p12c_stimColors[3]));
    p12c_sq3.setLineColor(new util.Color(p12c_stimColors[3]));
    p12c_sq2.setFillColor(new util.Color(p12c_stimColors[2]));
    p12c_sq2.setLineColor(new util.Color(p12c_stimColors[2]));
    p12c_sq1.setFillColor(new util.Color(p12c_stimColors[1]));
    p12c_sq1.setLineColor(new util.Color(p12c_stimColors[1]));
    p12c_box_next.setFillColor(new util.Color(BoxNextColor));
    p12c_box_next.setOpacity(p12c_opNextBox);
    p12c_box_next.setLineColor(new util.Color(cGrey));
    p12c_txt_next.setOpacity(p12c_opNextTxt);
    p12c_box_try.setFillColor(new util.Color(BoxTryColor));
    p12c_box_try.setOpacity(p12c_opTryBox);
    p12c_box_try.setLineColor(new util.Color(cGrey));
    p12c_txt_try.setOpacity(p12c_opTryTxt);
    p12c_txt_try_many.setOpacity(p12c_opTryManyTxt);
    // setup some python lists for storing info about the p12c_mouse
    // current position of the mouse:
    p12c_mouse.x = [];
    p12c_mouse.y = [];
    p12c_mouse.leftButton = [];
    p12c_mouse.midButton = [];
    p12c_mouse.rightButton = [];
    p12c_mouse.time = [];
    p12c_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p12c_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p12c_VS_lines.started', globalClock.getTime());
    p12c_VS_linesMaxDuration = null
    // keep track of which components have finished
    p12c_VS_linesComponents = [];
    p12c_VS_linesComponents.push(p12c_sq6);
    p12c_VS_linesComponents.push(p12c_sq5);
    p12c_VS_linesComponents.push(p12c_sq4);
    p12c_VS_linesComponents.push(p12c_sq3);
    p12c_VS_linesComponents.push(p12c_sq2);
    p12c_VS_linesComponents.push(p12c_sq1);
    p12c_VS_linesComponents.push(p12c_txb_q1);
    p12c_VS_linesComponents.push(p12c_txt_q1);
    p12c_VS_linesComponents.push(p12c_img_1);
    p12c_VS_linesComponents.push(p12c_img_2);
    p12c_VS_linesComponents.push(p12c_img_3);
    p12c_VS_linesComponents.push(p12c_img_4);
    p12c_VS_linesComponents.push(p12c_img_5);
    p12c_VS_linesComponents.push(p12c_img_6);
    p12c_VS_linesComponents.push(p12c_img_whole);
    p12c_VS_linesComponents.push(p12c_box_next);
    p12c_VS_linesComponents.push(p12c_txt_next);
    p12c_VS_linesComponents.push(p12c_box_try);
    p12c_VS_linesComponents.push(p12c_txt_try);
    p12c_VS_linesComponents.push(p12c_txt_try_many);
    p12c_VS_linesComponents.push(p12c_mouse);
    
    p12c_VS_linesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12c_VS_linesRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12c_VS_lines' ---
    // get current time
    t = p12c_VS_linesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p12c_sq6* updates
    if (t >= 0.0 && p12c_sq6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq6.tStart = t;  // (not accounting for frame time here)
      p12c_sq6.frameNStart = frameN;  // exact frame index
      
      p12c_sq6.setAutoDraw(true);
    }
    
    
    // if p12c_sq6 is active this frame...
    if (p12c_sq6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_sq5* updates
    if (t >= 0.0 && p12c_sq5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq5.tStart = t;  // (not accounting for frame time here)
      p12c_sq5.frameNStart = frameN;  // exact frame index
      
      p12c_sq5.setAutoDraw(true);
    }
    
    
    // if p12c_sq5 is active this frame...
    if (p12c_sq5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_sq4* updates
    if (t >= 0.0 && p12c_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq4.tStart = t;  // (not accounting for frame time here)
      p12c_sq4.frameNStart = frameN;  // exact frame index
      
      p12c_sq4.setAutoDraw(true);
    }
    
    
    // if p12c_sq4 is active this frame...
    if (p12c_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_sq3* updates
    if (t >= 0.0 && p12c_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq3.tStart = t;  // (not accounting for frame time here)
      p12c_sq3.frameNStart = frameN;  // exact frame index
      
      p12c_sq3.setAutoDraw(true);
    }
    
    
    // if p12c_sq3 is active this frame...
    if (p12c_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_sq2* updates
    if (t >= 0.0 && p12c_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq2.tStart = t;  // (not accounting for frame time here)
      p12c_sq2.frameNStart = frameN;  // exact frame index
      
      p12c_sq2.setAutoDraw(true);
    }
    
    
    // if p12c_sq2 is active this frame...
    if (p12c_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_sq1* updates
    if (t >= 0.0 && p12c_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_sq1.tStart = t;  // (not accounting for frame time here)
      p12c_sq1.frameNStart = frameN;  // exact frame index
      
      p12c_sq1.setAutoDraw(true);
    }
    
    
    // if p12c_sq1 is active this frame...
    if (p12c_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_txb_q1* updates
    if (t >= 0.0 && p12c_txb_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_txb_q1.tStart = t;  // (not accounting for frame time here)
      p12c_txb_q1.frameNStart = frameN;  // exact frame index
      
      p12c_txb_q1.setAutoDraw(true);
    }
    
    
    // if p12c_txb_q1 is active this frame...
    if (p12c_txb_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_txt_q1* updates
    if (t >= 0.0 && p12c_txt_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_txt_q1.tStart = t;  // (not accounting for frame time here)
      p12c_txt_q1.frameNStart = frameN;  // exact frame index
      
      p12c_txt_q1.setAutoDraw(true);
    }
    
    
    // if p12c_txt_q1 is active this frame...
    if (p12c_txt_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_1* updates
    if (t >= 0.0 && p12c_img_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_1.tStart = t;  // (not accounting for frame time here)
      p12c_img_1.frameNStart = frameN;  // exact frame index
      
      p12c_img_1.setAutoDraw(true);
    }
    
    
    // if p12c_img_1 is active this frame...
    if (p12c_img_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_2* updates
    if (t >= 0.0 && p12c_img_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_2.tStart = t;  // (not accounting for frame time here)
      p12c_img_2.frameNStart = frameN;  // exact frame index
      
      p12c_img_2.setAutoDraw(true);
    }
    
    
    // if p12c_img_2 is active this frame...
    if (p12c_img_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_3* updates
    if (t >= 0.0 && p12c_img_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_3.tStart = t;  // (not accounting for frame time here)
      p12c_img_3.frameNStart = frameN;  // exact frame index
      
      p12c_img_3.setAutoDraw(true);
    }
    
    
    // if p12c_img_3 is active this frame...
    if (p12c_img_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_4* updates
    if (t >= 0.0 && p12c_img_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_4.tStart = t;  // (not accounting for frame time here)
      p12c_img_4.frameNStart = frameN;  // exact frame index
      
      p12c_img_4.setAutoDraw(true);
    }
    
    
    // if p12c_img_4 is active this frame...
    if (p12c_img_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_5* updates
    if (t >= 0.0 && p12c_img_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_5.tStart = t;  // (not accounting for frame time here)
      p12c_img_5.frameNStart = frameN;  // exact frame index
      
      p12c_img_5.setAutoDraw(true);
    }
    
    
    // if p12c_img_5 is active this frame...
    if (p12c_img_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_6* updates
    if (t >= 0.0 && p12c_img_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_6.tStart = t;  // (not accounting for frame time here)
      p12c_img_6.frameNStart = frameN;  // exact frame index
      
      p12c_img_6.setAutoDraw(true);
    }
    
    
    // if p12c_img_6 is active this frame...
    if (p12c_img_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_img_whole* updates
    if (t >= 0.0 && p12c_img_whole.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_img_whole.tStart = t;  // (not accounting for frame time here)
      p12c_img_whole.frameNStart = frameN;  // exact frame index
      
      p12c_img_whole.setAutoDraw(true);
    }
    
    
    // if p12c_img_whole is active this frame...
    if (p12c_img_whole.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_box_next* updates
    if (t >= 0.0 && p12c_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_box_next.tStart = t;  // (not accounting for frame time here)
      p12c_box_next.frameNStart = frameN;  // exact frame index
      
      p12c_box_next.setAutoDraw(true);
    }
    
    
    // if p12c_box_next is active this frame...
    if (p12c_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_txt_next* updates
    if (t >= 0.0 && p12c_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_txt_next.tStart = t;  // (not accounting for frame time here)
      p12c_txt_next.frameNStart = frameN;  // exact frame index
      
      p12c_txt_next.setAutoDraw(true);
    }
    
    
    // if p12c_txt_next is active this frame...
    if (p12c_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_box_try* updates
    if (t >= 0.0 && p12c_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_box_try.tStart = t;  // (not accounting for frame time here)
      p12c_box_try.frameNStart = frameN;  // exact frame index
      
      p12c_box_try.setAutoDraw(true);
    }
    
    
    // if p12c_box_try is active this frame...
    if (p12c_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_txt_try* updates
    if (t >= 0.0 && p12c_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_txt_try.tStart = t;  // (not accounting for frame time here)
      p12c_txt_try.frameNStart = frameN;  // exact frame index
      
      p12c_txt_try.setAutoDraw(true);
    }
    
    
    // if p12c_txt_try is active this frame...
    if (p12c_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12c_txt_try_many* updates
    if (t >= 0.0 && p12c_txt_try_many.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_txt_try_many.tStart = t;  // (not accounting for frame time here)
      p12c_txt_try_many.frameNStart = frameN;  // exact frame index
      
      p12c_txt_try_many.setAutoDraw(true);
    }
    
    
    // if p12c_txt_try_many is active this frame...
    if (p12c_txt_try_many.status === PsychoJS.Status.STARTED) {
    }
    
    // *p12c_mouse* updates
    if (t >= 0.0 && p12c_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12c_mouse.tStart = t;  // (not accounting for frame time here)
      p12c_mouse.frameNStart = frameN;  // exact frame index
      
      p12c_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p12c_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p12c_mouse is active this frame...
    if (p12c_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p12c_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12c_mouse.clickableObjects = eval([p12c_img_1, p12c_img_2, p12c_img_3, p12c_img_4, p12c_img_5, p12c_img_6, p12c_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12c_mouse.clickableObjects)) {
              p12c_mouse.clickableObjects = [p12c_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12c_mouse.clickableObjects) {
              if (obj.contains(p12c_mouse)) {
                  gotValidClick = true;
                  p12c_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12c_mouse.clickableObjects = eval([p12c_img_1, p12c_img_2, p12c_img_3, p12c_img_4, p12c_img_5, p12c_img_6, p12c_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12c_mouse.clickableObjects)) {
              p12c_mouse.clickableObjects = [p12c_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12c_mouse.clickableObjects) {
              if (obj.contains(p12c_mouse)) {
                  gotValidClick = true;
                  p12c_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p12c_mouse.getPos();
            p12c_mouse.x.push(_mouseXYs[0]);
            p12c_mouse.y.push(_mouseXYs[1]);
            p12c_mouse.leftButton.push(_mouseButtons[0]);
            p12c_mouse.midButton.push(_mouseButtons[1]);
            p12c_mouse.rightButton.push(_mouseButtons[2]);
            p12c_mouse.time.push(p12c_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12c_VS_linesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12c_VS_linesRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12c_VS_lines' ---
    p12c_VS_linesComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12c_VS_lines.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p12c_mouse.x', p12c_mouse.x);
    psychoJS.experiment.addData('p12c_mouse.y', p12c_mouse.y);
    psychoJS.experiment.addData('p12c_mouse.leftButton', p12c_mouse.leftButton);
    psychoJS.experiment.addData('p12c_mouse.midButton', p12c_mouse.midButton);
    psychoJS.experiment.addData('p12c_mouse.rightButton', p12c_mouse.rightButton);
    psychoJS.experiment.addData('p12c_mouse.time', p12c_mouse.time);
    psychoJS.experiment.addData('p12c_mouse.clicked_name', p12c_mouse.clicked_name);
    
    // Run 'End Routine' code from p12c_code_ans
    psychoJS.experiment.addData('p12c_isCorrect',p12c_isCorrect)
    psychoJS.experiment.addData('p12c_ans', p12c_ans)
    psychoJS.experiment.addData('p12c_ans_Idx', p12c_ans_Idx)
    psychoJS.experiment.addData('p12c_corrAns',p12c_corrAns)
    psychoJS.experiment.addData('p12c_corrAns_Idx',p12c_corrAns_Idx)
    psychoJS.experiment.addData('p12c_countNext',p12c_countNext)
    psychoJS.experiment.addData('p12c_points',p12c_points)
    // the Routine "p12c_VS_lines" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12c_inTimeMaxDurationReached;
var p12c_inTimeMaxDuration;
var p12c_inTimeComponents;
function p12c_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12c_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12c_inTimeClock.reset();
    routineTimer.reset();
    p12c_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p12c_inTime.started', globalClock.getTime());
    p12c_inTimeMaxDuration = null
    // keep track of which components have finished
    p12c_inTimeComponents = [];
    
    p12c_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12c_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12c_inTime' ---
    // get current time
    t = p12c_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12c_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12c_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12c_inTime' ---
    p12c_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12c_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p12c_code_inTime
    psychoJS.experiment.addData("p12c_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p12c_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12d_VS_cubesMaxDurationReached;
var p12d_stimID;
var p12d_VS_cubesMaxDuration;
var p12d_VS_cubesComponents;
function p12d_VS_cubesRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12d_VS_cubes' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12d_VS_cubesClock.reset();
    routineTimer.reset();
    p12d_VS_cubesMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p12d_code
    p12d_stimID = [p12d_img_1, p12d_img_2, p12d_img_3, p12d_img_4, p12d_img_5, p12d_img_6];
    k = 0;
    i = 0;
    if ((p12d_mouse.isPressedIn(p12d_box_next) && (util.sum(p12d_isPicked) === 2))) {
        p12d_countNext = (p12d_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p12d_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p12d_ans_Idx = (p12d_ans_Idx + [i]);
                p12d_ans = ((p12d_ans + ",") + p12d_words[i]);
                p12d_countCorrect = (p12d_countCorrect + (val * p12d_corrAns_Vec[i]));
            }
            i = (i + 1);
        }
        if ((p12d_countCorrect === util.sum(p12d_corrAns_Vec))) {
            p12d_isCorrect = 1;
            p12d_points = 1;
        } else {
            p12d_isCorrect = 0;
            p12d_points = 0;
        }
        loop_waitTillOK_p12d.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p12d_mouse.isPressedIn(p12d_box_next) && (util.sum(p12d_isPicked) > 2))) {
            p12d_countNext = (p12d_countNext + 1);
            p12d_opTryBox = 1;
            p12d_opTryTxt = 0;
            p12d_opTryManyTxt = 1;
            p12d_opNextBox = 0;
            p12d_opNextTxt = 0;
        } else {
            if ((p12d_mouse.isPressedIn(p12d_box_next) && (util.sum(p12d_isPicked) < 2))) {
                p12d_countNext = (p12d_countNext + 1);
                p12d_opTryBox = 1;
                p12d_opTryTxt = 1;
                p12d_opTryManyTxt = 0;
                p12d_opNextBox = 0;
                p12d_opNextTxt = 0;
            } else {
                for (var thisStim, _pj_c = 0, _pj_a = p12d_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                    thisStim = _pj_a[_pj_c];
                    k = (k + 1);
                    if ((p12d_mouse.isPressedIn(thisStim) && (p12d_isPicked[k] === 0))) {
                        p12d_stimColors[k] = cAzul;
                        p12d_isPicked[k] = 1;
                        p12d_opTryBox = 0;
                        p12d_opTryTxt = 0;
                        p12d_opTryManyTxt = 0;
                        p12d_opNextBox = 1;
                        p12d_opNextTxt = 1;
                    } else {
                        if ((p12d_mouse.isPressedIn(thisStim) && (p12d_isPicked[k] === 1))) {
                            p12d_stimColors[k] = cWhite;
                            p12d_isPicked[k] = 0;
                            p12d_opTryBox = 0;
                            p12d_opTryTxt = 0;
                            p12d_opTryManyTxt = 0;
                            p12d_opNextBox = 1;
                            p12d_opNextTxt = 1;
                        }
                    }
                }
            }
        }
    }
    
    p12d_sq6.setFillColor(new util.Color(p12d_stimColors[6]));
    p12d_sq6.setLineColor(new util.Color(p12d_stimColors[6]));
    p12d_sq5.setFillColor(new util.Color(p12d_stimColors[5]));
    p12d_sq5.setLineColor(new util.Color(p12d_stimColors[5]));
    p12d_sq4.setFillColor(new util.Color(p12d_stimColors[4]));
    p12d_sq4.setLineColor(new util.Color(p12d_stimColors[4]));
    p12d_sq3.setFillColor(new util.Color(p12d_stimColors[3]));
    p12d_sq3.setLineColor(new util.Color(p12d_stimColors[3]));
    p12d_sq2.setFillColor(new util.Color(p12d_stimColors[2]));
    p12d_sq2.setLineColor(new util.Color(p12d_stimColors[2]));
    p12d_sq1.setFillColor(new util.Color(p12d_stimColors[1]));
    p12d_sq1.setLineColor(new util.Color(p12d_stimColors[1]));
    p12d_box_next.setFillColor(new util.Color(BoxNextColor));
    p12d_box_next.setOpacity(p12d_opNextBox);
    p12d_box_next.setLineColor(new util.Color(cGrey));
    p12d_txt_next.setOpacity(p12d_opNextTxt);
    p12d_box_try.setFillColor(new util.Color(BoxTryColor));
    p12d_box_try.setOpacity(p12d_opTryBox);
    p12d_box_try.setLineColor(new util.Color(cGrey));
    p12d_txt_try.setOpacity(p12d_opTryTxt);
    p12d_txt_try_many.setOpacity(p12d_opTryManyTxt);
    // setup some python lists for storing info about the p12d_mouse
    // current position of the mouse:
    p12d_mouse.x = [];
    p12d_mouse.y = [];
    p12d_mouse.leftButton = [];
    p12d_mouse.midButton = [];
    p12d_mouse.rightButton = [];
    p12d_mouse.time = [];
    p12d_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p12d_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p12d_VS_cubes.started', globalClock.getTime());
    p12d_VS_cubesMaxDuration = null
    // keep track of which components have finished
    p12d_VS_cubesComponents = [];
    p12d_VS_cubesComponents.push(p12d_sq6);
    p12d_VS_cubesComponents.push(p12d_sq5);
    p12d_VS_cubesComponents.push(p12d_sq4);
    p12d_VS_cubesComponents.push(p12d_sq3);
    p12d_VS_cubesComponents.push(p12d_sq2);
    p12d_VS_cubesComponents.push(p12d_sq1);
    p12d_VS_cubesComponents.push(p12d_txb_q1);
    p12d_VS_cubesComponents.push(p12d_txt_q1);
    p12d_VS_cubesComponents.push(p12d_img_1);
    p12d_VS_cubesComponents.push(p12d_img_2);
    p12d_VS_cubesComponents.push(p12d_img_3);
    p12d_VS_cubesComponents.push(p12d_img_4);
    p12d_VS_cubesComponents.push(p12d_img_5);
    p12d_VS_cubesComponents.push(p12d_img_6);
    p12d_VS_cubesComponents.push(p12d_img_whole);
    p12d_VS_cubesComponents.push(p12d_box_next);
    p12d_VS_cubesComponents.push(p12d_txt_next);
    p12d_VS_cubesComponents.push(p12d_box_try);
    p12d_VS_cubesComponents.push(p12d_txt_try);
    p12d_VS_cubesComponents.push(p12d_txt_try_many);
    p12d_VS_cubesComponents.push(p12d_mouse);
    
    p12d_VS_cubesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12d_VS_cubesRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12d_VS_cubes' ---
    // get current time
    t = p12d_VS_cubesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p12d_sq6* updates
    if (t >= 0.0 && p12d_sq6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq6.tStart = t;  // (not accounting for frame time here)
      p12d_sq6.frameNStart = frameN;  // exact frame index
      
      p12d_sq6.setAutoDraw(true);
    }
    
    
    // if p12d_sq6 is active this frame...
    if (p12d_sq6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_sq5* updates
    if (t >= 0.0 && p12d_sq5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq5.tStart = t;  // (not accounting for frame time here)
      p12d_sq5.frameNStart = frameN;  // exact frame index
      
      p12d_sq5.setAutoDraw(true);
    }
    
    
    // if p12d_sq5 is active this frame...
    if (p12d_sq5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_sq4* updates
    if (t >= 0.0 && p12d_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq4.tStart = t;  // (not accounting for frame time here)
      p12d_sq4.frameNStart = frameN;  // exact frame index
      
      p12d_sq4.setAutoDraw(true);
    }
    
    
    // if p12d_sq4 is active this frame...
    if (p12d_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_sq3* updates
    if (t >= 0.0 && p12d_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq3.tStart = t;  // (not accounting for frame time here)
      p12d_sq3.frameNStart = frameN;  // exact frame index
      
      p12d_sq3.setAutoDraw(true);
    }
    
    
    // if p12d_sq3 is active this frame...
    if (p12d_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_sq2* updates
    if (t >= 0.0 && p12d_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq2.tStart = t;  // (not accounting for frame time here)
      p12d_sq2.frameNStart = frameN;  // exact frame index
      
      p12d_sq2.setAutoDraw(true);
    }
    
    
    // if p12d_sq2 is active this frame...
    if (p12d_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_sq1* updates
    if (t >= 0.0 && p12d_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_sq1.tStart = t;  // (not accounting for frame time here)
      p12d_sq1.frameNStart = frameN;  // exact frame index
      
      p12d_sq1.setAutoDraw(true);
    }
    
    
    // if p12d_sq1 is active this frame...
    if (p12d_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_txb_q1* updates
    if (t >= 0.0 && p12d_txb_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_txb_q1.tStart = t;  // (not accounting for frame time here)
      p12d_txb_q1.frameNStart = frameN;  // exact frame index
      
      p12d_txb_q1.setAutoDraw(true);
    }
    
    
    // if p12d_txb_q1 is active this frame...
    if (p12d_txb_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_txt_q1* updates
    if (t >= 0.0 && p12d_txt_q1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_txt_q1.tStart = t;  // (not accounting for frame time here)
      p12d_txt_q1.frameNStart = frameN;  // exact frame index
      
      p12d_txt_q1.setAutoDraw(true);
    }
    
    
    // if p12d_txt_q1 is active this frame...
    if (p12d_txt_q1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_1* updates
    if (t >= 0.0 && p12d_img_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_1.tStart = t;  // (not accounting for frame time here)
      p12d_img_1.frameNStart = frameN;  // exact frame index
      
      p12d_img_1.setAutoDraw(true);
    }
    
    
    // if p12d_img_1 is active this frame...
    if (p12d_img_1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_2* updates
    if (t >= 0.0 && p12d_img_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_2.tStart = t;  // (not accounting for frame time here)
      p12d_img_2.frameNStart = frameN;  // exact frame index
      
      p12d_img_2.setAutoDraw(true);
    }
    
    
    // if p12d_img_2 is active this frame...
    if (p12d_img_2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_3* updates
    if (t >= 0.0 && p12d_img_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_3.tStart = t;  // (not accounting for frame time here)
      p12d_img_3.frameNStart = frameN;  // exact frame index
      
      p12d_img_3.setAutoDraw(true);
    }
    
    
    // if p12d_img_3 is active this frame...
    if (p12d_img_3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_4* updates
    if (t >= 0.0 && p12d_img_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_4.tStart = t;  // (not accounting for frame time here)
      p12d_img_4.frameNStart = frameN;  // exact frame index
      
      p12d_img_4.setAutoDraw(true);
    }
    
    
    // if p12d_img_4 is active this frame...
    if (p12d_img_4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_5* updates
    if (t >= 0.0 && p12d_img_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_5.tStart = t;  // (not accounting for frame time here)
      p12d_img_5.frameNStart = frameN;  // exact frame index
      
      p12d_img_5.setAutoDraw(true);
    }
    
    
    // if p12d_img_5 is active this frame...
    if (p12d_img_5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_6* updates
    if (t >= 0.0 && p12d_img_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_6.tStart = t;  // (not accounting for frame time here)
      p12d_img_6.frameNStart = frameN;  // exact frame index
      
      p12d_img_6.setAutoDraw(true);
    }
    
    
    // if p12d_img_6 is active this frame...
    if (p12d_img_6.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_img_whole* updates
    if (t >= 0.0 && p12d_img_whole.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_img_whole.tStart = t;  // (not accounting for frame time here)
      p12d_img_whole.frameNStart = frameN;  // exact frame index
      
      p12d_img_whole.setAutoDraw(true);
    }
    
    
    // if p12d_img_whole is active this frame...
    if (p12d_img_whole.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_box_next* updates
    if (t >= 0.0 && p12d_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_box_next.tStart = t;  // (not accounting for frame time here)
      p12d_box_next.frameNStart = frameN;  // exact frame index
      
      p12d_box_next.setAutoDraw(true);
    }
    
    
    // if p12d_box_next is active this frame...
    if (p12d_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_txt_next* updates
    if (t >= 0.0 && p12d_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_txt_next.tStart = t;  // (not accounting for frame time here)
      p12d_txt_next.frameNStart = frameN;  // exact frame index
      
      p12d_txt_next.setAutoDraw(true);
    }
    
    
    // if p12d_txt_next is active this frame...
    if (p12d_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_box_try* updates
    if (t >= 0.0 && p12d_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_box_try.tStart = t;  // (not accounting for frame time here)
      p12d_box_try.frameNStart = frameN;  // exact frame index
      
      p12d_box_try.setAutoDraw(true);
    }
    
    
    // if p12d_box_try is active this frame...
    if (p12d_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_txt_try* updates
    if (t >= 0.0 && p12d_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_txt_try.tStart = t;  // (not accounting for frame time here)
      p12d_txt_try.frameNStart = frameN;  // exact frame index
      
      p12d_txt_try.setAutoDraw(true);
    }
    
    
    // if p12d_txt_try is active this frame...
    if (p12d_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p12d_txt_try_many* updates
    if (t >= 0.0 && p12d_txt_try_many.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_txt_try_many.tStart = t;  // (not accounting for frame time here)
      p12d_txt_try_many.frameNStart = frameN;  // exact frame index
      
      p12d_txt_try_many.setAutoDraw(true);
    }
    
    
    // if p12d_txt_try_many is active this frame...
    if (p12d_txt_try_many.status === PsychoJS.Status.STARTED) {
    }
    
    // *p12d_mouse* updates
    if (t >= 0.0 && p12d_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p12d_mouse.tStart = t;  // (not accounting for frame time here)
      p12d_mouse.frameNStart = frameN;  // exact frame index
      
      p12d_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p12d_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p12d_mouse is active this frame...
    if (p12d_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p12d_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12d_mouse.clickableObjects = eval([p12d_img_1, p12d_img_2, p12d_img_3, p12d_img_4, p12d_img_5, p12d_img_6, p12d_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12d_mouse.clickableObjects)) {
              p12d_mouse.clickableObjects = [p12d_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12d_mouse.clickableObjects) {
              if (obj.contains(p12d_mouse)) {
                  gotValidClick = true;
                  p12d_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p12d_mouse.clickableObjects = eval([p12d_img_1, p12d_img_2, p12d_img_3, p12d_img_4, p12d_img_5, p12d_img_6, p12d_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p12d_mouse.clickableObjects)) {
              p12d_mouse.clickableObjects = [p12d_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p12d_mouse.clickableObjects) {
              if (obj.contains(p12d_mouse)) {
                  gotValidClick = true;
                  p12d_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p12d_mouse.getPos();
            p12d_mouse.x.push(_mouseXYs[0]);
            p12d_mouse.y.push(_mouseXYs[1]);
            p12d_mouse.leftButton.push(_mouseButtons[0]);
            p12d_mouse.midButton.push(_mouseButtons[1]);
            p12d_mouse.rightButton.push(_mouseButtons[2]);
            p12d_mouse.time.push(p12d_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12d_VS_cubesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12d_VS_cubesRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12d_VS_cubes' ---
    p12d_VS_cubesComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12d_VS_cubes.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p12d_mouse.x', p12d_mouse.x);
    psychoJS.experiment.addData('p12d_mouse.y', p12d_mouse.y);
    psychoJS.experiment.addData('p12d_mouse.leftButton', p12d_mouse.leftButton);
    psychoJS.experiment.addData('p12d_mouse.midButton', p12d_mouse.midButton);
    psychoJS.experiment.addData('p12d_mouse.rightButton', p12d_mouse.rightButton);
    psychoJS.experiment.addData('p12d_mouse.time', p12d_mouse.time);
    psychoJS.experiment.addData('p12d_mouse.clicked_name', p12d_mouse.clicked_name);
    
    // Run 'End Routine' code from p12d_code_ans
    psychoJS.experiment.addData('p12d_isCorrect',p12d_isCorrect)
    psychoJS.experiment.addData('p12d_ans', p12d_ans)
    psychoJS.experiment.addData('p12d_ans_Idx', p12d_ans_Idx)
    psychoJS.experiment.addData('p12d_corrAns',p12d_corrAns)
    psychoJS.experiment.addData('p12d_corrAns_Idx',p12d_corrAns_Idx)
    psychoJS.experiment.addData('p12d_countNext',p12d_countNext)
    psychoJS.experiment.addData('p12d_points',p12d_points)
    // the Routine "p12d_VS_cubes" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p12d_inTimeMaxDurationReached;
var p12d_inTimeMaxDuration;
var p12d_inTimeComponents;
function p12d_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p12d_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p12d_inTimeClock.reset();
    routineTimer.reset();
    p12d_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p12d_inTime.started', globalClock.getTime());
    p12d_inTimeMaxDuration = null
    // keep track of which components have finished
    p12d_inTimeComponents = [];
    
    p12d_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p12d_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p12d_inTime' ---
    // get current time
    t = p12d_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p12d_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p12d_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p12d_inTime' ---
    p12d_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p12d_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p12d_code_inTime
    psychoJS.experiment.addData("p12d_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p12d_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p13MaxDurationReached;
var p13MaxDuration;
var p13Components;
function p13RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p13' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p13Clock.reset();
    routineTimer.reset();
    p13MaxDurationReached = false;
    // update component parameters for each repeat
    // setup some python lists for storing info about the p13_mouse
    // current position of the mouse:
    p13_mouse.x = [];
    p13_mouse.y = [];
    p13_mouse.leftButton = [];
    p13_mouse.midButton = [];
    p13_mouse.rightButton = [];
    p13_mouse.time = [];
    p13_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p13_mouse.mouseClock.reset();
    p13_box_next.setFillColor(new util.Color(BoxNextColor));
    p13_box_next.setLineColor(new util.Color(BoxNextColor));
    psychoJS.experiment.addData('p13.started', globalClock.getTime());
    p13MaxDuration = null
    // keep track of which components have finished
    p13Components = [];
    p13Components.push(p13_img_instr);
    p13Components.push(p13_mouse);
    p13Components.push(p13_box_next);
    p13Components.push(p13_txt_next);
    
    p13Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p13RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p13' ---
    // get current time
    t = p13Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p13_img_instr* updates
    if (t >= 0.0 && p13_img_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13_img_instr.tStart = t;  // (not accounting for frame time here)
      p13_img_instr.frameNStart = frameN;  // exact frame index
      
      p13_img_instr.setAutoDraw(true);
    }
    
    
    // if p13_img_instr is active this frame...
    if (p13_img_instr.status === PsychoJS.Status.STARTED) {
    }
    
    // *p13_mouse* updates
    if (t >= 0.0 && p13_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13_mouse.tStart = t;  // (not accounting for frame time here)
      p13_mouse.frameNStart = frameN;  // exact frame index
      
      p13_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p13_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p13_mouse is active this frame...
    if (p13_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p13_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p13_mouse.clickableObjects = eval(p13_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p13_mouse.clickableObjects)) {
              p13_mouse.clickableObjects = [p13_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p13_mouse.clickableObjects) {
              if (obj.contains(p13_mouse)) {
                  gotValidClick = true;
                  p13_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p13_mouse.clickableObjects = eval(p13_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p13_mouse.clickableObjects)) {
              p13_mouse.clickableObjects = [p13_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p13_mouse.clickableObjects) {
              if (obj.contains(p13_mouse)) {
                  gotValidClick = true;
                  p13_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p13_mouse.getPos();
            p13_mouse.x.push(_mouseXYs[0]);
            p13_mouse.y.push(_mouseXYs[1]);
            p13_mouse.leftButton.push(_mouseButtons[0]);
            p13_mouse.midButton.push(_mouseButtons[1]);
            p13_mouse.rightButton.push(_mouseButtons[2]);
            p13_mouse.time.push(p13_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p13_box_next* updates
    if (t >= 0.0 && p13_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13_box_next.tStart = t;  // (not accounting for frame time here)
      p13_box_next.frameNStart = frameN;  // exact frame index
      
      p13_box_next.setAutoDraw(true);
    }
    
    
    // if p13_box_next is active this frame...
    if (p13_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13_txt_next* updates
    if (t >= 0.0 && p13_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13_txt_next.tStart = t;  // (not accounting for frame time here)
      p13_txt_next.frameNStart = frameN;  // exact frame index
      
      p13_txt_next.setAutoDraw(true);
    }
    
    
    // if p13_txt_next is active this frame...
    if (p13_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p13Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p13RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p13' ---
    p13Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p13.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p13_mouse.x', p13_mouse.x);
    psychoJS.experiment.addData('p13_mouse.y', p13_mouse.y);
    psychoJS.experiment.addData('p13_mouse.leftButton', p13_mouse.leftButton);
    psychoJS.experiment.addData('p13_mouse.midButton', p13_mouse.midButton);
    psychoJS.experiment.addData('p13_mouse.rightButton', p13_mouse.rightButton);
    psychoJS.experiment.addData('p13_mouse.time', p13_mouse.time);
    psychoJS.experiment.addData('p13_mouse.clicked_name', p13_mouse.clicked_name);
    
    // the Routine "p13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p13_leadinMaxDurationReached;
var p13_leadinMaxDuration;
var p13_leadinComponents;
function p13_leadinRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p13_leadin' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p13_leadinClock.reset(routineTimer.getTime());
    routineTimer.add(0.300000);
    p13_leadinMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p13_leadin.started', globalClock.getTime());
    p13_leadinMaxDuration = null
    // keep track of which components have finished
    p13_leadinComponents = [];
    p13_leadinComponents.push(text_2);
    
    p13_leadinComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p13_leadinRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p13_leadin' ---
    // get current time
    t = p13_leadinClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_2* updates
    if (t >= 0.0 && text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_2.tStart = t;  // (not accounting for frame time here)
      text_2.frameNStart = frameN;  // exact frame index
      
      text_2.setAutoDraw(true);
    }
    
    
    // if text_2 is active this frame...
    if (text_2.status === PsychoJS.Status.STARTED) {
    }
    
    frameRemains = 0.0 + 0.3 - psychoJS.window.monitorFramePeriod * 0.75;// most of one frame period left
    if (text_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      // keep track of stop time/frame for later
      text_2.tStop = t;  // not accounting for scr refresh
      text_2.frameNStop = frameN;  // exact frame index
      // update status
      text_2.status = PsychoJS.Status.FINISHED;
      text_2.setAutoDraw(false);
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p13_leadinComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p13_leadinRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p13_leadin' ---
    p13_leadinComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p13_leadin.stopped', globalClock.getTime());
    if (routineForceEnded) {
        routineTimer.reset();} else if (p13_leadinMaxDurationReached) {
        p13_leadinClock.add(p13_leadinMaxDuration);
    } else {
        p13_leadinClock.add(0.300000);
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p13a_Stroop_practiceMaxDurationReached;
var p13a_corrAns_Vec;
var p13a_stimID;
var p13a_Stroop_practiceMaxDuration;
var p13a_Stroop_practiceComponents;
function p13a_Stroop_practiceRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p13a_Stroop_practice' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p13a_Stroop_practiceClock.reset();
    routineTimer.reset();
    p13a_Stroop_practiceMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p13a_code
    p13a_corrAns_Vec = [0, 0, 0, 0];
    p13a_corrAns_Vec[p13a_corrAns_Idx] = 1;
    p13a_stimID = [p13a_txb1, p13a_txb2, p13a_txb3];
    k = 0;
    i = 0;
    if ((p13a_mouse.isPressedIn(p13a_box_next) && (p13a_isCorrect === 1))) {
        p13a_countNext = (p13a_countNext + 1);
        for (var val, _pj_c = 0, _pj_a = p13a_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p13a_ans_Idx = (p13a_ans_Idx + [i]);
                p13a_ans = ((p13a_ans + ",") + p13a_words[i]);
            }
            i = (i + 1);
        }
        loop_waitTillOK_p13a.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p13a_mouse.isPressedIn(p13a_box_next) && (p13a_isCorrect === 0))) {
            p13a_countNext = (p13a_countNext + 1);
            p13a_opTryBox = 1;
            p13a_opTryTxt = 1;
            p13a_opNextBox = 0;
            p13a_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p13a_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p13a_mouse.isPressedIn(thisStim) && (p13a_isPicked[k] === 0))) {
                    p13a_stimColors[k] = cAzul;
                    p13a_isPicked[k] = 1;
                    p13a_opTryBox = 0;
                    p13a_opTryTxt = 0;
                    p13a_opNextBox = 1;
                    p13a_opNextTxt = 1;
                } else {
                    p13a_stimColors[k] = cWhite;
                    p13a_isPicked[k] = 0;
                }
                if ((p13a_isPicked[p13a_corrAns_Idx] === 1)) {
                    p13a_isCorrect = 1;
                } else {
                    p13a_isCorrect = 0;
                }
            }
        }
    }
    
    p13a_txb1.setFillColor(new util.Color(p13a_stimColors[1]));
    p13a_txb2.setFillColor(new util.Color(p13a_stimColors[2]));
    p13a_txb3.setFillColor(new util.Color(p13a_stimColors[3]));
    p13a_box_next.setFillColor(new util.Color(BoxNextColor));
    p13a_box_next.setOpacity(p13a_opNextBox);
    p13a_box_next.setLineColor(new util.Color(cGrey));
    p13a_txt_next.setOpacity(p13a_opNextTxt);
    p13a_box_try.setFillColor(new util.Color(BoxTryColor));
    p13a_box_try.setOpacity(p13a_opTryBox);
    p13a_box_try.setLineColor(new util.Color(cGrey));
    p13a_txt_try.setOpacity(p13a_opTryTxt);
    // setup some python lists for storing info about the p13a_mouse
    // current position of the mouse:
    p13a_mouse.x = [];
    p13a_mouse.y = [];
    p13a_mouse.leftButton = [];
    p13a_mouse.midButton = [];
    p13a_mouse.rightButton = [];
    p13a_mouse.time = [];
    p13a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p13a_mouse.mouseClock.reset();
    p13a_txt_word.setColor(new util.Color([Col1, Col2, Col3]));
    p13a_txt_word.setText(StroopWord_a);
    psychoJS.experiment.addData('p13a_Stroop_practice.started', globalClock.getTime());
    p13a_Stroop_practiceMaxDuration = null
    // keep track of which components have finished
    p13a_Stroop_practiceComponents = [];
    p13a_Stroop_practiceComponents.push(p13a_txb1);
    p13a_Stroop_practiceComponents.push(p13a_txb2);
    p13a_Stroop_practiceComponents.push(p13a_txb3);
    p13a_Stroop_practiceComponents.push(p13a_box_next);
    p13a_Stroop_practiceComponents.push(p13a_txt_next);
    p13a_Stroop_practiceComponents.push(p13a_box_try);
    p13a_Stroop_practiceComponents.push(p13a_txt_try);
    p13a_Stroop_practiceComponents.push(p13a_mouse);
    p13a_Stroop_practiceComponents.push(p13a_txt1);
    p13a_Stroop_practiceComponents.push(p13a_txt2);
    p13a_Stroop_practiceComponents.push(p13a_txt3);
    p13a_Stroop_practiceComponents.push(p13a_box_word);
    p13a_Stroop_practiceComponents.push(p13a_txt_word);
    
    p13a_Stroop_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p13a_Stroop_practiceRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p13a_Stroop_practice' ---
    // get current time
    t = p13a_Stroop_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p13a_txb1* updates
    if (t >= 0.0 && p13a_txb1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txb1.tStart = t;  // (not accounting for frame time here)
      p13a_txb1.frameNStart = frameN;  // exact frame index
      
      p13a_txb1.setAutoDraw(true);
    }
    
    
    // if p13a_txb1 is active this frame...
    if (p13a_txb1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txb2* updates
    if (t >= 0.0 && p13a_txb2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txb2.tStart = t;  // (not accounting for frame time here)
      p13a_txb2.frameNStart = frameN;  // exact frame index
      
      p13a_txb2.setAutoDraw(true);
    }
    
    
    // if p13a_txb2 is active this frame...
    if (p13a_txb2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txb3* updates
    if (t >= 0.0 && p13a_txb3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txb3.tStart = t;  // (not accounting for frame time here)
      p13a_txb3.frameNStart = frameN;  // exact frame index
      
      p13a_txb3.setAutoDraw(true);
    }
    
    
    // if p13a_txb3 is active this frame...
    if (p13a_txb3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_box_next* updates
    if (t >= 0.0 && p13a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_box_next.tStart = t;  // (not accounting for frame time here)
      p13a_box_next.frameNStart = frameN;  // exact frame index
      
      p13a_box_next.setAutoDraw(true);
    }
    
    
    // if p13a_box_next is active this frame...
    if (p13a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txt_next* updates
    if (t >= 0.0 && p13a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt_next.tStart = t;  // (not accounting for frame time here)
      p13a_txt_next.frameNStart = frameN;  // exact frame index
      
      p13a_txt_next.setAutoDraw(true);
    }
    
    
    // if p13a_txt_next is active this frame...
    if (p13a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_box_try* updates
    if (t >= 0.0 && p13a_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_box_try.tStart = t;  // (not accounting for frame time here)
      p13a_box_try.frameNStart = frameN;  // exact frame index
      
      p13a_box_try.setAutoDraw(true);
    }
    
    
    // if p13a_box_try is active this frame...
    if (p13a_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txt_try* updates
    if (t >= 0.0 && p13a_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt_try.tStart = t;  // (not accounting for frame time here)
      p13a_txt_try.frameNStart = frameN;  // exact frame index
      
      p13a_txt_try.setAutoDraw(true);
    }
    
    
    // if p13a_txt_try is active this frame...
    if (p13a_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // *p13a_mouse* updates
    if (t >= 0.0 && p13a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_mouse.tStart = t;  // (not accounting for frame time here)
      p13a_mouse.frameNStart = frameN;  // exact frame index
      
      p13a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p13a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p13a_mouse is active this frame...
    if (p13a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p13a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p13a_mouse.clickableObjects = eval([p13a_txb1, p13a_txb2, p13a_txb3, p13a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p13a_mouse.clickableObjects)) {
              p13a_mouse.clickableObjects = [p13a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p13a_mouse.clickableObjects) {
              if (obj.contains(p13a_mouse)) {
                  gotValidClick = true;
                  p13a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p13a_mouse.clickableObjects = eval([p13a_txb1, p13a_txb2, p13a_txb3, p13a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p13a_mouse.clickableObjects)) {
              p13a_mouse.clickableObjects = [p13a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p13a_mouse.clickableObjects) {
              if (obj.contains(p13a_mouse)) {
                  gotValidClick = true;
                  p13a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p13a_mouse.getPos();
            p13a_mouse.x.push(_mouseXYs[0]);
            p13a_mouse.y.push(_mouseXYs[1]);
            p13a_mouse.leftButton.push(_mouseButtons[0]);
            p13a_mouse.midButton.push(_mouseButtons[1]);
            p13a_mouse.rightButton.push(_mouseButtons[2]);
            p13a_mouse.time.push(p13a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p13a_txt1* updates
    if (t >= 0.0 && p13a_txt1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt1.tStart = t;  // (not accounting for frame time here)
      p13a_txt1.frameNStart = frameN;  // exact frame index
      
      p13a_txt1.setAutoDraw(true);
    }
    
    
    // if p13a_txt1 is active this frame...
    if (p13a_txt1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txt2* updates
    if (t >= 0.0 && p13a_txt2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt2.tStart = t;  // (not accounting for frame time here)
      p13a_txt2.frameNStart = frameN;  // exact frame index
      
      p13a_txt2.setAutoDraw(true);
    }
    
    
    // if p13a_txt2 is active this frame...
    if (p13a_txt2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txt3* updates
    if (t >= 0.0 && p13a_txt3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt3.tStart = t;  // (not accounting for frame time here)
      p13a_txt3.frameNStart = frameN;  // exact frame index
      
      p13a_txt3.setAutoDraw(true);
    }
    
    
    // if p13a_txt3 is active this frame...
    if (p13a_txt3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_box_word* updates
    if (t >= 0.0 && p13a_box_word.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_box_word.tStart = t;  // (not accounting for frame time here)
      p13a_box_word.frameNStart = frameN;  // exact frame index
      
      p13a_box_word.setAutoDraw(true);
    }
    
    
    // if p13a_box_word is active this frame...
    if (p13a_box_word.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13a_txt_word* updates
    if (t >= 0.0 && p13a_txt_word.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13a_txt_word.tStart = t;  // (not accounting for frame time here)
      p13a_txt_word.frameNStart = frameN;  // exact frame index
      
      p13a_txt_word.setAutoDraw(true);
    }
    
    
    // if p13a_txt_word is active this frame...
    if (p13a_txt_word.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p13a_Stroop_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p13a_Stroop_practiceRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p13a_Stroop_practice' ---
    p13a_Stroop_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p13a_Stroop_practice.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p13a_mouse.x', p13a_mouse.x);
    psychoJS.experiment.addData('p13a_mouse.y', p13a_mouse.y);
    psychoJS.experiment.addData('p13a_mouse.leftButton', p13a_mouse.leftButton);
    psychoJS.experiment.addData('p13a_mouse.midButton', p13a_mouse.midButton);
    psychoJS.experiment.addData('p13a_mouse.rightButton', p13a_mouse.rightButton);
    psychoJS.experiment.addData('p13a_mouse.time', p13a_mouse.time);
    psychoJS.experiment.addData('p13a_mouse.clicked_name', p13a_mouse.clicked_name);
    
    // Run 'End Routine' code from p13a_code_ans
    psychoJS.experiment.addData('p13a_isCorrect',p13a_isCorrect)
    psychoJS.experiment.addData('p13a_ans', p13a_ans)
    psychoJS.experiment.addData('p13a_ans_Idx', p13a_ans_Idx)
    psychoJS.experiment.addData('p13a_corrAns',p13a_corrAns)
    psychoJS.experiment.addData('p13a_corrAns_Idx',p13a_corrAns_Idx)
    psychoJS.experiment.addData('p13a_countNext',p13a_countNext)
    psychoJS.experiment.addData('p13a_points',p13a_points)
    // the Routine "p13a_Stroop_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p13b_StroopMaxDurationReached;
var p13b_corrAns_Vec;
var p13b_stimID;
var p13b_StroopMaxDuration;
var p13b_StroopComponents;
function p13b_StroopRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p13b_Stroop' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p13b_StroopClock.reset();
    routineTimer.reset();
    p13b_StroopMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p13b_code
    p13b_corrAns_Vec = [0, 0, 0, 0];
    p13b_corrAns_Vec[p13b_corrAns_Idx] = 1;
    p13b_stimID = [p13b_txb1, p13b_txb2, p13b_txb3];
    k = 0;
    i = 0;
    if ((p13b_mouse.isPressedIn(p13b_box_next) && (p13b_isCorrect === 1))) {
        p13b_countNext = (p13b_countNext + 1);
        if ((p13b_isCorrect && (p13b_countNext === 1))) {
            p13b_points = 1;
        }
        for (var val, _pj_c = 0, _pj_a = p13b_isPicked, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
            val = _pj_a[_pj_c];
            if ((val !== 0)) {
                p13b_ans_Idx = (p13b_ans_Idx + [i]);
                p13b_ans = ((p13b_ans + ",") + p13b_words[i]);
            }
            i = (i + 1);
        }
        loop_waitTillOK_p13b.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p13b_mouse.isPressedIn(p13b_box_next) && (p13b_isCorrect === 0))) {
            p13b_countNext = (p13b_countNext + 1);
            p13b_opTryBox = 1;
            p13b_opTryTxt = 1;
            p13b_opNextBox = 0;
            p13b_opNextTxt = 0;
        } else {
            for (var thisStim, _pj_c = 0, _pj_a = p13b_stimID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisStim = _pj_a[_pj_c];
                k = (k + 1);
                if ((p13b_mouse.isPressedIn(thisStim) && (p13b_isPicked[k] === 0))) {
                    p13b_stimColors[k] = cAzul;
                    p13b_isPicked[k] = 1;
                    p13b_opTryBox = 0;
                    p13b_opTryTxt = 0;
                    p13b_opNextBox = 1;
                    p13b_opNextTxt = 1;
                } else {
                    p13b_stimColors[k] = cWhite;
                    p13b_isPicked[k] = 0;
                }
                if ((p13b_isPicked[p13b_corrAns_Idx] === 1)) {
                    p13b_isCorrect = 1;
                } else {
                    p13b_isCorrect = 0;
                }
            }
        }
    }
    
    p13b_txb1.setFillColor(new util.Color(p13b_stimColors[1]));
    p13b_txb1.setLineColor(new util.Color(cBlack));
    p13b_txb2.setFillColor(new util.Color(p13b_stimColors[2]));
    p13b_txb2.setLineColor(new util.Color(cBlack));
    p13b_txb3.setFillColor(new util.Color(p13b_stimColors[3]));
    p13b_txb3.setLineColor(new util.Color(cBlack));
    p13b_box_next.setFillColor(new util.Color(BoxNextColor));
    p13b_box_next.setOpacity(p13b_opNextBox);
    p13b_box_next.setLineColor(new util.Color(cGrey));
    p13b_txt_next.setOpacity(p13b_opNextTxt);
    p13b_box_try.setFillColor(new util.Color(BoxTryColor));
    p13b_box_try.setOpacity(p13b_opTryBox);
    p13b_box_try.setLineColor(new util.Color(cGrey));
    p13b_txt_try.setOpacity(p13b_opTryTxt);
    // setup some python lists for storing info about the p13b_mouse
    // current position of the mouse:
    p13b_mouse.x = [];
    p13b_mouse.y = [];
    p13b_mouse.leftButton = [];
    p13b_mouse.midButton = [];
    p13b_mouse.rightButton = [];
    p13b_mouse.time = [];
    p13b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p13b_mouse.mouseClock.reset();
    p13b_txt1.setColor(new util.Color(cBlack));
    p13b_txt2.setColor(new util.Color(cBlack));
    p13b_txt3.setColor(new util.Color(cBlack));
    p13b_txt_word.setColor(new util.Color([Col1b, Col2b, Col3b]));
    p13b_txt_word.setText(StroopWord_b);
    psychoJS.experiment.addData('p13b_Stroop.started', globalClock.getTime());
    p13b_StroopMaxDuration = null
    // keep track of which components have finished
    p13b_StroopComponents = [];
    p13b_StroopComponents.push(p13b_txb1);
    p13b_StroopComponents.push(p13b_txb2);
    p13b_StroopComponents.push(p13b_txb3);
    p13b_StroopComponents.push(p13b_box_next);
    p13b_StroopComponents.push(p13b_txt_next);
    p13b_StroopComponents.push(p13b_box_try);
    p13b_StroopComponents.push(p13b_txt_try);
    p13b_StroopComponents.push(p13b_mouse);
    p13b_StroopComponents.push(p13b_txt1);
    p13b_StroopComponents.push(p13b_txt2);
    p13b_StroopComponents.push(p13b_txt3);
    p13b_StroopComponents.push(p13b_box_word);
    p13b_StroopComponents.push(p13b_txt_word);
    
    p13b_StroopComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p13b_StroopRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p13b_Stroop' ---
    // get current time
    t = p13b_StroopClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p13b_txb1* updates
    if (t >= 0.0 && p13b_txb1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txb1.tStart = t;  // (not accounting for frame time here)
      p13b_txb1.frameNStart = frameN;  // exact frame index
      
      p13b_txb1.setAutoDraw(true);
    }
    
    
    // if p13b_txb1 is active this frame...
    if (p13b_txb1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txb2* updates
    if (t >= 0.0 && p13b_txb2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txb2.tStart = t;  // (not accounting for frame time here)
      p13b_txb2.frameNStart = frameN;  // exact frame index
      
      p13b_txb2.setAutoDraw(true);
    }
    
    
    // if p13b_txb2 is active this frame...
    if (p13b_txb2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txb3* updates
    if (t >= 0.0 && p13b_txb3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txb3.tStart = t;  // (not accounting for frame time here)
      p13b_txb3.frameNStart = frameN;  // exact frame index
      
      p13b_txb3.setAutoDraw(true);
    }
    
    
    // if p13b_txb3 is active this frame...
    if (p13b_txb3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_box_next* updates
    if (t >= 0.0 && p13b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_box_next.tStart = t;  // (not accounting for frame time here)
      p13b_box_next.frameNStart = frameN;  // exact frame index
      
      p13b_box_next.setAutoDraw(true);
    }
    
    
    // if p13b_box_next is active this frame...
    if (p13b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txt_next* updates
    if (t >= 0.0 && p13b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt_next.tStart = t;  // (not accounting for frame time here)
      p13b_txt_next.frameNStart = frameN;  // exact frame index
      
      p13b_txt_next.setAutoDraw(true);
    }
    
    
    // if p13b_txt_next is active this frame...
    if (p13b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_box_try* updates
    if (t >= 0.0 && p13b_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_box_try.tStart = t;  // (not accounting for frame time here)
      p13b_box_try.frameNStart = frameN;  // exact frame index
      
      p13b_box_try.setAutoDraw(true);
    }
    
    
    // if p13b_box_try is active this frame...
    if (p13b_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txt_try* updates
    if (t >= 0.0 && p13b_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt_try.tStart = t;  // (not accounting for frame time here)
      p13b_txt_try.frameNStart = frameN;  // exact frame index
      
      p13b_txt_try.setAutoDraw(true);
    }
    
    
    // if p13b_txt_try is active this frame...
    if (p13b_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // *p13b_mouse* updates
    if (t >= 0.0 && p13b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_mouse.tStart = t;  // (not accounting for frame time here)
      p13b_mouse.frameNStart = frameN;  // exact frame index
      
      p13b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p13b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p13b_mouse is active this frame...
    if (p13b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p13b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p13b_mouse.clickableObjects = eval([p13b_txb1, p13b_txb2, p13b_txb3, p13b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p13b_mouse.clickableObjects)) {
              p13b_mouse.clickableObjects = [p13b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p13b_mouse.clickableObjects) {
              if (obj.contains(p13b_mouse)) {
                  gotValidClick = true;
                  p13b_mouse.clicked_name.push(obj.name);
              }
          }
          if (!gotValidClick) {
              p13b_mouse.clicked_name.push(null);
          }
          _mouseXYs = p13b_mouse.getPos();
          p13b_mouse.x.push(_mouseXYs[0]);
          p13b_mouse.y.push(_mouseXYs[1]);
          p13b_mouse.leftButton.push(_mouseButtons[0]);
          p13b_mouse.midButton.push(_mouseButtons[1]);
          p13b_mouse.rightButton.push(_mouseButtons[2]);
          p13b_mouse.time.push(p13b_mouse.mouseClock.getTime());
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    
    // *p13b_txt1* updates
    if (t >= 0.0 && p13b_txt1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt1.tStart = t;  // (not accounting for frame time here)
      p13b_txt1.frameNStart = frameN;  // exact frame index
      
      p13b_txt1.setAutoDraw(true);
    }
    
    
    // if p13b_txt1 is active this frame...
    if (p13b_txt1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txt2* updates
    if (t >= 0.0 && p13b_txt2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt2.tStart = t;  // (not accounting for frame time here)
      p13b_txt2.frameNStart = frameN;  // exact frame index
      
      p13b_txt2.setAutoDraw(true);
    }
    
    
    // if p13b_txt2 is active this frame...
    if (p13b_txt2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txt3* updates
    if (t >= 0.0 && p13b_txt3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt3.tStart = t;  // (not accounting for frame time here)
      p13b_txt3.frameNStart = frameN;  // exact frame index
      
      p13b_txt3.setAutoDraw(true);
    }
    
    
    // if p13b_txt3 is active this frame...
    if (p13b_txt3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_box_word* updates
    if (t >= 0.0 && p13b_box_word.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_box_word.tStart = t;  // (not accounting for frame time here)
      p13b_box_word.frameNStart = frameN;  // exact frame index
      
      p13b_box_word.setAutoDraw(true);
    }
    
    
    // if p13b_box_word is active this frame...
    if (p13b_box_word.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p13b_txt_word* updates
    if (t >= 0.0 && p13b_txt_word.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p13b_txt_word.tStart = t;  // (not accounting for frame time here)
      p13b_txt_word.frameNStart = frameN;  // exact frame index
      
      p13b_txt_word.setAutoDraw(true);
    }
    
    
    // if p13b_txt_word is active this frame...
    if (p13b_txt_word.status === PsychoJS.Status.STARTED) {
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p13b_StroopComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p13b_StroopRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p13b_Stroop' ---
    p13b_StroopComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p13b_Stroop.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p13b_mouse.x', p13b_mouse.x);
    psychoJS.experiment.addData('p13b_mouse.y', p13b_mouse.y);
    psychoJS.experiment.addData('p13b_mouse.leftButton', p13b_mouse.leftButton);
    psychoJS.experiment.addData('p13b_mouse.midButton', p13b_mouse.midButton);
    psychoJS.experiment.addData('p13b_mouse.rightButton', p13b_mouse.rightButton);
    psychoJS.experiment.addData('p13b_mouse.time', p13b_mouse.time);
    psychoJS.experiment.addData('p13b_mouse.clicked_name', p13b_mouse.clicked_name);
    
    // Run 'End Routine' code from p13b_code_ans
    psychoJS.experiment.addData('p13b_isCorrect',p13b_isCorrect)
    psychoJS.experiment.addData('p13b_ans', p13b_ans)
    psychoJS.experiment.addData('p13b_ans_Idx', p13b_ans_Idx)
    psychoJS.experiment.addData('p13b_corrAns',p13b_corrAns)
    psychoJS.experiment.addData('p13b_corrAns_Idx',p13b_corrAns_Idx)
    psychoJS.experiment.addData('p13b_countNext',p13b_countNext)
    psychoJS.experiment.addData('p13b_points',p13b_points)
    // the Routine "p13b_Stroop" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p13_inTimeMaxDurationReached;
var p13_inTimeMaxDuration;
var p13_inTimeComponents;
function p13_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p13_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p13_inTimeClock.reset();
    routineTimer.reset();
    p13_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p13_inTime.started', globalClock.getTime());
    p13_inTimeMaxDuration = null
    // keep track of which components have finished
    p13_inTimeComponents = [];
    
    p13_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p13_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p13_inTime' ---
    // get current time
    t = p13_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p13_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p13_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p13_inTime' ---
    p13_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p13_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p13_code_inTime
    psychoJS.experiment.addData("p13_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p13_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p14_TMTMaxDurationReached;
var p14_TMTMaxDuration;
var p14_TMTComponents;
function p14_TMTRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p14_TMT' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p14_TMTClock.reset();
    routineTimer.reset();
    p14_TMTMaxDurationReached = false;
    // update component parameters for each repeat
    p14_img_instr.setImage(instrPath);
    p14_box_next.setFillColor(new util.Color(BoxNextColor));
    p14_box_next.setLineColor(new util.Color(BoxNextColor));
    // setup some python lists for storing info about the p14_mouse
    // current position of the mouse:
    p14_mouse.x = [];
    p14_mouse.y = [];
    p14_mouse.leftButton = [];
    p14_mouse.midButton = [];
    p14_mouse.rightButton = [];
    p14_mouse.time = [];
    p14_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p14_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p14_TMT.started', globalClock.getTime());
    p14_TMTMaxDuration = null
    // keep track of which components have finished
    p14_TMTComponents = [];
    p14_TMTComponents.push(p14_img_instr);
    p14_TMTComponents.push(p14_box_next);
    p14_TMTComponents.push(p14_txt_next);
    p14_TMTComponents.push(p14_mouse);
    
    p14_TMTComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p14_TMTRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p14_TMT' ---
    // get current time
    t = p14_TMTClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p14_img_instr* updates
    if (t >= 0.0 && p14_img_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14_img_instr.tStart = t;  // (not accounting for frame time here)
      p14_img_instr.frameNStart = frameN;  // exact frame index
      
      p14_img_instr.setAutoDraw(true);
    }
    
    
    // if p14_img_instr is active this frame...
    if (p14_img_instr.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14_box_next* updates
    if (t >= 0.0 && p14_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14_box_next.tStart = t;  // (not accounting for frame time here)
      p14_box_next.frameNStart = frameN;  // exact frame index
      
      p14_box_next.setAutoDraw(true);
    }
    
    
    // if p14_box_next is active this frame...
    if (p14_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14_txt_next* updates
    if (t >= 0.0 && p14_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14_txt_next.tStart = t;  // (not accounting for frame time here)
      p14_txt_next.frameNStart = frameN;  // exact frame index
      
      p14_txt_next.setAutoDraw(true);
    }
    
    
    // if p14_txt_next is active this frame...
    if (p14_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    // *p14_mouse* updates
    if (t >= 0.0 && p14_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14_mouse.tStart = t;  // (not accounting for frame time here)
      p14_mouse.frameNStart = frameN;  // exact frame index
      
      p14_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p14_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p14_mouse is active this frame...
    if (p14_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p14_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14_mouse.clickableObjects = eval(p14_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14_mouse.clickableObjects)) {
              p14_mouse.clickableObjects = [p14_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14_mouse.clickableObjects) {
              if (obj.contains(p14_mouse)) {
                  gotValidClick = true;
                  p14_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14_mouse.clickableObjects = eval(p14_box_next)
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14_mouse.clickableObjects)) {
              p14_mouse.clickableObjects = [p14_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14_mouse.clickableObjects) {
              if (obj.contains(p14_mouse)) {
                  gotValidClick = true;
                  p14_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p14_mouse.getPos();
            p14_mouse.x.push(_mouseXYs[0]);
            p14_mouse.y.push(_mouseXYs[1]);
            p14_mouse.leftButton.push(_mouseButtons[0]);
            p14_mouse.midButton.push(_mouseButtons[1]);
            p14_mouse.rightButton.push(_mouseButtons[2]);
            p14_mouse.time.push(p14_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p14_TMTComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p14_TMTRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p14_TMT' ---
    p14_TMTComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p14_TMT.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p14_mouse.x', p14_mouse.x);
    psychoJS.experiment.addData('p14_mouse.y', p14_mouse.y);
    psychoJS.experiment.addData('p14_mouse.leftButton', p14_mouse.leftButton);
    psychoJS.experiment.addData('p14_mouse.midButton', p14_mouse.midButton);
    psychoJS.experiment.addData('p14_mouse.rightButton', p14_mouse.rightButton);
    psychoJS.experiment.addData('p14_mouse.time', p14_mouse.time);
    psychoJS.experiment.addData('p14_mouse.clicked_name', p14_mouse.clicked_name);
    
    // the Routine "p14_TMT" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p14a_TMT_NumbersMaxDurationReached;
var p14a_keyID;
var p14a_TMT_NumbersMaxDuration;
var p14a_TMT_NumbersComponents;
function p14a_TMT_NumbersRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p14a_TMT_Numbers' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p14a_TMT_NumbersClock.reset();
    routineTimer.reset();
    p14a_TMT_NumbersMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p14a_code
    p14a_keyID = [p14a_sq1, p14a_sq2, p14a_sq3, p14a_sq4, p14a_sq5];
    k = 0;
    if ((p14a_mouse.isPressedIn(p14a_box_next) && (lenString_p14a === 5))) {
        p14a_countNext = (p14a_countNext + 1);
        if (((p14a_nErrors === 0) && (p14a_countNext === 1))) {
            p14a_isCorrect = 1;
            p14a_points = 1;
        }
        loop_waitTillOK_p14a.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p14a_mouse.isPressedIn(p14a_box_next) && (lenString_p14a < 5))) {
            p14a_countNext = (p14a_countNext + 1);
            p14a_opTryBox = 1;
            p14a_opTryTxt = 1;
            p14a_opNextBox = 0;
            p14a_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p14a_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p14a_mouse.isPressedIn(thisKey)) {
                    if (((p14a_isPicked[k] === 0) && (p14a_keyNum[k] === p14a_corrAns[(lenString_p14a + 1)]))) {
                        p14a_ans = (p14a_ans + p14a_keyNum[k]);
                        lenString_p14a = (lenString_p14a + 1);
                        p14a_stimColors[k] = cGreen;
                        p14a_isPicked[k] = 1;
                        p14a_opTryBox = 0;
                        p14a_opTryTxt = 0;
                        p14a_opNextBox = 1;
                        p14a_opNextTxt = 1;
                    } else {
                        if (((p14a_isPicked[k] === 0) && (p14a_keyNum[k] !== p14a_corrAns[(lenString_p14a + 1)]))) {
                            p14a_nErrors = (p14a_nErrors + 1);
                            p14a_stimColors[k] = cRed;
                            p14a_isPicked[k] = 0;
                            p14a_opTryBox = 0;
                            p14a_opTryTxt = 0;
                            p14a_opNextBox = 1;
                            p14a_opNextTxt = 1;
                        }
                    }
                } else {
                    if ((p14a_isPicked[k] === 0)) {
                        p14a_stimColors[k] = cWhite;
                    }
                }
            }
        }
    }
    
    p14a_sq1.setFillColor(new util.Color(p14a_stimColors[1]));
    p14a_sq2.setFillColor(new util.Color(p14a_stimColors[2]));
    p14a_sq3.setFillColor(new util.Color(p14a_stimColors[3]));
    p14a_sq4.setFillColor(new util.Color(p14a_stimColors[4]));
    p14a_sq5.setFillColor(new util.Color(p14a_stimColors[5]));
    p14a_box_try.setFillColor(new util.Color(BoxTryColor));
    p14a_box_try.setOpacity(p14a_opTryBox);
    p14a_box_try.setLineColor(new util.Color(cGrey));
    p14a_box_next.setFillColor(new util.Color(BoxNextColor));
    p14a_box_next.setOpacity(p14a_opNextBox);
    p14a_box_next.setLineColor(new util.Color(cGrey));
    p14a_txt_next.setOpacity(p14a_opNextTxt);
    p14a_txt_try.setOpacity(p14a_opTryTxt);
    // setup some python lists for storing info about the p14a_mouse
    // current position of the mouse:
    p14a_mouse.x = [];
    p14a_mouse.y = [];
    p14a_mouse.leftButton = [];
    p14a_mouse.midButton = [];
    p14a_mouse.rightButton = [];
    p14a_mouse.time = [];
    p14a_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p14a_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p14a_TMT_Numbers.started', globalClock.getTime());
    p14a_TMT_NumbersMaxDuration = null
    // keep track of which components have finished
    p14a_TMT_NumbersComponents = [];
    p14a_TMT_NumbersComponents.push(p14a_txt_instr1);
    p14a_TMT_NumbersComponents.push(p14a_txt_instr2);
    p14a_TMT_NumbersComponents.push(p14a_sq1);
    p14a_TMT_NumbersComponents.push(p14a_sq2);
    p14a_TMT_NumbersComponents.push(p14a_sq3);
    p14a_TMT_NumbersComponents.push(p14a_sq4);
    p14a_TMT_NumbersComponents.push(p14a_sq5);
    p14a_TMT_NumbersComponents.push(p14a_txt1);
    p14a_TMT_NumbersComponents.push(p14a_txt2);
    p14a_TMT_NumbersComponents.push(p14a_txt3);
    p14a_TMT_NumbersComponents.push(p14a_txt4);
    p14a_TMT_NumbersComponents.push(p14a_txt5);
    p14a_TMT_NumbersComponents.push(p14a_txtEND);
    p14a_TMT_NumbersComponents.push(p14a_txtSTART);
    p14a_TMT_NumbersComponents.push(p14a_box_try);
    p14a_TMT_NumbersComponents.push(p14a_box_next);
    p14a_TMT_NumbersComponents.push(p14a_txt_next);
    p14a_TMT_NumbersComponents.push(p14a_txt_try);
    p14a_TMT_NumbersComponents.push(p14a_mouse);
    
    p14a_TMT_NumbersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p14a_TMT_NumbersRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p14a_TMT_Numbers' ---
    // get current time
    t = p14a_TMT_NumbersClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p14a_txt_instr1* updates
    if (t >= 0.0 && p14a_txt_instr1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt_instr1.tStart = t;  // (not accounting for frame time here)
      p14a_txt_instr1.frameNStart = frameN;  // exact frame index
      
      p14a_txt_instr1.setAutoDraw(true);
    }
    
    
    // if p14a_txt_instr1 is active this frame...
    if (p14a_txt_instr1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt_instr2* updates
    if (t >= 0.0 && p14a_txt_instr2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt_instr2.tStart = t;  // (not accounting for frame time here)
      p14a_txt_instr2.frameNStart = frameN;  // exact frame index
      
      p14a_txt_instr2.setAutoDraw(true);
    }
    
    
    // if p14a_txt_instr2 is active this frame...
    if (p14a_txt_instr2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_sq1* updates
    if (t >= 0.0 && p14a_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_sq1.tStart = t;  // (not accounting for frame time here)
      p14a_sq1.frameNStart = frameN;  // exact frame index
      
      p14a_sq1.setAutoDraw(true);
    }
    
    
    // if p14a_sq1 is active this frame...
    if (p14a_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_sq2* updates
    if (t >= 0.0 && p14a_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_sq2.tStart = t;  // (not accounting for frame time here)
      p14a_sq2.frameNStart = frameN;  // exact frame index
      
      p14a_sq2.setAutoDraw(true);
    }
    
    
    // if p14a_sq2 is active this frame...
    if (p14a_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_sq3* updates
    if (t >= 0.0 && p14a_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_sq3.tStart = t;  // (not accounting for frame time here)
      p14a_sq3.frameNStart = frameN;  // exact frame index
      
      p14a_sq3.setAutoDraw(true);
    }
    
    
    // if p14a_sq3 is active this frame...
    if (p14a_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_sq4* updates
    if (t >= 0.0 && p14a_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_sq4.tStart = t;  // (not accounting for frame time here)
      p14a_sq4.frameNStart = frameN;  // exact frame index
      
      p14a_sq4.setAutoDraw(true);
    }
    
    
    // if p14a_sq4 is active this frame...
    if (p14a_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_sq5* updates
    if (t >= 0.0 && p14a_sq5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_sq5.tStart = t;  // (not accounting for frame time here)
      p14a_sq5.frameNStart = frameN;  // exact frame index
      
      p14a_sq5.setAutoDraw(true);
    }
    
    
    // if p14a_sq5 is active this frame...
    if (p14a_sq5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt1* updates
    if (t >= 0.0 && p14a_txt1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt1.tStart = t;  // (not accounting for frame time here)
      p14a_txt1.frameNStart = frameN;  // exact frame index
      
      p14a_txt1.setAutoDraw(true);
    }
    
    
    // if p14a_txt1 is active this frame...
    if (p14a_txt1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt2* updates
    if (t >= 0.0 && p14a_txt2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt2.tStart = t;  // (not accounting for frame time here)
      p14a_txt2.frameNStart = frameN;  // exact frame index
      
      p14a_txt2.setAutoDraw(true);
    }
    
    
    // if p14a_txt2 is active this frame...
    if (p14a_txt2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt3* updates
    if (t >= 0.0 && p14a_txt3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt3.tStart = t;  // (not accounting for frame time here)
      p14a_txt3.frameNStart = frameN;  // exact frame index
      
      p14a_txt3.setAutoDraw(true);
    }
    
    
    // if p14a_txt3 is active this frame...
    if (p14a_txt3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt4* updates
    if (t >= 0.0 && p14a_txt4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt4.tStart = t;  // (not accounting for frame time here)
      p14a_txt4.frameNStart = frameN;  // exact frame index
      
      p14a_txt4.setAutoDraw(true);
    }
    
    
    // if p14a_txt4 is active this frame...
    if (p14a_txt4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt5* updates
    if (t >= 0.0 && p14a_txt5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt5.tStart = t;  // (not accounting for frame time here)
      p14a_txt5.frameNStart = frameN;  // exact frame index
      
      p14a_txt5.setAutoDraw(true);
    }
    
    
    // if p14a_txt5 is active this frame...
    if (p14a_txt5.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txtEND* updates
    if (t >= 0.0 && p14a_txtEND.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txtEND.tStart = t;  // (not accounting for frame time here)
      p14a_txtEND.frameNStart = frameN;  // exact frame index
      
      p14a_txtEND.setAutoDraw(true);
    }
    
    
    // if p14a_txtEND is active this frame...
    if (p14a_txtEND.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txtSTART* updates
    if (t >= 0.0 && p14a_txtSTART.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txtSTART.tStart = t;  // (not accounting for frame time here)
      p14a_txtSTART.frameNStart = frameN;  // exact frame index
      
      p14a_txtSTART.setAutoDraw(true);
    }
    
    
    // if p14a_txtSTART is active this frame...
    if (p14a_txtSTART.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_box_try* updates
    if (t >= 0.0 && p14a_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_box_try.tStart = t;  // (not accounting for frame time here)
      p14a_box_try.frameNStart = frameN;  // exact frame index
      
      p14a_box_try.setAutoDraw(true);
    }
    
    
    // if p14a_box_try is active this frame...
    if (p14a_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_box_next* updates
    if (t >= 0.0 && p14a_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_box_next.tStart = t;  // (not accounting for frame time here)
      p14a_box_next.frameNStart = frameN;  // exact frame index
      
      p14a_box_next.setAutoDraw(true);
    }
    
    
    // if p14a_box_next is active this frame...
    if (p14a_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt_next* updates
    if (t >= 0.0 && p14a_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt_next.tStart = t;  // (not accounting for frame time here)
      p14a_txt_next.frameNStart = frameN;  // exact frame index
      
      p14a_txt_next.setAutoDraw(true);
    }
    
    
    // if p14a_txt_next is active this frame...
    if (p14a_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14a_txt_try* updates
    if (t >= 0.0 && p14a_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_txt_try.tStart = t;  // (not accounting for frame time here)
      p14a_txt_try.frameNStart = frameN;  // exact frame index
      
      p14a_txt_try.setAutoDraw(true);
    }
    
    
    // if p14a_txt_try is active this frame...
    if (p14a_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // *p14a_mouse* updates
    if (t >= 0.0 && p14a_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14a_mouse.tStart = t;  // (not accounting for frame time here)
      p14a_mouse.frameNStart = frameN;  // exact frame index
      
      p14a_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p14a_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p14a_mouse is active this frame...
    if (p14a_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p14a_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14a_mouse.clickableObjects = eval([p14a_sq1, p14a_sq2, p14a_sq3, p14a_sq4, p14a_sq5, p14a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14a_mouse.clickableObjects)) {
              p14a_mouse.clickableObjects = [p14a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14a_mouse.clickableObjects) {
              if (obj.contains(p14a_mouse)) {
                  gotValidClick = true;
                  p14a_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14a_mouse.clickableObjects = eval([p14a_sq1, p14a_sq2, p14a_sq3, p14a_sq4, p14a_sq5, p14a_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14a_mouse.clickableObjects)) {
              p14a_mouse.clickableObjects = [p14a_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14a_mouse.clickableObjects) {
              if (obj.contains(p14a_mouse)) {
                  gotValidClick = true;
                  p14a_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p14a_mouse.getPos();
            p14a_mouse.x.push(_mouseXYs[0]);
            p14a_mouse.y.push(_mouseXYs[1]);
            p14a_mouse.leftButton.push(_mouseButtons[0]);
            p14a_mouse.midButton.push(_mouseButtons[1]);
            p14a_mouse.rightButton.push(_mouseButtons[2]);
            p14a_mouse.time.push(p14a_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p14a_TMT_NumbersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p14a_TMT_NumbersRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p14a_TMT_Numbers' ---
    p14a_TMT_NumbersComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p14a_TMT_Numbers.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p14a_mouse.x', p14a_mouse.x);
    psychoJS.experiment.addData('p14a_mouse.y', p14a_mouse.y);
    psychoJS.experiment.addData('p14a_mouse.leftButton', p14a_mouse.leftButton);
    psychoJS.experiment.addData('p14a_mouse.midButton', p14a_mouse.midButton);
    psychoJS.experiment.addData('p14a_mouse.rightButton', p14a_mouse.rightButton);
    psychoJS.experiment.addData('p14a_mouse.time', p14a_mouse.time);
    psychoJS.experiment.addData('p14a_mouse.clicked_name', p14a_mouse.clicked_name);
    
    // Run 'End Routine' code from p14a_code_ans
    psychoJS.experiment.addData('p14a_isCorrect',p14a_isCorrect)
    psychoJS.experiment.addData('p14a_ans', p14a_ans)
    psychoJS.experiment.addData('p14a_corrAns',p14a_corrAns)
    psychoJS.experiment.addData('p14a_countNext',p14a_countNext)
    psychoJS.experiment.addData('p14a_points',p14a_points)
    psychoJS.experiment.addData('p14a_nErrors',p14a_nErrors)
    // the Routine "p14a_TMT_Numbers" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p14a_inTimeMaxDurationReached;
var p14a_inTimeMaxDuration;
var p14a_inTimeComponents;
function p14a_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p14a_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p14a_inTimeClock.reset();
    routineTimer.reset();
    p14a_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p14a_inTime.started', globalClock.getTime());
    p14a_inTimeMaxDuration = null
    // keep track of which components have finished
    p14a_inTimeComponents = [];
    
    p14a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p14a_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p14a_inTime' ---
    // get current time
    t = p14a_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p14a_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p14a_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p14a_inTime' ---
    p14a_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p14a_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p14a_code_inTime
    psychoJS.experiment.addData("p14a_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p14a_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p14b_TMT_LettersMaxDurationReached;
var p14b_keyID;
var p14b_TMT_LettersMaxDuration;
var p14b_TMT_LettersComponents;
function p14b_TMT_LettersRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p14b_TMT_Letters' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p14b_TMT_LettersClock.reset();
    routineTimer.reset();
    p14b_TMT_LettersMaxDurationReached = false;
    // update component parameters for each repeat
    // Run 'Begin Routine' code from p14b_code
    p14b_keyID = [p14b_sq1, p14b_sqA, p14b_sq2, p14b_sqB, p14b_sq3, p14b_sqC, p14b_sq4, p14b_sqD];
    k = 0;
    if ((p14b_mouse.isPressedIn(p14b_box_next) && (lenString_p14b === 8))) {
        p14b_countNext = (p14b_countNext + 1);
        if (((p14b_nErrors === 0) && (p14b_countNext === 1))) {
            p14b_isCorrect = 1;
            p14b_points = 1;
        }
        loop_waitTillOK_p14b.finished = true;
        skipThisTrial = true;
        continueRoutine = false;
    } else {
        if ((p14b_mouse.isPressedIn(p14b_box_next) && (lenString_p14b !== 8))) {
            p14b_countNext = (p14b_countNext + 1);
            p14b_opTryBox = 1;
            p14b_opTryTxt = 1;
            p14b_opNextBox = 0;
            p14b_opNextTxt = 0;
        } else {
            for (var thisKey, _pj_c = 0, _pj_a = p14b_keyID, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                thisKey = _pj_a[_pj_c];
                k = (k + 1);
                if (p14b_mouse.isPressedIn(thisKey)) {
                    if (((p14b_isPicked[k] === 0) && (p14b_keyNum[k] === p14b_corrAns[(lenString_p14b + 1)]))) {
                        p14b_ans = (p14b_ans + p14b_keyNum[k]);
                        lenString_p14b = (lenString_p14b + 1);
                        p14b_stimColors[k] = cGreen;
                        p14b_isPicked[k] = 1;
                        p14b_opTryBox = 0;
                        p14b_opTryTxt = 0;
                        p14b_opNextBox = 1;
                        p14b_opNextTxt = 1;
                    } else {
                        if (((p14b_isPicked[k] === 0) && (p14b_keyNum[k] !== p14b_corrAns[(lenString_p14b + 1)]))) {
                            p14b_nErrors = (p14b_nErrors + 1);
                            p14b_stimColors[k] = cRed;
                            p14b_isPicked[k] = 0;
                            p14b_opTryBox = 0;
                            p14b_opTryTxt = 0;
                            p14b_opNextBox = 1;
                            p14b_opNextTxt = 1;
                        }
                    }
                } else {
                    if ((p14b_isPicked[k] === 0)) {
                        p14b_stimColors[k] = cWhite;
                    }
                }
            }
        }
    }
    
    p14b_sq1.setFillColor(new util.Color(p14b_stimColors[1]));
    p14b_sqA.setFillColor(new util.Color(p14b_stimColors[2]));
    p14b_sq2.setFillColor(new util.Color(p14b_stimColors[3]));
    p14b_sqB.setFillColor(new util.Color(p14b_stimColors[4]));
    p14b_sq3.setFillColor(new util.Color(p14b_stimColors[5]));
    p14b_sqC.setFillColor(new util.Color(p14b_stimColors[6]));
    p14b_sq4.setFillColor(new util.Color(p14b_stimColors[7]));
    p14b_sqD.setFillColor(new util.Color(p14b_stimColors[8]));
    p14b_box_try.setFillColor(new util.Color(BoxTryColor));
    p14b_box_try.setOpacity(p14b_opTryBox);
    p14b_box_try.setLineColor(new util.Color(cGrey));
    p14b_box_next.setFillColor(new util.Color(BoxNextColor));
    p14b_box_next.setOpacity(p14b_opNextBox);
    p14b_box_next.setLineColor(new util.Color(cGrey));
    p14b_txt_next.setOpacity(p14b_opNextTxt);
    p14b_txt_try.setOpacity(p14b_opTryTxt);
    // setup some python lists for storing info about the p14b_mouse
    // current position of the mouse:
    p14b_mouse.x = [];
    p14b_mouse.y = [];
    p14b_mouse.leftButton = [];
    p14b_mouse.midButton = [];
    p14b_mouse.rightButton = [];
    p14b_mouse.time = [];
    p14b_mouse.clicked_name = [];
    gotValidClick = false; // until a click is received
    p14b_mouse.mouseClock.reset();
    psychoJS.experiment.addData('p14b_TMT_Letters.started', globalClock.getTime());
    p14b_TMT_LettersMaxDuration = null
    // keep track of which components have finished
    p14b_TMT_LettersComponents = [];
    p14b_TMT_LettersComponents.push(p14b_txt_instr1);
    p14b_TMT_LettersComponents.push(p14b_txt_instr2);
    p14b_TMT_LettersComponents.push(p14b_sq1);
    p14b_TMT_LettersComponents.push(p14b_sqA);
    p14b_TMT_LettersComponents.push(p14b_sq2);
    p14b_TMT_LettersComponents.push(p14b_sqB);
    p14b_TMT_LettersComponents.push(p14b_sq3);
    p14b_TMT_LettersComponents.push(p14b_sqC);
    p14b_TMT_LettersComponents.push(p14b_sq4);
    p14b_TMT_LettersComponents.push(p14b_sqD);
    p14b_TMT_LettersComponents.push(p14b_txt1);
    p14b_TMT_LettersComponents.push(p14b_txtA);
    p14b_TMT_LettersComponents.push(p14b_txt2);
    p14b_TMT_LettersComponents.push(p14b_txtB);
    p14b_TMT_LettersComponents.push(p14b_txt3);
    p14b_TMT_LettersComponents.push(p14b_txtC);
    p14b_TMT_LettersComponents.push(p14b_txt4);
    p14b_TMT_LettersComponents.push(p14b_txtD);
    p14b_TMT_LettersComponents.push(p14b_txtEND);
    p14b_TMT_LettersComponents.push(p14b_txtSTART);
    p14b_TMT_LettersComponents.push(p14b_box_try);
    p14b_TMT_LettersComponents.push(p14b_box_next);
    p14b_TMT_LettersComponents.push(p14b_txt_next);
    p14b_TMT_LettersComponents.push(p14b_txt_try);
    p14b_TMT_LettersComponents.push(p14b_mouse);
    
    p14b_TMT_LettersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p14b_TMT_LettersRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p14b_TMT_Letters' ---
    // get current time
    t = p14b_TMT_LettersClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *p14b_txt_instr1* updates
    if (t >= 0.0 && p14b_txt_instr1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt_instr1.tStart = t;  // (not accounting for frame time here)
      p14b_txt_instr1.frameNStart = frameN;  // exact frame index
      
      p14b_txt_instr1.setAutoDraw(true);
    }
    
    
    // if p14b_txt_instr1 is active this frame...
    if (p14b_txt_instr1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt_instr2* updates
    if (t >= 0.0 && p14b_txt_instr2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt_instr2.tStart = t;  // (not accounting for frame time here)
      p14b_txt_instr2.frameNStart = frameN;  // exact frame index
      
      p14b_txt_instr2.setAutoDraw(true);
    }
    
    
    // if p14b_txt_instr2 is active this frame...
    if (p14b_txt_instr2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sq1* updates
    if (t >= 0.0 && p14b_sq1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sq1.tStart = t;  // (not accounting for frame time here)
      p14b_sq1.frameNStart = frameN;  // exact frame index
      
      p14b_sq1.setAutoDraw(true);
    }
    
    
    // if p14b_sq1 is active this frame...
    if (p14b_sq1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sqA* updates
    if (t >= 0.0 && p14b_sqA.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sqA.tStart = t;  // (not accounting for frame time here)
      p14b_sqA.frameNStart = frameN;  // exact frame index
      
      p14b_sqA.setAutoDraw(true);
    }
    
    
    // if p14b_sqA is active this frame...
    if (p14b_sqA.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sq2* updates
    if (t >= 0.0 && p14b_sq2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sq2.tStart = t;  // (not accounting for frame time here)
      p14b_sq2.frameNStart = frameN;  // exact frame index
      
      p14b_sq2.setAutoDraw(true);
    }
    
    
    // if p14b_sq2 is active this frame...
    if (p14b_sq2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sqB* updates
    if (t >= 0.0 && p14b_sqB.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sqB.tStart = t;  // (not accounting for frame time here)
      p14b_sqB.frameNStart = frameN;  // exact frame index
      
      p14b_sqB.setAutoDraw(true);
    }
    
    
    // if p14b_sqB is active this frame...
    if (p14b_sqB.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sq3* updates
    if (t >= 0.0 && p14b_sq3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sq3.tStart = t;  // (not accounting for frame time here)
      p14b_sq3.frameNStart = frameN;  // exact frame index
      
      p14b_sq3.setAutoDraw(true);
    }
    
    
    // if p14b_sq3 is active this frame...
    if (p14b_sq3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sqC* updates
    if (t >= 0.0 && p14b_sqC.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sqC.tStart = t;  // (not accounting for frame time here)
      p14b_sqC.frameNStart = frameN;  // exact frame index
      
      p14b_sqC.setAutoDraw(true);
    }
    
    
    // if p14b_sqC is active this frame...
    if (p14b_sqC.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sq4* updates
    if (t >= 0.0 && p14b_sq4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sq4.tStart = t;  // (not accounting for frame time here)
      p14b_sq4.frameNStart = frameN;  // exact frame index
      
      p14b_sq4.setAutoDraw(true);
    }
    
    
    // if p14b_sq4 is active this frame...
    if (p14b_sq4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_sqD* updates
    if (t >= 0.0 && p14b_sqD.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_sqD.tStart = t;  // (not accounting for frame time here)
      p14b_sqD.frameNStart = frameN;  // exact frame index
      
      p14b_sqD.setAutoDraw(true);
    }
    
    
    // if p14b_sqD is active this frame...
    if (p14b_sqD.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt1* updates
    if (t >= 0.0 && p14b_txt1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt1.tStart = t;  // (not accounting for frame time here)
      p14b_txt1.frameNStart = frameN;  // exact frame index
      
      p14b_txt1.setAutoDraw(true);
    }
    
    
    // if p14b_txt1 is active this frame...
    if (p14b_txt1.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtA* updates
    if (t >= 0.0 && p14b_txtA.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtA.tStart = t;  // (not accounting for frame time here)
      p14b_txtA.frameNStart = frameN;  // exact frame index
      
      p14b_txtA.setAutoDraw(true);
    }
    
    
    // if p14b_txtA is active this frame...
    if (p14b_txtA.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt2* updates
    if (t >= 0.0 && p14b_txt2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt2.tStart = t;  // (not accounting for frame time here)
      p14b_txt2.frameNStart = frameN;  // exact frame index
      
      p14b_txt2.setAutoDraw(true);
    }
    
    
    // if p14b_txt2 is active this frame...
    if (p14b_txt2.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtB* updates
    if (t >= 0.0 && p14b_txtB.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtB.tStart = t;  // (not accounting for frame time here)
      p14b_txtB.frameNStart = frameN;  // exact frame index
      
      p14b_txtB.setAutoDraw(true);
    }
    
    
    // if p14b_txtB is active this frame...
    if (p14b_txtB.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt3* updates
    if (t >= 0.0 && p14b_txt3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt3.tStart = t;  // (not accounting for frame time here)
      p14b_txt3.frameNStart = frameN;  // exact frame index
      
      p14b_txt3.setAutoDraw(true);
    }
    
    
    // if p14b_txt3 is active this frame...
    if (p14b_txt3.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtC* updates
    if (t >= 0.0 && p14b_txtC.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtC.tStart = t;  // (not accounting for frame time here)
      p14b_txtC.frameNStart = frameN;  // exact frame index
      
      p14b_txtC.setAutoDraw(true);
    }
    
    
    // if p14b_txtC is active this frame...
    if (p14b_txtC.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt4* updates
    if (t >= 0.0 && p14b_txt4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt4.tStart = t;  // (not accounting for frame time here)
      p14b_txt4.frameNStart = frameN;  // exact frame index
      
      p14b_txt4.setAutoDraw(true);
    }
    
    
    // if p14b_txt4 is active this frame...
    if (p14b_txt4.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtD* updates
    if (t >= 0.0 && p14b_txtD.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtD.tStart = t;  // (not accounting for frame time here)
      p14b_txtD.frameNStart = frameN;  // exact frame index
      
      p14b_txtD.setAutoDraw(true);
    }
    
    
    // if p14b_txtD is active this frame...
    if (p14b_txtD.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtEND* updates
    if (t >= 0.0 && p14b_txtEND.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtEND.tStart = t;  // (not accounting for frame time here)
      p14b_txtEND.frameNStart = frameN;  // exact frame index
      
      p14b_txtEND.setAutoDraw(true);
    }
    
    
    // if p14b_txtEND is active this frame...
    if (p14b_txtEND.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txtSTART* updates
    if (t >= 0.0 && p14b_txtSTART.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txtSTART.tStart = t;  // (not accounting for frame time here)
      p14b_txtSTART.frameNStart = frameN;  // exact frame index
      
      p14b_txtSTART.setAutoDraw(true);
    }
    
    
    // if p14b_txtSTART is active this frame...
    if (p14b_txtSTART.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_box_try* updates
    if (t >= 0.0 && p14b_box_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_box_try.tStart = t;  // (not accounting for frame time here)
      p14b_box_try.frameNStart = frameN;  // exact frame index
      
      p14b_box_try.setAutoDraw(true);
    }
    
    
    // if p14b_box_try is active this frame...
    if (p14b_box_try.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_box_next* updates
    if (t >= 0.0 && p14b_box_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_box_next.tStart = t;  // (not accounting for frame time here)
      p14b_box_next.frameNStart = frameN;  // exact frame index
      
      p14b_box_next.setAutoDraw(true);
    }
    
    
    // if p14b_box_next is active this frame...
    if (p14b_box_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt_next* updates
    if (t >= 0.0 && p14b_txt_next.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt_next.tStart = t;  // (not accounting for frame time here)
      p14b_txt_next.frameNStart = frameN;  // exact frame index
      
      p14b_txt_next.setAutoDraw(true);
    }
    
    
    // if p14b_txt_next is active this frame...
    if (p14b_txt_next.status === PsychoJS.Status.STARTED) {
    }
    
    
    // *p14b_txt_try* updates
    if (t >= 0.0 && p14b_txt_try.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_txt_try.tStart = t;  // (not accounting for frame time here)
      p14b_txt_try.frameNStart = frameN;  // exact frame index
      
      p14b_txt_try.setAutoDraw(true);
    }
    
    
    // if p14b_txt_try is active this frame...
    if (p14b_txt_try.status === PsychoJS.Status.STARTED) {
    }
    
    // *p14b_mouse* updates
    if (t >= 0.0 && p14b_mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      p14b_mouse.tStart = t;  // (not accounting for frame time here)
      p14b_mouse.frameNStart = frameN;  // exact frame index
      
      p14b_mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = p14b_mouse.getPressed();  // if button is down already this ISN'T a new click
    }
    
    // if p14b_mouse is active this frame...
    if (p14b_mouse.status === PsychoJS.Status.STARTED) {
      _mouseButtons = p14b_mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14b_mouse.clickableObjects = eval([p14b_sq1, p14b_sqA, p14b_sq2, p14b_sqB, p14b_sq3, p14b_sqC, p14b_sq4, p14b_sqD, p14b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14b_mouse.clickableObjects)) {
              p14b_mouse.clickableObjects = [p14b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14b_mouse.clickableObjects) {
              if (obj.contains(p14b_mouse)) {
                  gotValidClick = true;
                  p14b_mouse.clicked_name.push(obj.name);
              }
          }
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          p14b_mouse.clickableObjects = eval([p14b_sq1, p14b_sqA, p14b_sq2, p14b_sqB, p14b_sq3, p14b_sqC, p14b_sq4, p14b_sqD, p14b_box_next])
          ;// make sure the mouse's clickable objects are an array
          if (!Array.isArray(p14b_mouse.clickableObjects)) {
              p14b_mouse.clickableObjects = [p14b_mouse.clickableObjects];
          }
          // iterate through clickable objects and check each
          for (const obj of p14b_mouse.clickableObjects) {
              if (obj.contains(p14b_mouse)) {
                  gotValidClick = true;
                  p14b_mouse.clicked_name.push(obj.name);
              }
          }
          if (gotValidClick === true) { 
            _mouseXYs = p14b_mouse.getPos();
            p14b_mouse.x.push(_mouseXYs[0]);
            p14b_mouse.y.push(_mouseXYs[1]);
            p14b_mouse.leftButton.push(_mouseButtons[0]);
            p14b_mouse.midButton.push(_mouseButtons[1]);
            p14b_mouse.rightButton.push(_mouseButtons[2]);
            p14b_mouse.time.push(p14b_mouse.mouseClock.getTime());
          }
          if (gotValidClick === true) { // end routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p14b_TMT_LettersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p14b_TMT_LettersRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p14b_TMT_Letters' ---
    p14b_TMT_LettersComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p14b_TMT_Letters.stopped', globalClock.getTime());
    // store data for psychoJS.experiment (ExperimentHandler)
    psychoJS.experiment.addData('p14b_mouse.x', p14b_mouse.x);
    psychoJS.experiment.addData('p14b_mouse.y', p14b_mouse.y);
    psychoJS.experiment.addData('p14b_mouse.leftButton', p14b_mouse.leftButton);
    psychoJS.experiment.addData('p14b_mouse.midButton', p14b_mouse.midButton);
    psychoJS.experiment.addData('p14b_mouse.rightButton', p14b_mouse.rightButton);
    psychoJS.experiment.addData('p14b_mouse.time', p14b_mouse.time);
    psychoJS.experiment.addData('p14b_mouse.clicked_name', p14b_mouse.clicked_name);
    
    // Run 'End Routine' code from p14b_code_ans
    psychoJS.experiment.addData('p14b_isCorrect',p14b_isCorrect)
    psychoJS.experiment.addData('p14b_ans', p14b_ans)
    psychoJS.experiment.addData('p14b_corrAns',p14b_corrAns)
    psychoJS.experiment.addData('p14b_countNext',p14b_countNext)
    psychoJS.experiment.addData('p14b_points',p14b_points)
    psychoJS.experiment.addData('p14b_nErrors',p14b_nErrors)
    // the Routine "p14b_TMT_Letters" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var p14b_inTimeMaxDurationReached;
var p14b_inTimeMaxDuration;
var p14b_inTimeComponents;
function p14b_inTimeRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'p14b_inTime' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    p14b_inTimeClock.reset();
    routineTimer.reset();
    p14b_inTimeMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('p14b_inTime.started', globalClock.getTime());
    p14b_inTimeMaxDuration = null
    // keep track of which components have finished
    p14b_inTimeComponents = [];
    
    p14b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function p14b_inTimeRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'p14b_inTime' ---
    // get current time
    t = p14b_inTimeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    p14b_inTimeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function p14b_inTimeRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'p14b_inTime' ---
    p14b_inTimeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('p14b_inTime.stopped', globalClock.getTime());
    // Run 'End Routine' code from p14b_code_inTime
    psychoJS.experiment.addData("p14b_globalClockTime", globalClock.getTime());
    if ((globalClock.getTime() >= maxtime)) {
        inTime = 0;
    }
    
    // the Routine "p14b_inTime" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var r_endMaxDurationReached;
var r_endMaxDuration;
var r_endComponents;
function r_endRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'r_end' ---
    t = 0;
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    // keep track of whether this Routine was forcibly ended
    routineForceEnded = false;
    r_endClock.reset(routineTimer.getTime());
    routineTimer.add(3.000000);
    r_endMaxDurationReached = false;
    // update component parameters for each repeat
    psychoJS.experiment.addData('r_end.started', globalClock.getTime());
    r_endMaxDuration = null
    // keep track of which components have finished
    r_endComponents = [];
    r_endComponents.push(pEND_img_instr);
    
    r_endComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function r_endRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'r_end' ---
    // get current time
    t = r_endClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pEND_img_instr* updates
    if (t >= 0.0 && pEND_img_instr.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pEND_img_instr.tStart = t;  // (not accounting for frame time here)
      pEND_img_instr.frameNStart = frameN;  // exact frame index
      
      pEND_img_instr.setAutoDraw(true);
    }
    
    
    // if pEND_img_instr is active this frame...
    if (pEND_img_instr.status === PsychoJS.Status.STARTED) {
    }
    
    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;// most of one frame period left
    if (pEND_img_instr.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      // keep track of stop time/frame for later
      pEND_img_instr.tStop = t;  // not accounting for scr refresh
      pEND_img_instr.frameNStop = frameN;  // exact frame index
      // update status
      pEND_img_instr.status = PsychoJS.Status.FINISHED;
      pEND_img_instr.setAutoDraw(false);
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      routineForceEnded = true;
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    r_endComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function r_endRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'r_end' ---
    r_endComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('r_end.stopped', globalClock.getTime());
    // Run 'End Routine' code from pEND_code
    psychoJS.experiment.addData("pEnd_globalClockTime", globalClock.getTime());
    
    if (routineForceEnded) {
        routineTimer.reset();} else if (r_endMaxDurationReached) {
        r_endClock.add(r_endMaxDuration);
    } else {
        r_endClock.add(3.000000);
    }
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


function importConditions(currentLoop) {
  return async function () {
    psychoJS.importAttributes(currentLoop.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}


async function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
